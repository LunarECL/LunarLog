// LunarLog - Single Header
// https://github.com/LunarECL/LunarLog
// Auto-generated by tools/generate_single_header.py
//
// Usage: just include this file.

#ifndef LUNAR_LOG_SINGLE_HEADER_HPP
#define LUNAR_LOG_SINGLE_HEADER_HPP

// --- lunar_log/core/log_level.hpp ---

// Windows.h defines ERROR as 0, which conflicts with the ERROR enum member.
// Undefine it here so LogLevel::ERROR is always usable regardless of include order.
#ifdef ERROR
#undef ERROR
#endif

namespace minta {
    enum class LogLevel {
        TRACE,
        DEBUG,
        INFO,
        WARN,
        ERROR,
        FATAL
    };

    inline const char *getLevelString(LogLevel level) {
        switch (level) {
            case LogLevel::TRACE: return "TRACE";
            case LogLevel::DEBUG: return "DEBUG";
            case LogLevel::INFO: return "INFO";
            case LogLevel::WARN: return "WARN";
            case LogLevel::ERROR: return "ERROR";
            case LogLevel::FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }
} // namespace minta


// --- lunar_log/core/log_common.hpp ---

#include <string>
#include <chrono>
#include <ctime>
#include <cstdio>
#include <cstdint>
#include <memory>
#include <sstream>
#include <iomanip>
#include <locale>
#include <cstdlib>
#include <cerrno>
#include <cmath>
#include <climits>
#include <vector>
#include <unordered_map>
#include <utility>


namespace minta {
namespace detail {
    template<typename T, typename... Args>
    inline std::unique_ptr<T> make_unique(Args&&... args) {
#if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
        return std::make_unique<T>(std::forward<Args>(args)...);
#else
        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
#endif
    }

    /// FNV-1a hash (32-bit) for template grouping.
    inline uint32_t fnv1a(const std::string &s) {
        uint32_t hash = 0x811c9dc5u;
        for (size_t i = 0; i < s.size(); ++i) {
            hash ^= static_cast<uint32_t>(static_cast<unsigned char>(s[i]));
            hash *= 0x01000193u;
        }
        return hash;
    }

    /// Format a uint32_t as an 8-char lowercase hex string.
    inline std::string toHexString(uint32_t value) {
        char buf[9];
        std::snprintf(buf, sizeof(buf), "%08x", value);
        return std::string(buf);
    }

    inline std::string formatTimestamp(const std::chrono::system_clock::time_point &time) {
        auto nowTime = std::chrono::system_clock::to_time_t(time);
        auto nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(time.time_since_epoch()) % 1000;

        std::tm tmBuf;
#if defined(_MSC_VER)
        localtime_s(&tmBuf, &nowTime);
#else
        localtime_r(&nowTime, &tmBuf);
#endif

        char buf[32];
        size_t pos = std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &tmBuf);
        if (pos == 0) {
            buf[0] = '\0';
        }
        // Defensive: ensure non-negative milliseconds for pre-epoch time points
        std::snprintf(buf + pos, sizeof(buf) - pos, ".%03d", static_cast<int>((nowMs.count() + 1000) % 1000));
        return std::string(buf);
    }
    // ----------------------------------------------------------------
    // Format helpers (shared by LunarLog and detail::reformatMessage)
    // ----------------------------------------------------------------

    /// Safely parse an integer from a string. Returns fallback on failure.
    inline int safeStoi(const std::string &s, int fallback = 0) {
        if (s.empty()) return fallback;
        for (size_t i = 0; i < s.size(); ++i) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) return fallback;
        }
        try { return std::stoi(s); } catch (...) { return fallback; }
    }

    /// Parse non-negative integer index safely with overflow clamping.
    /// Returns false if the input is empty or contains non-digits.
    inline bool tryParseIndex(const std::string &s, int &out) {
        if (s.empty()) return false;
        unsigned long long v = 0;
        for (size_t i = 0; i < s.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(s[i]);
            if (!std::isdigit(c)) return false;
            unsigned int digit = static_cast<unsigned int>(c - '0');
            if (v > (static_cast<unsigned long long>(INT_MAX) - digit) / 10ULL) {
                out = INT_MAX;
                return true;
            }
            v = v * 10ULL + digit;
        }
        out = static_cast<int>(v);
        return true;
    }

    /// Try to parse a string as a double. Returns true on success and sets out.
    inline bool tryParseDouble(const std::string &s, double &out) {
        if (s.empty()) return false;
        const char* start = s.c_str();
        char* end = nullptr;
        errno = 0;
        double val = std::strtod(start, &end);
        if (errno == ERANGE || end == start || static_cast<size_t>(end - start) != s.size()) {
            errno = 0;
            return false;
        }
        errno = 0;
        if (std::isinf(val) || std::isnan(val)) return false;
        out = val;
        return true;
    }

    inline double clampForLongLong(double val) {
        if (val != val) return 0.0;
        static const double kMinLL = static_cast<double>(LLONG_MIN + 1);
        static const double kMaxLL = std::nextafter(static_cast<double>(LLONG_MAX), 0.0);
        if (val < kMinLL) return kMinLL;
        if (val > kMaxLL) return kMaxLL;
        return val;
    }

    /// Format a double into a string using the given printf format.
    inline std::string snprintfDouble(const char* fmt, double val) {
        int needed = std::snprintf(nullptr, 0, fmt, val);
        if (needed < 0) return std::string();
        if (static_cast<size_t>(needed) < 256) {
            char stackBuf[256];
            std::snprintf(stackBuf, sizeof(stackBuf), fmt, val);
            return std::string(stackBuf);
        }
        std::vector<char> heapBuf(static_cast<size_t>(needed) + 1);
        std::snprintf(heapBuf.data(), heapBuf.size(), fmt, val);
        return std::string(heapBuf.data());
    }

    /// Format a double with precision.
    inline std::string snprintfDoublePrecision(const char* fmt, int precision, double val) {
        int needed = std::snprintf(nullptr, 0, fmt, precision, val);
        if (needed < 0) return std::string();
        if (static_cast<size_t>(needed) < 256) {
            char stackBuf[256];
            std::snprintf(stackBuf, sizeof(stackBuf), fmt, precision, val);
            return std::string(stackBuf);
        }
        std::vector<char> heapBuf(static_cast<size_t>(needed) + 1);
        std::snprintf(heapBuf.data(), heapBuf.size(), fmt, precision, val);
        return std::string(heapBuf.data());
    }

    /// Split "name:spec" into (name, spec). Returns (placeholder, "") if no colon.
    inline std::pair<std::string, std::string> splitPlaceholder(const std::string &placeholder) {
        size_t colonPos = placeholder.rfind(':');
        if (colonPos == std::string::npos) {
            return std::make_pair(placeholder, std::string());
        }
        return std::make_pair(placeholder.substr(0, colonPos), placeholder.substr(colonPos + 1));
    }

    // ----------------------------------------------------------------
    // Culture-specific formatting utilities
    // ----------------------------------------------------------------

    inline std::locale tryCreateLocale(const std::string& name) {
        if (name.empty() || name == "C" || name == "POSIX") {
            return std::locale::classic();
        }
        // Thread-local multi-entry cache: handles the realistic multi-sink
        // case (3-4 locales) without thrashing. Capped at 8 entries to
        // prevent unbounded growth from programmatic locale creation.
        thread_local std::unordered_map<std::string, std::locale> cache;
        auto it = cache.find(name);
        if (it != cache.end()) {
            return it->second;
        }
        std::locale result = std::locale::classic();
        try {
            result = std::locale(name);
        } catch (...) {
            if (name.find('.') == std::string::npos) {
                try {
                    result = std::locale(name + ".UTF-8");
                } catch (...) {}
            }
        }
        if (cache.size() < 8) {
            cache.emplace(name, result);
        }
        return result;
    }

    /// Format a number with locale-specific thousand/decimal separators.
    /// Used by the :n and :N format specs.
    inline std::string formatCultureNumber(const std::string& value, const std::string& localeName) {
        double numVal;
        if (!tryParseDouble(value, numVal)) return value;

        std::locale loc = tryCreateLocale(localeName);
        std::ostringstream oss;
        oss.imbue(loc);

        bool hasSciNotation = (value.find('e') != std::string::npos ||
                               value.find('E') != std::string::npos);
        if (hasSciNotation) {
            oss << std::fixed << std::setprecision(6) << numVal;
        } else {
            size_t dotPos = value.find('.');
            int precision = 0;
            if (dotPos != std::string::npos) {
                precision = static_cast<int>(value.size() - dotPos - 1);
                if (precision > 15) precision = 15;
            }
            oss << std::fixed << std::setprecision(precision) << numVal;
        }
        return oss.str();
    }

    /// Format a unix timestamp as a locale-aware date/time string.
    /// Used by the :d, :D, :t, :T, :f, :F format specs.
    inline std::string formatCultureDateTime(const std::string& value, char spec, const std::string& localeName) {
        double tsVal;
        if (!tryParseDouble(value, tsVal)) return value;

        time_t t = static_cast<time_t>(tsVal);
        std::tm tmBuf;
#if defined(_MSC_VER)
        localtime_s(&tmBuf, &t);
#else
        localtime_r(&t, &tmBuf);
#endif

        const char* fmt = nullptr;
        switch (spec) {
            case 'd': fmt = "%x"; break;                           // short date
            case 'D': fmt = "%A, %B %d, %Y"; break;               // long date
            case 't': fmt = "%H:%M"; break;                        // short time
            case 'T': fmt = "%H:%M:%S"; break;                     // long time
            case 'f': fmt = "%A, %B %d, %Y %H:%M"; break;         // full date + short time
            case 'F': fmt = "%A, %B %d, %Y %H:%M:%S"; break;      // full date + long time
            default: return value;
        }

        std::locale loc = tryCreateLocale(localeName);
        std::ostringstream oss;
        oss.imbue(loc);
        oss << std::put_time(&tmBuf, fmt);
        std::string result = oss.str();
        return result.empty() ? value : result;
    }

    // ----------------------------------------------------------------
    // Complete format spec application with locale support
    // ----------------------------------------------------------------

    /// Apply a format spec to a string value, with optional locale for culture specs.
    /// Handles all existing specs (.Nf, Nf, C, X, E, P, 0N) plus culture specs (n, N, d, D, t, T, f, F).
    inline std::string applyFormat(const std::string &value, const std::string &spec, const std::string &locale = "C") {
        if (spec.empty()) return value;

        double numVal;

        // Culture-specific: locale-aware number (n / N)
        if (spec == "n" || spec == "N") {
            return formatCultureNumber(value, locale);
        }

        // Culture-specific: date/time (d, D, t, T, f, F)
        if (spec.size() == 1) {
            char c = spec[0];
            if (c == 'd' || c == 'D' || c == 't' || c == 'T' || c == 'f' || c == 'F') {
                return formatCultureDateTime(value, c, locale);
            }
        }

        // Fixed-point: .Nf (e.g. ".2f", ".4f")
        if (spec.size() >= 2 && spec[0] == '.' && spec.back() == 'f') {
            if (!tryParseDouble(value, numVal)) return value;
            std::string digits = spec.substr(1, spec.size() - 2);
            int precision = safeStoi(digits, 6);
            if (precision > 50) precision = 50;
            return snprintfDoublePrecision("%.*f", precision, numVal);
        }

        // Fixed-point shorthand: Nf (e.g. "2f", "4f")
        if (spec.size() >= 2 && spec.back() == 'f' && std::isdigit(static_cast<unsigned char>(spec[0]))) {
            if (!tryParseDouble(value, numVal)) return value;
            int precision = safeStoi(spec.substr(0, spec.size() - 1), 6);
            if (precision > 50) precision = 50;
            return snprintfDoublePrecision("%.*f", precision, numVal);
        }

        // Currency: C or c
        if (spec == "C" || spec == "c") {
            if (!tryParseDouble(value, numVal)) return value;
            if (numVal < 0) {
                std::string formatted = snprintfDouble("%.2f", -numVal);
                if (formatted == "0.00") return "$0.00";
                return "-$" + formatted;
            } else {
                std::string formatted = snprintfDouble("%.2f", numVal);
                return "$" + formatted;
            }
        }

        // Hex: X (upper) or x (lower)
        if (spec == "X" || spec == "x") {
            if (!tryParseDouble(value, numVal)) return value;
            char buf[64];
            numVal = clampForLongLong(numVal);
            long long intVal = static_cast<long long>(numVal);
            unsigned long long uval;
            std::string result;
            if (intVal < 0) {
                result = "-";
                uval = 0ULL - static_cast<unsigned long long>(intVal);
            } else {
                uval = static_cast<unsigned long long>(intVal);
            }
            if (spec == "X") {
                std::snprintf(buf, sizeof(buf), "%llX", uval);
            } else {
                std::snprintf(buf, sizeof(buf), "%llx", uval);
            }
            result += buf;
            return result;
        }

        // Scientific: E (upper) or e (lower)
        if (spec == "E" || spec == "e") {
            if (!tryParseDouble(value, numVal)) return value;
            char buf[64];
            if (spec == "E") {
                std::snprintf(buf, sizeof(buf), "%E", numVal);
            } else {
                std::snprintf(buf, sizeof(buf), "%e", numVal);
            }
            return std::string(buf);
        }

        // Percentage: P or p
        if (spec == "P" || spec == "p") {
            if (!tryParseDouble(value, numVal)) return value;
            double pct = numVal * 100.0;
            if (!std::isfinite(pct)) pct = numVal;
            return snprintfDouble("%.2f", pct) + "%";
        }

        // Zero-padded integer: 0N (e.g. "04", "08")
        if (spec.size() >= 2 && spec[0] == '0' && std::isdigit(static_cast<unsigned char>(spec[1]))) {
            if (!tryParseDouble(value, numVal)) return value;
            char buf[64];
            numVal = clampForLongLong(numVal);
            int width = safeStoi(spec.substr(1), 1);
            if (width > 50) width = 50;
            long long intVal = static_cast<long long>(numVal);
            if (intVal < 0) {
                unsigned long long absVal = 0ULL - static_cast<unsigned long long>(intVal);
                std::snprintf(buf, sizeof(buf), "-%0*llu", width, absVal);
            } else {
                std::snprintf(buf, sizeof(buf), "%0*lld", width, intVal);
            }
            return std::string(buf);
        }

        // Unknown spec — return value as-is
        return value;
    }

    // ----------------------------------------------------------------
    // Shared placeholder iterator — single source of truth for
    // operator stripping, validation, and name/spec splitting.
    // ----------------------------------------------------------------

    /// Return true when every character in @p name is an ASCII digit.
    /// Used to distinguish indexed placeholders ({0}, {1}) from named ones ({user}).
    inline bool isIndexedPlaceholder(const std::string &name) {
        if (name.empty()) return false;
        for (size_t i = 0; i < name.size(); ++i) {
            if (!std::isdigit(static_cast<unsigned char>(name[i]))) return false;
        }
        return true;
    }

    struct ParsedPlaceholder {
        size_t startPos;
        size_t endPos;
        std::string name;
        std::string fullContent;
        std::string spec;
        char op;  // '@', '$', or 0
        std::vector<Transform> transforms;
        int indexedArg;  // >= 0 for indexed ({0},{1},...), -1 for named
        int alignment;   // >0 right-align, <0 left-align, 0 = none
    };

    /// Maximum alignment width to prevent excessive memory allocation.
    /// Placeholders like {name,999999999} are clamped to this value.
    static const int MAX_ALIGNMENT_WIDTH = 1024;

    inline int parseAlignment(const std::string &s) {
        if (s.empty()) return 0;
        size_t start = 0;
        if (s[0] == '-') start = 1;
        if (start >= s.size()) return 0;
        for (size_t i = start; i < s.size(); ++i) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) return 0;
        }
        try {
            int val = std::stoi(s);
            // Clamp to reasonable range to prevent excessive allocations
            if (val > MAX_ALIGNMENT_WIDTH) val = MAX_ALIGNMENT_WIDTH;
            if (val < -MAX_ALIGNMENT_WIDTH) val = -MAX_ALIGNMENT_WIDTH;
            return val;
        } catch (...) { return 0; }
    }

    inline std::string applyAlignment(const std::string &value, int alignment) {
        if (alignment == 0) return value;
        // Guard against INT_MIN: negating INT_MIN is undefined behavior
        // (signed integer overflow). Treat as max right-alignment.
        if (alignment == INT_MIN) alignment = -INT_MAX;
        size_t width = static_cast<size_t>(alignment < 0 ? -alignment : alignment);
        // Clamp width to prevent excessive memory allocation (defense-in-depth;
        // parseAlignment already clamps, but alignment may originate elsewhere).
        if (width > static_cast<size_t>(MAX_ALIGNMENT_WIDTH))
            width = static_cast<size_t>(MAX_ALIGNMENT_WIDTH);
        size_t charCount = utf8CharCount(value);
        if (charCount >= width) return value;
        size_t padding = width - charCount;
        if (alignment > 0) {
            return std::string(padding, ' ') + value;
        } else {
            return value + std::string(padding, ' ');
        }
    }

    inline size_t resolveValueSlot(int indexedArg, size_t namedOrdinal) {
        return indexedArg >= 0
            ? static_cast<size_t>(indexedArg)
            : namedOrdinal;
    }

    template<typename Callback>
    inline void forEachPlaceholder(const std::string &templateStr, Callback callback) {
        for (size_t i = 0; i < templateStr.length(); ++i) {
            if (templateStr[i] == '{') {
                if (i + 1 < templateStr.length() && templateStr[i + 1] == '{') {
                    ++i;
                    continue;
                }
                size_t endPos = templateStr.find('}', i);
                if (endPos == std::string::npos) break;
                std::string content = templateStr.substr(i + 1, endPos - i - 1);
                char op = 0;
                std::string nameContent = content;
                if (!content.empty() && (content[0] == '@' || content[0] == '$')) {
                    op = content[0];
                    nameContent = content.substr(1);
                    if (nameContent.empty() || nameContent[0] == '@' || nameContent[0] == '$'
                        || !(std::isalnum(static_cast<unsigned char>(nameContent[0])) || nameContent[0] == '_')) {
                        i = endPos;
                        continue;
                    }
                }
                std::string nameSpec = nameContent;
                std::vector<Transform> transforms;
                size_t pipePos = nameContent.find('|');
                if (pipePos != std::string::npos) {
                    nameSpec = nameContent.substr(0, pipePos);
                    transforms = parseTransforms(nameContent.substr(pipePos + 1));
                }
                auto parts = splitPlaceholder(nameSpec);
                int alignment = 0;
                std::string cleanName = parts.first;
                size_t commaPos = cleanName.find(',');
                if (commaPos != std::string::npos) {
                    alignment = parseAlignment(cleanName.substr(commaPos + 1));
                    cleanName.resize(commaPos);
                }
                int idxArg = -1;
                if (isIndexedPlaceholder(cleanName)) {
                    int parsed = -1;
                    if (tryParseIndex(cleanName, parsed)) idxArg = parsed;
                }
                callback(ParsedPlaceholder{i, endPos, cleanName, content, parts.second, op, std::move(transforms), idxArg, alignment});
                i = endPos;
            } else if (templateStr[i] == '}') {
                if (i + 1 < templateStr.length() && templateStr[i + 1] == '}') {
                    ++i;
                }
            }
        }
    }

    // ----------------------------------------------------------------
    // Shared template walker — single source of truth for the
    // template-walk algorithm used by both reformatMessage and
    // LunarLog::formatMessage.  Parameterized on placeholder type
    // (works with ParsedPlaceholder and LunarLog::PlaceholderInfo;
    // both expose startPos, endPos, spec).
    // ----------------------------------------------------------------

    template<typename PlaceholderType>
    inline std::string walkTemplate(const std::string &templateStr,
                                    const std::vector<PlaceholderType> &placeholders,
                                    const std::vector<std::string> &values,
                                    const std::string &locale) {
        std::string result;
        result.reserve(templateStr.length());
        size_t phIdx = 0;
        size_t pos = 0;
        size_t namedOrdinal = 0;

        while (pos < templateStr.length()) {
            if (phIdx < placeholders.size() && pos == placeholders[phIdx].startPos) {
                size_t valueIdx = resolveValueSlot(placeholders[phIdx].indexedArg, namedOrdinal);
                if (placeholders[phIdx].indexedArg < 0) {
                    ++namedOrdinal;
                }
                if (valueIdx < values.size()) {
                    std::string formatted = applyFormat(values[valueIdx], placeholders[phIdx].spec, locale);
                    if (!placeholders[phIdx].transforms.empty()) {
                        formatted = applyTransforms(formatted, placeholders[phIdx].transforms);
                    }
                    if (placeholders[phIdx].alignment != 0) {
                        formatted = applyAlignment(formatted, placeholders[phIdx].alignment);
                    }
                    result += formatted;
                } else if (placeholders[phIdx].indexedArg >= 0) {
                    // Indexed out-of-range renders as empty string
                } else {
                    result.append(templateStr, pos, placeholders[phIdx].endPos - pos + 1);
                }
                pos = placeholders[phIdx].endPos + 1;
                ++phIdx;
            } else if (templateStr[pos] == '{' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '{') {
                result += '{';
                pos += 2;
            } else if (templateStr[pos] == '}' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '}') {
                result += '}';
                pos += 2;
            } else {
                size_t litStart = pos;
                ++pos;
                while (pos < templateStr.length()) {
                    if (phIdx < placeholders.size() && pos == placeholders[phIdx].startPos) break;
                    if (templateStr[pos] == '{' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '{') break;
                    if (templateStr[pos] == '}' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '}') break;
                    ++pos;
                }
                result.append(templateStr, litStart, pos - litStart);
            }
        }
        return result;
    }

    // ----------------------------------------------------------------
    // Message re-rendering with a different locale
    // ----------------------------------------------------------------

    inline std::string reformatMessage(const std::string &templateStr,
                                       const std::vector<std::string> &values,
                                       const std::string &locale) {
        std::vector<ParsedPlaceholder> spans;
        forEachPlaceholder(templateStr, [&](const ParsedPlaceholder& ph) {
            spans.push_back(ph);
        });
        return walkTemplate(templateStr, spans, values, locale);
    }

} // namespace detail
} // namespace minta


// --- lunar_log/core/log_entry.hpp ---

#include <string>
#include <chrono>
#include <cstdint>
#include <vector>
#include <map>
#include <memory>
#include <thread>

namespace minta {
    struct PlaceholderProperty {
        std::string name;
        std::string value;
        char op;  // '@' (destructure), '$' (stringify), or 0 (none)
        std::vector<std::string> transforms;
    };

    struct LogEntry {
        LogLevel level = LogLevel::INFO;
        std::string message;
        std::chrono::system_clock::time_point timestamp;
        std::string templateStr;
        uint32_t templateHash = 0;
        std::vector<std::pair<std::string, std::string>> arguments;
        std::string file;
        int line = 0;
        std::string function;
        std::map<std::string, std::string> customContext;
        std::vector<PlaceholderProperty> properties;
        std::vector<std::string> tags;
        std::string locale = "C";
        std::thread::id threadId;
        std::unique_ptr<detail::ExceptionInfo> exception;

        /// Returns true if this log entry has exception information attached.
        bool hasException() const { return exception != nullptr; }

        LogEntry() = default;
        LogEntry(LogEntry&&) = default;
        LogEntry& operator=(LogEntry&&) = default;
        LogEntry(const LogEntry&) = delete;
        LogEntry& operator=(const LogEntry&) = delete;

        /// Backward-compatible positional constructor for custom formatters.
        LogEntry(LogLevel level_, std::string message_, std::chrono::system_clock::time_point timestamp_,
                 std::string templateStr_, uint32_t templateHash_,
                 std::vector<std::pair<std::string, std::string>> arguments_,
                 std::string file_, int line_, std::string function_,
                 std::map<std::string, std::string> customContext_,
                 std::vector<PlaceholderProperty> properties_,
                 std::vector<std::string> tags_ = {},
                 std::string locale_ = "C",
                 std::thread::id threadId_ = std::thread::id())
            : level(level_), message(std::move(message_)), timestamp(timestamp_),
              templateStr(std::move(templateStr_)), templateHash(templateHash_),
              arguments(std::move(arguments_)),
              file(std::move(file_)), line(line_), function(std::move(function_)),
              customContext(std::move(customContext_)), properties(std::move(properties_)),
              tags(std::move(tags_)),
              locale(std::move(locale_)),
              threadId(threadId_) {}
    };

namespace detail {
    /// Deep-copy a LogEntry (which is move-only due to unique_ptr member).
    inline LogEntry cloneEntry(const LogEntry& src) {
        LogEntry dst(
            src.level,
            std::string(src.message),
            src.timestamp,
            std::string(src.templateStr),
            src.templateHash,
            std::vector<std::pair<std::string, std::string>>(src.arguments),
            std::string(src.file),
            src.line,
            std::string(src.function),
            std::map<std::string, std::string>(src.customContext),
            std::vector<PlaceholderProperty>(src.properties),
            std::vector<std::string>(src.tags),
            std::string(src.locale),
            src.threadId
        );
        if (src.exception) {
            std::unique_ptr<ExceptionInfo> exCopy(new ExceptionInfo());
            exCopy->type = src.exception->type;
            exCopy->message = src.exception->message;
            exCopy->chain = src.exception->chain;
            dst.exception = std::move(exCopy);
        }
        return dst;
    }
} // namespace detail

} // namespace minta


// --- lunar_log/core/filter_rule.hpp ---

#include <string>
#include <stdexcept>

namespace minta {

    /// A single DSL filter rule parsed from a string.
    ///
    /// Supported syntax:
    ///   level >= LEVEL  /  level == LEVEL  /  level != LEVEL
    ///   message contains 'text'
    ///   message startswith 'text'
    ///   context has 'key'
    ///   context key == 'value'
    ///   template == 'exact template'
    ///   template contains 'partial'
    ///   not <rule>
    ///
    /// Multiple rules are AND-combined externally (each must return true).
    class FilterRule {
    public:
        /// Parse a rule string into a FilterRule.
        /// Throws std::invalid_argument on unrecognized syntax.
        ///
        /// String values are delimited by outer single quotes with no escape
        /// sequences. Embedded quotes work by accident (outermost pair is
        /// stripped). There is no way to match a value that both starts and
        /// ends with a single quote.
        static FilterRule parse(const std::string& rule) {
            std::string trimmed = trim(rule);
            if (trimmed.empty()) {
                throw std::invalid_argument("Empty filter rule");
            }

            bool negated = false;
            if (startsWith(trimmed, "not ")) {
                negated = true;
                trimmed = trim(trimmed.substr(4));
                if (trimmed.empty()) {
                    throw std::invalid_argument("Empty rule after 'not'");
                }
            }

            FilterRule r;
            r.m_negated = negated;

            // level >= LEVEL  /  level == LEVEL  /  level != LEVEL
            if (startsWith(trimmed, "level ")) {
                std::string rest = trim(trimmed.substr(6));
                if (startsWith(rest, ">= ")) {
                    r.m_type = RuleType::LevelGe;
                    r.m_level = parseLevel(trim(rest.substr(3)));
                } else if (startsWith(rest, "== ")) {
                    r.m_type = RuleType::LevelEq;
                    r.m_level = parseLevel(trim(rest.substr(3)));
                } else if (startsWith(rest, "!= ")) {
                    r.m_type = RuleType::LevelNe;
                    r.m_level = parseLevel(trim(rest.substr(3)));
                } else {
                    throw std::invalid_argument("Invalid level operator in rule: " + rule);
                }
                return r;
            }

            // message contains 'text'  /  message startswith 'text'
            if (startsWith(trimmed, "message ")) {
                std::string rest = trim(trimmed.substr(8));
                if (startsWith(rest, "contains ")) {
                    r.m_type = RuleType::MessageContains;
                    r.m_value = extractQuoted(trim(rest.substr(9)), rule);
                } else if (startsWith(rest, "startswith ")) {
                    r.m_type = RuleType::MessageStartsWith;
                    r.m_value = extractQuoted(trim(rest.substr(11)), rule);
                } else {
                    throw std::invalid_argument("Invalid message operator in rule: " + rule);
                }
                return r;
            }

            // context has 'key'  /  context key == 'value'
            // NOTE: Context keys containing spaces are not supported.
            // The parser splits on whitespace, so "context my key == 'val'"
            // would be misinterpreted.
            if (startsWith(trimmed, "context ")) {
                std::string rest = trim(trimmed.substr(8));
                if (startsWith(rest, "has ")) {
                    r.m_type = RuleType::ContextHas;
                    r.m_value = extractQuoted(trim(rest.substr(4)), rule);
                } else {
                    size_t spacePos = rest.find(' ');
                    if (spacePos == std::string::npos) {
                        throw std::invalid_argument("Invalid context rule: " + rule);
                    }
                    std::string key = rest.substr(0, spacePos);
                    std::string afterKey = trim(rest.substr(spacePos + 1));
                    if (startsWith(afterKey, "== ")) {
                        r.m_type = RuleType::ContextKeyEq;
                        r.m_key = key;
                        r.m_value = extractQuoted(trim(afterKey.substr(3)), rule);
                    } else {
                        throw std::invalid_argument("Invalid context operator in rule: " + rule);
                    }
                }
                return r;
            }

            // template == 'exact template'  /  template contains 'partial'
            if (startsWith(trimmed, "template ")) {
                std::string rest = trim(trimmed.substr(9));
                if (startsWith(rest, "== ")) {
                    r.m_type = RuleType::TemplateEq;
                    r.m_value = extractQuoted(trim(rest.substr(3)), rule);
                } else if (startsWith(rest, "contains ")) {
                    r.m_type = RuleType::TemplateContains;
                    r.m_value = extractQuoted(trim(rest.substr(9)), rule);
                } else {
                    throw std::invalid_argument("Invalid template operator in rule: " + rule);
                }
                return r;
            }

            throw std::invalid_argument("Unrecognized filter rule: " + rule);
        }

        /// Evaluate this rule against a log entry.
        /// Returns true if the entry passes (should be kept).
        bool evaluate(const LogEntry& entry) const {
            bool result = false;
            switch (m_type) {
                case RuleType::LevelGe:
                    result = entry.level >= m_level;
                    break;
                case RuleType::LevelEq:
                    result = entry.level == m_level;
                    break;
                case RuleType::LevelNe:
                    result = entry.level != m_level;
                    break;
                case RuleType::MessageContains:
                    result = entry.message.find(m_value) != std::string::npos;
                    break;
                case RuleType::MessageStartsWith:
                    result = entry.message.size() >= m_value.size() &&
                             entry.message.compare(0, m_value.size(), m_value) == 0;
                    break;
                case RuleType::ContextHas:
                    result = entry.customContext.count(m_value) > 0;
                    break;
                case RuleType::ContextKeyEq:
                    {
                        auto it = entry.customContext.find(m_key);
                        result = it != entry.customContext.end() && it->second == m_value;
                    }
                    break;
                case RuleType::TemplateEq:
                    result = entry.templateStr == m_value;
                    break;
                case RuleType::TemplateContains:
                    result = entry.templateStr.find(m_value) != std::string::npos;
                    break;
            }
            return m_negated ? !result : result;
        }

    private:
        enum class RuleType {
            LevelGe,
            LevelEq,
            LevelNe,
            MessageContains,
            MessageStartsWith,
            ContextHas,
            ContextKeyEq,
            TemplateEq,
            TemplateContains
        };

        RuleType m_type;
        bool m_negated;
        LogLevel m_level;
        std::string m_value;
        std::string m_key;

        FilterRule() : m_type(RuleType::LevelGe), m_negated(false), m_level(LogLevel::TRACE) {}

        static LogLevel parseLevel(const std::string& s) {
            if (s == "TRACE") return LogLevel::TRACE;
            if (s == "DEBUG") return LogLevel::DEBUG;
            if (s == "INFO")  return LogLevel::INFO;
            if (s == "WARN")  return LogLevel::WARN;
            if (s == "ERROR") return LogLevel::ERROR;
            if (s == "FATAL") return LogLevel::FATAL;
            throw std::invalid_argument("Unknown log level: " + s);
        }

        /// Extract a single-quoted string value, e.g. 'hello world'.
        static std::string extractQuoted(const std::string& s, const std::string& rule) {
            if (s.size() >= 2 && s.front() == '\'' && s.back() == '\'') {
                return s.substr(1, s.size() - 2);
            }
            throw std::invalid_argument("Expected single-quoted string in rule: " + rule);
        }

        static std::string trim(const std::string& s) {
            size_t start = 0;
            while (start < s.size() && (s[start] == ' ' || s[start] == '\t')) ++start;
            size_t end = s.size();
            while (end > start && (s[end - 1] == ' ' || s[end - 1] == '\t')) --end;
            return s.substr(start, end - start);
        }

        static bool startsWith(const std::string& s, const std::string& prefix) {
            return s.size() >= prefix.size() && s.compare(0, prefix.size(), prefix) == 0;
        }
    };

} // namespace minta


// --- lunar_log/core/compact_filter.hpp ---

#include <string>
#include <vector>
#include <stdexcept>
#include <cctype>

namespace minta {
namespace detail {

    inline std::string compactToUpper(const std::string& s) {
        std::string result;
        result.reserve(s.size());
        for (size_t i = 0; i < s.size(); ++i) {
            result += static_cast<char>(std::toupper(static_cast<unsigned char>(s[i])));
        }
        return result;
    }

    inline std::string compactStripQuotes(const std::string& s) {
        if (s.size() >= 2) {
            char first = s.front();
            char last = s.back();
            if ((first == '"' && last == '"') || (first == '\'' && last == '\'')) {
                return s.substr(1, s.size() - 2);
            }
        }
        return s;
    }

    /// Wrap a value in single quotes for DSL consumption.
    /// Throws if the value contains a single quote (cannot be safely
    /// represented in the DSL's outermost-quote-stripping parser).
    inline std::string compactDslQuote(const std::string& s) {
        for (size_t i = 0; i < s.size(); ++i) {
            if (s[i] == '\'') {
                throw std::invalid_argument(
                    "Compact filter value cannot contain single quotes (DSL limitation). "
                    "Use addFilterRule() or setFilter() predicate instead. Value: " + s);
            }
        }
        return "'" + s + "'";
    }

    inline bool compactIsLevelName(const std::string& upper) {
        return upper == "TRACE" || upper == "DEBUG" || upper == "INFO" ||
               upper == "WARN"  || upper == "WARNING" || upper == "ERROR" || upper == "FATAL";
    }

    inline FilterRule parseCompactToken(const std::string& token) {
        if (token.empty()) {
            throw std::invalid_argument("Empty compact filter token");
        }

        if (token.size() >= 2 && token.back() == '+') {
            std::string levelStr = compactToUpper(token.substr(0, token.size() - 1));
            if (compactIsLevelName(levelStr)) {
                if (levelStr == "WARNING") levelStr = "WARN";
                return FilterRule::parse("level >= " + levelStr);
            }
        }

        if (token.size() > 5 && token[0] == '!' && token[1] == 't' &&
            token[2] == 'p' && token[3] == 'l' && token[4] == ':') {
            std::string pattern = compactStripQuotes(token.substr(5));
            return FilterRule::parse("not template == " + compactDslQuote(pattern));
        }

        if (token.size() > 4 && token[0] == 't' && token[1] == 'p' &&
            token[2] == 'l' && token[3] == ':') {
            std::string pattern = compactStripQuotes(token.substr(4));
            return FilterRule::parse("template == " + compactDslQuote(pattern));
        }

        if (token.size() > 2 && token[0] == '!' && token[1] == '~') {
            std::string keyword = compactStripQuotes(token.substr(2));
            if (keyword.empty()) {
                throw std::invalid_argument("Empty keyword in compact filter: " + token);
            }
            return FilterRule::parse("not message contains " + compactDslQuote(keyword));
        }

        if (token.size() > 1 && token[0] == '~') {
            std::string keyword = compactStripQuotes(token.substr(1));
            if (keyword.empty()) {
                throw std::invalid_argument("Empty keyword in compact filter: " + token);
            }
            return FilterRule::parse("message contains " + compactDslQuote(keyword));
        }

        if (token.size() > 4 && token[0] == 'c' && token[1] == 't' &&
            token[2] == 'x' && token[3] == ':') {
            std::string rest = token.substr(4);
            size_t eqPos = std::string::npos;
            bool inQuote = false;
            char quoteChar = 0;
            for (size_t j = 0; j < rest.size(); ++j) {
                if (!inQuote && (rest[j] == '"' || rest[j] == '\'')) {
                    inQuote = true;
                    quoteChar = rest[j];
                } else if (inQuote && rest[j] == quoteChar) {
                    inQuote = false;
                } else if (!inQuote && rest[j] == '=') {
                    eqPos = j;
                    break;
                }
            }

            if (eqPos != std::string::npos && eqPos > 0) {
                std::string key = compactStripQuotes(rest.substr(0, eqPos));
                std::string val = compactStripQuotes(rest.substr(eqPos + 1));
                if (key.empty()) {
                    throw std::invalid_argument("Empty context key in compact filter: " + token);
                }
                if (val.empty()) {
                    throw std::invalid_argument("Empty context value in compact filter: " + token);
                }
                return FilterRule::parse("context " + key + " == " + compactDslQuote(val));
            } else {
                std::string key = compactStripQuotes(rest);
                return FilterRule::parse("context has " + compactDslQuote(key));
            }
        }

        // Catch bare prefixes that fall through because size guards above
        // use strict > (e.g., token.size() > 4 for ctx:). Keep in sync.
        if (token == "ctx:" || token == "tpl:" || token == "!tpl:") {
            throw std::invalid_argument("Missing value after '" + token + "' in compact filter");
        }
        throw std::invalid_argument("Unrecognized compact filter token: " + token);
    }

    /// Parse a compact filter expression string into FilterRule objects.
    /// Tokens are space-separated and AND-combined.
    /// Syntax: LEVEL+, ~keyword, !~keyword, ctx:key, ctx:key=val, tpl:pattern, !tpl:pattern
    /// Level names are case-insensitive. Keywords are case-sensitive.
    inline std::vector<FilterRule> parseCompactFilter(const std::string& expr) {
        std::vector<FilterRule> rules;
        if (expr.empty()) return rules;

        std::vector<std::string> tokens;
        size_t i = 0;
        while (i < expr.size()) {
            while (i < expr.size() && (expr[i] == ' ' || expr[i] == '\t')) ++i;
            if (i >= expr.size()) break;

            std::string token;
            while (i < expr.size() && expr[i] != ' ' && expr[i] != '\t') {
                if (expr[i] == '"' || expr[i] == '\'') {
                    char quote = expr[i];
                    token += quote;
                    ++i;
                    while (i < expr.size() && expr[i] != quote) {
                        token += expr[i];
                        ++i;
                    }
                    if (i >= expr.size()) {
                        throw std::invalid_argument(
                            "Unterminated quote in compact filter expression");
                    }
                    token += expr[i];
                    ++i;
                } else {
                    token += expr[i];
                    ++i;
                }
            }
            if (!token.empty()) {
                tokens.push_back(token);
            }
        }

        for (size_t t = 0; t < tokens.size(); ++t) {
            rules.push_back(parseCompactToken(tokens[t]));
        }

        return rules;
    }

} // namespace detail
} // namespace minta


// --- lunar_log/core/rolling_policy.hpp ---

#include <string>
#include <cstdint>

namespace minta {

    enum class RollInterval {
        None,
        Daily,
        Hourly
    };

    class RollingPolicy {
    public:
        /// Size-based rolling: rotate when the current file reaches maxBytes.
        static RollingPolicy size(const std::string& path, std::uint64_t maxBytes) {
            RollingPolicy p;
            p.m_basePath = path;
            p.m_maxSizeBytes = maxBytes;
            p.m_rollInterval = RollInterval::None;
            return p;
        }

        /// Daily time-based rolling.
        static RollingPolicy daily(const std::string& path) {
            RollingPolicy p;
            p.m_basePath = path;
            p.m_maxSizeBytes = 0;
            p.m_rollInterval = RollInterval::Daily;
            return p;
        }

        /// Hourly time-based rolling.
        static RollingPolicy hourly(const std::string& path) {
            RollingPolicy p;
            p.m_basePath = path;
            p.m_maxSizeBytes = 0;
            p.m_rollInterval = RollInterval::Hourly;
            return p;
        }

        /// Maximum number of rolled files to keep (0 = unlimited).
        RollingPolicy& maxFiles(unsigned int n) {
            m_maxFiles = n;
            return *this;
        }

        /// Maximum size per file (enables hybrid size+time rolling).
        RollingPolicy& maxSize(std::uint64_t bytes) {
            m_maxSizeBytes = bytes;
            return *this;
        }

        /// Maximum total size of all rolled files combined (0 = unlimited).
        /// When exceeded, the oldest rolled files are deleted until under the limit.
        RollingPolicy& maxTotalSize(std::uint64_t bytes) {
            m_maxTotalSize = bytes;
            return *this;
        }

        // --- Accessors ---
        const std::string& basePath()         const { return m_basePath; }
        std::uint64_t      maxSizeBytes()     const { return m_maxSizeBytes; }
        RollInterval       rollInterval()     const { return m_rollInterval; }
        unsigned int       maxFilesCount()    const { return m_maxFiles; }
        std::uint64_t      maxTotalSizeBytes() const { return m_maxTotalSize; }

    private:
        RollingPolicy() : m_maxSizeBytes(0), m_rollInterval(RollInterval::None), m_maxFiles(0), m_maxTotalSize(0) {}

        std::string    m_basePath;
        std::uint64_t  m_maxSizeBytes;
        RollInterval   m_rollInterval;
        unsigned int   m_maxFiles;
        std::uint64_t  m_maxTotalSize;
    };

} // namespace minta


// --- lunar_log/transform/pipe_transform.hpp ---

#include <string>
#include <vector>
#include <cstdlib>
#include <cerrno>
#include <cmath>
#include <cstdio>
#include <cctype>
#include <climits>

namespace minta {
namespace detail {

    // ----------------------------------------------------------------
    // Pipe Transform — parse and apply "|transform" chains
    // ----------------------------------------------------------------

    struct Transform {
        std::string name;
        std::string arg;
    };

    // --- Private helpers (number parsing, UTF-8) ---

    /// Parse a double from string. Separate from detail::tryParseDouble
    /// to keep pipe_transform.hpp self-contained (no log_common.hpp dep).
    inline bool pipeParseDouble(const std::string &s, double &out) {
        if (s.empty()) return false;
        const char *start = s.c_str();
        char *end = nullptr;
        errno = 0;
        double val = std::strtod(start, &end);
        if (errno == ERANGE || end == start ||
            static_cast<size_t>(end - start) != s.size()) {
            errno = 0;
            return false;
        }
        errno = 0;
        if (std::isinf(val) || std::isnan(val)) return false;
        out = val;
        return true;
    }

    /// Safe int parser for transform arguments.
    inline int pipeSafeStoi(const std::string &s, int fallback = 0) {
        if (s.empty()) return fallback;
        for (size_t i = 0; i < s.size(); ++i) {
            if (i == 0 && s[i] == '-') continue;
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) return fallback;
        }
        try { return std::stoi(s); } catch (...) { return fallback; }
    }

    /// Count UTF-8 codepoints in a string.
    inline size_t utf8CharCount(const std::string &s) {
        size_t count = 0;
        for (size_t i = 0; i < s.size(); ) {
            unsigned char c = static_cast<unsigned char>(s[i]);
            if (c < 0x80)        i += 1;
            else if ((c & 0xE0) == 0xC0) i += 2;
            else if ((c & 0xF0) == 0xE0) i += 3;
            else if ((c & 0xF8) == 0xF0) i += 4;
            else                 i += 1; // invalid byte, skip
            ++count;
        }
        return count;
    }

    /// Truncate a string to maxChars UTF-8 codepoints.
    inline std::string utf8Truncate(const std::string &s, size_t maxChars) {
        size_t count = 0;
        size_t bytePos = 0;
        while (bytePos < s.size() && count < maxChars) {
            unsigned char c = static_cast<unsigned char>(s[bytePos]);
            size_t charLen = 1;
            if (c < 0x80)        charLen = 1;
            else if ((c & 0xE0) == 0xC0) charLen = 2;
            else if ((c & 0xF0) == 0xE0) charLen = 3;
            else if ((c & 0xF8) == 0xF0) charLen = 4;
            // Clamp to string boundary to avoid reading past end
            if (bytePos + charLen > s.size()) break;
            bytePos += charLen;
            ++count;
        }
        return s.substr(0, bytePos);
    }

    /// Serialise a Transform back to its pipe-syntax string form.
    inline std::string transformToString(const Transform &t) {
        if (t.arg.empty()) return t.name;
        return t.name + ":" + t.arg;
    }

    /// Clamp a double to the representable long long range (prevents UB on cast).
    inline double pipeClampLL(double val) {
        if (val != val) return 0.0; // NaN
        static const double kMinLL = static_cast<double>(LLONG_MIN + 1);
        static const double kMaxLL = std::nextafter(static_cast<double>(LLONG_MAX), 0.0);
        if (val < kMinLL) return kMinLL;
        if (val > kMaxLL) return kMaxLL;
        return val;
    }

    // ----------------------------------------------------------------
    // Transform parsing
    // ----------------------------------------------------------------

    /// Parse "comma|truncate:10|quote" into [{comma,""}, {truncate,"10"}, {quote,""}]
    inline std::vector<Transform> parseTransforms(const std::string &pipeStr) {
        std::vector<Transform> result;
        if (pipeStr.empty()) return result;

        size_t start = 0;
        while (start <= pipeStr.size()) {
            size_t end = pipeStr.find('|', start);
            if (end == std::string::npos) end = pipeStr.size();
            if (end > start) {
                std::string token = pipeStr.substr(start, end - start);
                size_t colonPos = token.find(':');
                if (colonPos != std::string::npos) {
                    result.push_back({token.substr(0, colonPos),
                                      token.substr(colonPos + 1)});
                } else {
                    result.push_back({token, std::string()});
                }
            }
            start = end + 1;
        }
        return result;
    }

    // ----------------------------------------------------------------
    // Built-in String Transforms
    // ----------------------------------------------------------------

    inline std::string transformUpper(const std::string &value) {
        std::string result = value;
        for (size_t i = 0; i < result.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(result[i]);
            if (c >= 'a' && c <= 'z') result[i] = static_cast<char>(c - 32);
        }
        return result;
    }

    inline std::string transformLower(const std::string &value) {
        std::string result = value;
        for (size_t i = 0; i < result.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(result[i]);
            if (c >= 'A' && c <= 'Z') result[i] = static_cast<char>(c + 32);
        }
        return result;
    }

    inline std::string transformTrim(const std::string &value) {
        if (value.empty()) return value;
        size_t start = 0;
        while (start < value.size() &&
               std::isspace(static_cast<unsigned char>(value[start]))) ++start;
        if (start == value.size()) return std::string();
        size_t end = value.size();
        while (end > start &&
               std::isspace(static_cast<unsigned char>(value[end - 1]))) --end;
        return value.substr(start, end - start);
    }

    /// Limit to N UTF-8 codepoints; append ellipsis if truncated.
    inline std::string transformTruncate(const std::string &value,
                                         const std::string &arg) {
        int n = pipeSafeStoi(arg, -1);
        if (n < 0) return value; // invalid / missing arg
        size_t maxChars = static_cast<size_t>(n);
        size_t charCount = utf8CharCount(value);
        if (charCount <= maxChars) return value;
        // U+2026 HORIZONTAL ELLIPSIS (3 bytes in UTF-8)
        return utf8Truncate(value, maxChars) + "\xe2\x80\xa6";
    }

    /// Right-pad with spaces to N UTF-8 codepoints.
    inline std::string transformPad(const std::string &value,
                                    const std::string &arg) {
        int n = pipeSafeStoi(arg, 0);
        if (n <= 0) return value;
        size_t charCount = utf8CharCount(value);
        if (charCount >= static_cast<size_t>(n)) return value;
        return value + std::string(static_cast<size_t>(n) - charCount, ' ');
    }

    /// Left-pad with spaces to N UTF-8 codepoints.
    inline std::string transformPadLeft(const std::string &value,
                                        const std::string &arg) {
        int n = pipeSafeStoi(arg, 0);
        if (n <= 0) return value;
        size_t charCount = utf8CharCount(value);
        if (charCount >= static_cast<size_t>(n)) return value;
        return std::string(static_cast<size_t>(n) - charCount, ' ') + value;
    }

    /// Wrap in double quotes.
    inline std::string transformQuote(const std::string &value) {
        return "\"" + value + "\"";
    }

    // ----------------------------------------------------------------
    // Built-in Number Transforms
    // ----------------------------------------------------------------

    /// Thousands separator: 1234567 -> "1,234,567", 1234567.89 -> "1,234,567.89"
    inline std::string transformComma(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;

        // Normalize scientific notation to fixed-point
        std::string work = value;
        if (value.find('e') != std::string::npos ||
            value.find('E') != std::string::npos) {
            char buf[64];
            if (numVal == std::floor(numVal) && std::fabs(numVal) < 1e15) {
                std::snprintf(buf, sizeof(buf), "%.0f", numVal);
            } else {
                std::snprintf(buf, sizeof(buf), "%.15g", numVal);
            }
            work = std::string(buf);
        }

        // Split on decimal point
        size_t dotPos = work.find('.');
        std::string intPart = (dotPos != std::string::npos)
                                  ? work.substr(0, dotPos)
                                  : work;
        std::string decPart = (dotPos != std::string::npos)
                                  ? work.substr(dotPos)
                                  : std::string();

        // Handle sign
        std::string prefix;
        if (!intPart.empty() && (intPart[0] == '-' || intPart[0] == '+')) {
            prefix = intPart.substr(0, 1);
            intPart = intPart.substr(1);
        }

        // Add commas every 3 digits from the right
        std::string result;
        int len = static_cast<int>(intPart.size());
        for (int i = 0; i < len; ++i) {
            if (i > 0 && (len - i) % 3 == 0) {
                result += ',';
            }
            result += intPart[i];
        }

        return prefix + result + decPart;
    }

    /// Hex with 0x prefix: 255 -> "0xff"
    inline std::string transformHex(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        long long intVal = static_cast<long long>(pipeClampLL(numVal));
        char buf[64];
        if (intVal < 0) {
            unsigned long long uval = 0ULL - static_cast<unsigned long long>(intVal);
            std::snprintf(buf, sizeof(buf), "-0x%llx", uval);
        } else {
            std::snprintf(buf, sizeof(buf), "0x%llx",
                          static_cast<unsigned long long>(intVal));
        }
        return std::string(buf);
    }

    /// Octal with 0 prefix: 8 -> "010"
    inline std::string transformOct(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        long long intVal = static_cast<long long>(pipeClampLL(numVal));
        char buf[64];
        if (intVal < 0) {
            unsigned long long uval = 0ULL - static_cast<unsigned long long>(intVal);
            std::snprintf(buf, sizeof(buf), "-0%llo", uval);
        } else if (intVal == 0) {
            return "0";
        } else {
            std::snprintf(buf, sizeof(buf), "0%llo",
                          static_cast<unsigned long long>(intVal));
        }
        return std::string(buf);
    }

    /// Binary with 0b prefix: 10 -> "0b1010"
    inline std::string transformBin(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        long long intVal = static_cast<long long>(pipeClampLL(numVal));
        bool negative = intVal < 0;
        unsigned long long uval = negative
            ? (0ULL - static_cast<unsigned long long>(intVal))
            : static_cast<unsigned long long>(intVal);

        if (uval == 0) return "0b0";

        std::string bits;
        unsigned long long tmp = uval;
        while (tmp > 0) {
            bits = static_cast<char>('0' + static_cast<int>(tmp & 1)) + bits;
            tmp >>= 1;
        }

        std::string result = negative ? "-0b" : "0b";
        result += bits;
        return result;
    }

    /// Human-readable bytes: 1048576 -> "1.0 MB"
    inline std::string transformBytes(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;

        static const char *units[] = {"B", "KB", "MB", "GB", "TB", "PB"};
        static const int unitCount = 6;

        double absVal = std::fabs(numVal);
        double displayVal = absVal;
        int unitIdx = 0;

        while (displayVal >= 1024.0 && unitIdx < unitCount - 1) {
            displayVal /= 1024.0;
            ++unitIdx;
        }

        if (numVal < 0) displayVal = -displayVal;

        char buf[64];
        if (unitIdx == 0) {
            std::snprintf(buf, sizeof(buf), "%lld B",
                          static_cast<long long>(numVal));
        } else {
            std::snprintf(buf, sizeof(buf), "%.1f %s", displayVal,
                          units[unitIdx]);
        }
        return std::string(buf);
    }

    /// Human-readable time from milliseconds: 3661000 -> "1h 1m 1s"
    inline std::string transformDuration(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;

        long long totalMs = static_cast<long long>(pipeClampLL(numVal));
        bool negative = totalMs < 0;
        if (negative) {
            // Avoid signed negation UB on LLONG_MIN by using unsigned arithmetic
            unsigned long long uMs = static_cast<unsigned long long>(-(totalMs + 1)) + 1u;
            totalMs = static_cast<long long>(uMs);
        }

        long long totalSec = totalMs / 1000;
        long long ms = totalMs % 1000;
        long long hours = totalSec / 3600;
        long long remaining = totalSec % 3600;
        long long minutes = remaining / 60;
        long long seconds = remaining % 60;

        std::string result;
        if (negative) result += "-";

        if (totalSec == 0 && ms == 0) {
            return result + "0s";
        }

        if (totalSec == 0) {
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%lldms", ms);
            return result + buf;
        }

        bool first = true;
        if (hours > 0) {
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%lldh", hours);
            result += buf;
            first = false;
        }
        if (minutes > 0) {
            if (!first) result += " ";
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%lldm", minutes);
            result += buf;
            first = false;
        }
        if (seconds > 0 || (hours == 0 && minutes == 0)) {
            if (!first) result += " ";
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%llds", seconds);
            result += buf;
        }

        return result;
    }

    /// Percentage: 0.856 -> "85.6%"
    inline std::string transformPct(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        double pct = numVal * 100.0;
        char buf[64];
        std::snprintf(buf, sizeof(buf), "%.1f%%", pct);
        return std::string(buf);
    }

    // ----------------------------------------------------------------
    // Structural Transforms
    // ----------------------------------------------------------------

    /// Force JSON serialization of the value.
    inline std::string transformJson(const std::string &value) {
        if (value == "true" || value == "false") return value;
        if (value == "(null)") return "null";

        double numVal;
        if (pipeParseDouble(value, numVal)) {
            char buf[64];
            if (numVal == static_cast<double>(static_cast<long long>(numVal)) &&
                std::fabs(numVal) < 1e15) {
                std::snprintf(buf, sizeof(buf), "%lld",
                              static_cast<long long>(numVal));
            } else {
                std::snprintf(buf, sizeof(buf), "%.15g", numVal);
            }
            return std::string(buf);
        }

        // String — wrap in quotes with JSON escaping
        std::string result = "\"";
        for (size_t i = 0; i < value.size(); ++i) {
            char c = value[i];
            switch (c) {
                case '"':  result += "\\\""; break;
                case '\\': result += "\\\\"; break;
                case '\b': result += "\\b";  break;
                case '\f': result += "\\f";  break;
                case '\n': result += "\\n";  break;
                case '\r': result += "\\r";  break;
                case '\t': result += "\\t";  break;
                default:
                    if (static_cast<unsigned char>(c) < 0x20) {
                        char esc[8];
                        std::snprintf(esc, sizeof(esc), "\\u%04x",
                                      static_cast<unsigned char>(c));
                        result += esc;
                    } else {
                        result += c;
                    }
            }
        }
        result += '"';
        return result;
    }

    /// Output the detected C++ type name.
    inline std::string transformType(const std::string &value) {
        if (value == "true" || value == "false") return "bool";
        if (value == "(null)") return "nullptr_t";

        double numVal;
        if (pipeParseDouble(value, numVal)) {
            if (value.find('.') == std::string::npos &&
                value.find('e') == std::string::npos &&
                value.find('E') == std::string::npos) {
                return "int";
            }
            return "double";
        }
        return "string";
    }

    // ----------------------------------------------------------------
    // Transform pipeline — apply left to right
    // ----------------------------------------------------------------

    /// Apply a sequence of transforms to a formatted value.
    /// Structural transforms (expand, str) are no-ops on the string —
    /// they affect property metadata and are handled in mapProperties.
    /// Unknown transforms pass the value through unchanged (fail-open).
    inline std::string applyTransforms(const std::string &value,
                                       const std::vector<Transform> &transforms) {
        if (transforms.empty()) return value;
        std::string result = value;
        for (size_t i = 0; i < transforms.size(); ++i) {
            const std::string &name = transforms[i].name;
            const std::string &arg  = transforms[i].arg;

            // Structural — skip (handled elsewhere)
            if (name == "expand" || name == "str") continue;

            // String transforms
            if      (name == "upper")    result = transformUpper(result);
            else if (name == "lower")    result = transformLower(result);
            else if (name == "trim")     result = transformTrim(result);
            else if (name == "truncate") result = transformTruncate(result, arg);
            else if (name == "pad")      result = transformPad(result, arg);
            else if (name == "padl")     result = transformPadLeft(result, arg);
            else if (name == "quote")    result = transformQuote(result);

            // Number transforms
            else if (name == "comma")    result = transformComma(result);
            else if (name == "hex")      result = transformHex(result);
            else if (name == "oct")      result = transformOct(result);
            else if (name == "bin")      result = transformBin(result);
            else if (name == "bytes")    result = transformBytes(result);
            else if (name == "duration") result = transformDuration(result);
            else if (name == "pct")      result = transformPct(result);

            // Structural value transforms
            else if (name == "json")     result = transformJson(result);
            else if (name == "type")     result = transformType(result);

            // Unknown transform — fail-open, value passes through
        }
        return result;
    }

} // namespace detail
} // namespace minta


// --- lunar_log/formatter/formatter_interface.hpp ---

#include <string>
#include <vector>
#include <mutex>

namespace minta {
    class IFormatter {
    public:
        virtual ~IFormatter() = default;

        virtual std::string format(const LogEntry &entry) const = 0;

        /// Set the per-sink locale for culture-specific format specifiers.
        /// When set (non-empty), the formatter re-renders the message using
        /// this locale instead of the logger-level locale stored in the entry.
        /// Thread-safe: can be called concurrently with format().
        void setLocale(const std::string& locale) {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            m_locale = locale;
        }

        std::string getLocale() const {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            return m_locale;
        }

    protected:
        /// Re-render the entry's message with this formatter's locale.
        /// Returns the original message if no per-sink locale is set or
        /// if the per-sink locale matches the entry's locale.
        std::string localizedMessage(const LogEntry &entry) const {
            // Copy locale under lock, then use the copy outside.
            std::string localeCopy;
            {
                std::lock_guard<std::mutex> lock(m_localeMutex);
                localeCopy = m_locale;
            }
            if (localeCopy.empty() || localeCopy == entry.locale) {
                return entry.message;
            }
            // Textually-different locale names may resolve to the same
            // locale (e.g. "en_US" vs "en_US.UTF-8") — skip re-render.
            {
                auto resolved1 = detail::tryCreateLocale(localeCopy);
                auto resolved2 = detail::tryCreateLocale(entry.locale);
                if (resolved1.name() == resolved2.name()) {
                    return entry.message;
                }
            }
            std::vector<detail::ParsedPlaceholder> spans;
            detail::forEachPlaceholder(entry.templateStr, [&](const detail::ParsedPlaceholder& ph) {
                spans.push_back(ph);
            });
            size_t maxSlot = 0;
            size_t namedOrdinal = 0;
            for (size_t i = 0; i < spans.size(); ++i) {
                size_t slot = detail::resolveValueSlot(spans[i].indexedArg, namedOrdinal);
                if (spans[i].indexedArg < 0) ++namedOrdinal;
                if (slot + 1 > maxSlot) maxSlot = slot + 1;
            }
            std::vector<std::string> values(maxSlot);
            // Use slot/placeholder order as captured in entry.arguments.
            // Do not collapse by placeholder name: duplicate names may carry
            // distinct positional values (e.g. "{x} {x}" with args 1,2).
            namedOrdinal = 0;
            size_t argCursor = 0;
            for (size_t i = 0; i < spans.size(); ++i) {
                const auto &ph = spans[i];
                size_t slot = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                if (slot < values.size() && argCursor < entry.arguments.size()) {
                    values[slot] = entry.arguments[argCursor].second;
                    ++argCursor;
                }
            }
            return detail::walkTemplate(entry.templateStr, spans, values, localeCopy);
        }

    private:
        mutable std::mutex m_localeMutex;
        std::string m_locale;
    };
} // namespace minta


// --- lunar_log/formatter/human_readable_formatter.hpp ---

#include <string>

namespace minta {
    class HumanReadableFormatter : public IFormatter {
    public:
        /// Set the output template for this formatter.
        /// Must be called before logging begins (same contract as
        /// useFormatter / addSink). Not safe to call concurrently
        /// with format().
        void setOutputTemplate(const std::string& templateStr) {
            if (templateStr.empty()) {
                m_outputTemplate = detail::OutputTemplate();
                m_hasTemplate = false;
            } else {
                m_outputTemplate = detail::OutputTemplate(templateStr);
                m_hasTemplate = true;
            }
        }

        std::string format(const LogEntry &entry) const override {
            if (m_hasTemplate) {
                return m_outputTemplate.render(entry, localizedMessage(entry));
            }
            return formatDefault(entry);
        }

    private:
        detail::OutputTemplate m_outputTemplate;
        bool m_hasTemplate = false;

        std::string formatDefault(const LogEntry &entry) const {
            std::string result;
            result.reserve(80 + entry.message.size() + entry.file.size() + entry.function.size());
            result += detail::formatTimestamp(entry.timestamp);
            result += " [";
            result += getLevelString(entry.level);
            result += "] ";
            result += localizedMessage(entry);

            if (!entry.file.empty()) {
                result += " [";
                result += entry.file;
                result += ':';
                result += std::to_string(entry.line);
                result += ' ';
                result += entry.function;
                result += ']';
            }

            if (!entry.customContext.empty()) {
                result += " {";
                bool first = true;
                for (const auto &ctx : entry.customContext) {
                    if (!first) result += ", ";
                    result += ctx.first;
                    result += '=';
                    if (ctx.second.find(',') != std::string::npos ||
                        ctx.second.find('=') != std::string::npos ||
                        ctx.second.find('"') != std::string::npos) {
                        result += '"';
                        for (char c : ctx.second) {
                            if (c == '"') result += '\\';
                            result += c;
                        }
                        result += '"';
                    } else {
                        result += ctx.second;
                    }
                    first = false;
                }
                result += '}';
            }

            if (entry.hasException()) {
                result += "\n  ";
                result += entry.exception->type;
                result += ": ";
                result += entry.exception->message;
                if (!entry.exception->chain.empty()) {
                    const std::string& chain = entry.exception->chain;
                    size_t pos = 0;
                    while (pos < chain.size()) {
                        size_t nl = chain.find('\n', pos);
                        result += "\n  --- ";
                        if (nl == std::string::npos) {
                            result.append(chain, pos, chain.size() - pos);
                            break;
                        }
                        result.append(chain, pos, nl - pos);
                        pos = nl + 1;
                    }
                }
            }

            return result;
        }
    };
} // namespace minta


// --- lunar_log/formatter/json_detail.hpp ---

#include <string>
#include <cstdio>
#include <cstdlib>
#include <cerrno>
#include <cmath>

// Platform-specific includes for locale-independent strtod.
// strtod_l / _strtod_l lets us parse with the "C" locale regardless
// of the process-wide locale set via setlocale().
#if defined(_MSC_VER)
    #include <locale.h>
#elif defined(__APPLE__)
    #include <xlocale.h>
#elif defined(__GLIBC__) || defined(__FreeBSD__)
    #include <locale.h>
#endif

namespace minta {
namespace detail {
namespace json {

    /// Locale-independent strtod.  Prevents the global C locale from
    /// interfering with JSON number parsing (e.g. locales that use ','
    /// as the decimal separator would cause plain strtod to reject "3.14").
    ///
    /// Uses strtod_l / _strtod_l where available (glibc, macOS, MSVC).
    /// Falls back to plain strtod on other platforms -- the output-side
    /// comma-to-dot replacement still produces valid JSON, but '.' in
    /// the *input* may be misinterpreted under a non-"C" locale on those
    /// platforms.
    inline double strtodLocaleIndependent(const char* str, char** endptr) {
#if defined(_MSC_VER)
        static _locale_t c_locale = _create_locale(LC_ALL, "C");
        return _strtod_l(str, endptr, c_locale);
#elif defined(__GLIBC__) || defined(__APPLE__) || defined(__FreeBSD__)
        static locale_t c_locale = newlocale(LC_ALL_MASK, "C", (locale_t)0);
        return strtod_l(str, endptr, c_locale);
#else
        return std::strtod(str, endptr);
#endif
    }

    /// Escape a string for inclusion in JSON output.
    /// Handles special characters (quotes, backslash, control chars).
    /// UTF-8 multi-byte sequences (>= 0x80) pass through unescaped.
    inline std::string escapeJsonString(const std::string &input) {
        std::string result;
        result.reserve(input.size());
        for (char c : input) {
            switch (c) {
                case '"': result += R"(\")"; break;
                case '\\': result += R"(\\)"; break;
                case '\b': result += R"(\b)"; break;
                case '\f': result += R"(\f)"; break;
                case '\n': result += R"(\n)"; break;
                case '\r': result += R"(\r)"; break;
                case '\t': result += R"(\t)"; break;
                default:
                    if ('\x00' <= c && c <= '\x1f') {
                        char buf[8];
                        std::snprintf(buf, sizeof(buf), "\\u%04x",
                                     static_cast<unsigned char>(c));
                        result += buf;
                    } else {
                        result += c;
                    }
            }
        }
        return result;
    }

    /// Attempt to emit a JSON-native value for @ (destructure) properties.
    /// Values arrive as strings (post-toString conversion), so original type
    /// info is lost.  This function uses string-based heuristics: "true"/"false"
    /// become JSON booleans, numeric-looking strings become JSON numbers.
    /// Known limitation: a string argument "true" becomes boolean true, and
    /// "3.14" becomes number 3.14.  Use the $ (stringify) operator to force
    /// string representation when this coercion is undesirable.
    /// Note: nullptr/"(null)" is emitted as the string "(null)", not JSON null,
    /// since the MessageTemplates spec does not mandate null handling.
    inline std::string toJsonNativeValue(const std::string &value) {
        if (value == "true" || value == "false") {
            return value;
        }

        if (value.empty()) {
            return "\"\"";
        }

        const char* start = value.c_str();
        char* end = nullptr;
        errno = 0;
        double numVal = strtodLocaleIndependent(start, &end);
        if (errno == 0 && end != start
            && static_cast<size_t>(end - start) == value.size()
            && std::isfinite(numVal)) {
            // Re-serialize from the parsed double to guarantee valid JSON.
            // strtod accepts inputs like "+42", " 42", "0x1A" which are
            // NOT valid JSON numbers, so we cannot return the original string.
            char buf[64];
            if (numVal == static_cast<double>(static_cast<long long>(numVal))
                && std::fabs(numVal) < 1e15) {
                std::snprintf(buf, sizeof(buf), "%lld",
                             static_cast<long long>(numVal));
            } else {
                std::snprintf(buf, sizeof(buf), "%.15g", numVal);
            }
            // Locale-safety: some locales use ',' as decimal separator.
            // Replace with '.' to guarantee valid JSON numbers.
            for (char *p = buf; *p; ++p) {
                if (*p == ',') *p = '.';
            }
            return std::string(buf);
        }
        errno = 0;

        std::string result = "\"";
        result += escapeJsonString(value);
        result += '"';
        return result;
    }

} // namespace json
} // namespace detail
} // namespace minta


// --- lunar_log/formatter/json_formatter.hpp ---

#include <string>

namespace minta {
    class JsonFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::string levelStr = getLevelString(entry.level);
            std::string tsStr = detail::formatTimestamp(entry.timestamp);
            std::string msgEsc = detail::json::escapeJsonString(localizedMessage(entry));

            std::string json;
            json.reserve(64 + levelStr.size() + tsStr.size() + msgEsc.size());
            json += R"({"level":")";
            json += levelStr;
            json += R"(","timestamp":")";
            json += tsStr;
            json += R"(","message":")";
            json += msgEsc;
            json += '"';

            if (!entry.templateStr.empty()) {
                json += R"(,"messageTemplate":")";
                json += detail::json::escapeJsonString(entry.templateStr);
                json += R"(","templateHash":")";
                json += detail::toHexString(entry.templateHash);
                json += '"';
            }

            if (!entry.file.empty()) {
                std::string fileEsc = detail::json::escapeJsonString(entry.file);
                std::string funcEsc = detail::json::escapeJsonString(entry.function);
                json += R"(,"file":")";
                json += fileEsc;
                json += R"(","line":)";
                json += std::to_string(entry.line);
                json += R"(,"function":")";
                json += funcEsc;
                json += '"';
            }

            if (!entry.customContext.empty()) {
                json += R"(,"context":{)";
                bool first = true;
                for (const auto &ctx : entry.customContext) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(ctx.first);
                    json += R"(":")";
                    json += detail::json::escapeJsonString(ctx.second);
                    json += '"';
                    first = false;
                }
                json += '}';
            }

            if (!entry.tags.empty()) {
                json += R"(,"tags":[)";
                bool first = true;
                for (const auto &tag : entry.tags) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(tag);
                    json += '"';
                    first = false;
                }
                json += ']';
            }

            if (entry.hasException()) {
                json += R"(,"exception":{"type":")";
                json += detail::json::escapeJsonString(entry.exception->type);
                json += R"(","message":")";
                json += detail::json::escapeJsonString(entry.exception->message);
                json += '"';
                if (!entry.exception->chain.empty()) {
                    json += R"(,"chain":")";
                    json += detail::json::escapeJsonString(entry.exception->chain);
                    json += '"';
                }
                json += '}';
            }

            if (!entry.properties.empty()) {
                json += R"(,"properties":{)";
                bool first = true;
                for (const auto &prop : entry.properties) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(prop.name);
                    json += R"(":)";
                    if (prop.op == '@') {
                        json += detail::json::toJsonNativeValue(prop.value);
                    } else {
                        json += '"';
                        json += detail::json::escapeJsonString(prop.value);
                        json += '"';
                    }
                    first = false;
                }
                json += '}';

                bool hasTransforms = false;
                for (const auto &prop : entry.properties) {
                    if (!prop.transforms.empty()) { hasTransforms = true; break; }
                }
                if (hasTransforms) {
                    json += R"(,"transforms":{)";
                    bool firstProp = true;
                    for (const auto &prop : entry.properties) {
                        if (prop.transforms.empty()) continue;
                        if (!firstProp) json += ',';
                        json += '"';
                        json += detail::json::escapeJsonString(prop.name);
                        json += R"(":[)";
                        bool firstT = true;
                        for (const auto &t : prop.transforms) {
                            if (!firstT) json += ',';
                            json += '"';
                            json += detail::json::escapeJsonString(t);
                            json += '"';
                            firstT = false;
                        }
                        json += ']';
                        firstProp = false;
                    }
                    json += '}';
                }
            }

            json += '}';
            return json;
        }

    };
} // namespace minta


// --- lunar_log/formatter/compact_json_formatter.hpp ---

#include <string>
#include <cstdio>
#include <atomic>

namespace minta {
    /// Compact JSON formatter producing single-line JSONL output optimized for
    /// log pipelines (ELK, Datadog, Loki).  Uses short property names with @
    /// prefix following the CLEF (Compact Log Event Format) convention.
    ///
    /// System fields:
    ///   @t  = timestamp (ISO 8601, UTC, ms precision)
    ///   @l  = level (3-char: TRC, DBG, INF, WRN, ERR, FTL; omitted for INFO)
    ///   @mt = message template
    ///   @m  = rendered message (optional, off by default)
    ///   @i  = template hash (included when template is present)
    ///   @x  = exception info (type: message, with nested chain if present)
    ///
    /// Properties and context are flattened to top level.  User property names
    /// starting with @ are escaped to @@ to prevent collision with system fields.
    /// The @l field is omitted for INFO level (parsers assume INFO when absent).
    class CompactJsonFormatter : public IFormatter {
    public:
        CompactJsonFormatter() : m_includeRenderedMessage(false) {}

        /// Enable/disable the @m (rendered message) field.
        /// Default is false (off).  Thread-safe.
        void includeRenderedMessage(bool include) {
            m_includeRenderedMessage.store(include, std::memory_order_relaxed);
        }

        bool isRenderedMessageIncluded() const {
            return m_includeRenderedMessage.load(std::memory_order_relaxed);
        }

        std::string format(const LogEntry &entry) const override {
            std::string json;
            json.reserve(128);

            // @t - timestamp (ISO 8601, UTC, ms precision)
            json += R"({"@t":")";
            json += formatTimestampUtc(entry.timestamp);
            json += '"';

            // @l - level (omitted for INFO)
            if (entry.level != LogLevel::INFO) {
                json += R"(,"@l":")";
                json += getCompactLevel(entry.level);
                json += '"';
            }

            // @mt - message template (always present)
            json += R"(,"@mt":")";
            if (!entry.templateStr.empty()) {
                json += detail::json::escapeJsonString(entry.templateStr);
            } else {
                json += detail::json::escapeJsonString(entry.message);
            }
            json += '"';

            // @i - template hash (when template is present)
            if (!entry.templateStr.empty()) {
                json += R"(,"@i":")";
                json += detail::toHexString(entry.templateHash);
                json += '"';
            }

            // @m - rendered message (optional, off by default)
            if (m_includeRenderedMessage.load(std::memory_order_relaxed)) {
                json += R"(,"@m":")";
                json += detail::json::escapeJsonString(localizedMessage(entry));
                json += '"';
            }

            if (entry.hasException()) {
                // Build the full @x string first, then escape once to avoid
                // fragmented escaping that can produce inconsistent output.
                std::string xValue;
                xValue += entry.exception->type;
                xValue += ": ";
                xValue += entry.exception->message;
                if (!entry.exception->chain.empty()) {
                    xValue += '\n';
                    xValue += entry.exception->chain;
                }
                json += R"(,"@x":")";
                json += detail::json::escapeJsonString(xValue);
                json += '"';
            }

            for (const auto &prop : entry.properties) {
                json += ',';
                json += '"';
                json += escapePropertyName(prop.name);
                json += R"(":)";
                if (prop.op == '@') {
                    json += detail::json::toJsonNativeValue(prop.value);
                } else {
                    json += '"';
                    json += detail::json::escapeJsonString(prop.value);
                    json += '"';
                }
            }

            // Flatten context to top level
            for (const auto &ctx : entry.customContext) {
                json += ',';
                json += '"';
                json += escapePropertyName(ctx.first);
                json += R"(":)";
                json += '"';
                json += detail::json::escapeJsonString(ctx.second);
                json += '"';
            }

            // Tags
            if (!entry.tags.empty()) {
                json += R"(,"tags":[)";
                bool first = true;
                for (const auto &tag : entry.tags) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(tag);
                    json += '"';
                    first = false;
                }
                json += ']';
            }

            json += '}';
            return json;
        }

    private:
        std::atomic<bool> m_includeRenderedMessage;

        /// Format timestamp as ISO 8601 UTC with millisecond precision.
        /// Example: "2026-02-16T12:00:00.000Z"
        static std::string formatTimestampUtc(const std::chrono::system_clock::time_point &time) {
            auto epoch = std::chrono::system_clock::to_time_t(time);
            auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                time.time_since_epoch()) % 1000;

            std::tm tmBuf;
#if defined(_MSC_VER)
            gmtime_s(&tmBuf, &epoch);
#else
            gmtime_r(&epoch, &tmBuf);
#endif

            char buf[32];
            size_t pos = std::strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S", &tmBuf);
            if (pos == 0) {
                buf[0] = '\0';
            }
            // Defensive: ensure non-negative milliseconds for pre-epoch time points
            std::snprintf(buf + pos, sizeof(buf) - pos, ".%03dZ",
                         static_cast<int>((ms.count() + 1000) % 1000));
            return std::string(buf);
        }

        /// Return 3-character level abbreviation.
        static const char* getCompactLevel(LogLevel level) {
            switch (level) {
                case LogLevel::TRACE: return "TRC";
                case LogLevel::DEBUG: return "DBG";
                case LogLevel::INFO:  return "INF";
                case LogLevel::WARN:  return "WRN";
                case LogLevel::ERROR: return "ERR";
                case LogLevel::FATAL: return "FTL";
                default: return "INF";
            }
        }

        /// Escape a property name for use as a JSON key.
        /// Names starting with @ are escaped to @@ to avoid collision with
        /// system fields (@t, @l, @mt, etc.).
        static std::string escapePropertyName(const std::string &name) {
            if (!name.empty() && name[0] == '@') {
                return "@" + detail::json::escapeJsonString(name);
            }
            return detail::json::escapeJsonString(name);
        }
    };
} // namespace minta


// --- lunar_log/formatter/xml_formatter.hpp ---

#include <string>
#include <cstdio>

namespace minta {
    class XmlFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::string xml;
            xml += "<log_entry>";
            xml += "<level>";
            xml += getLevelString(entry.level);
            xml += "</level>";
            xml += "<timestamp>";
            xml += detail::formatTimestamp(entry.timestamp);
            xml += "</timestamp>";
            xml += "<message>";
            xml += escapeXmlString(localizedMessage(entry));
            xml += "</message>";

            if (!entry.templateStr.empty()) {
                xml += "<MessageTemplate hash=\"";
                xml += detail::toHexString(entry.templateHash);
                xml += "\">";
                xml += escapeXmlString(entry.templateStr);
                xml += "</MessageTemplate>";
            }

            if (!entry.file.empty()) {
                xml += "<file>";
                xml += escapeXmlString(entry.file);
                xml += "</file>";
                xml += "<line>";
                xml += std::to_string(entry.line);
                xml += "</line>";
                xml += "<function>";
                xml += escapeXmlString(entry.function);
                xml += "</function>";
            }

            if (!entry.tags.empty()) {
                xml += "<tags>";
                for (const auto &tag : entry.tags) {
                    xml += "<tag>";
                    xml += escapeXmlString(tag);
                    xml += "</tag>";
                }
                xml += "</tags>";
            }

            if (entry.hasException()) {
                xml += "<exception type=\"";
                xml += escapeXmlString(entry.exception->type);
                xml += "\">";
                xml += escapeXmlString(entry.exception->message);
                if (!entry.exception->chain.empty()) {
                    xml += "<chain>";
                    xml += escapeXmlString(entry.exception->chain);
                    xml += "</chain>";
                }
                xml += "</exception>";
            }

            if (!entry.customContext.empty()) {
                xml += "<context>";
                for (const auto &ctx : entry.customContext) {
                    std::string safeName = sanitizeXmlName(ctx.first);
                    xml += "<";
                    xml += safeName;
                    xml += ">";
                    xml += escapeXmlString(ctx.second);
                    xml += "</";
                    xml += safeName;
                    xml += ">";
                }
                xml += "</context>";
            }

            if (!entry.properties.empty()) {
                xml += "<properties>";
                for (const auto &prop : entry.properties) {
                    std::string safeName = sanitizeXmlName(prop.name);
                    xml += "<";
                    xml += safeName;
                    if (prop.op == '@') {
                        xml += " destructure=\"true\"";
                    } else if (prop.op == '$') {
                        xml += " stringify=\"true\"";
                    }
                    if (!prop.transforms.empty()) {
                        xml += " transforms=\"";
                        bool firstT = true;
                        for (const auto &t : prop.transforms) {
                            if (!firstT) xml += '|';
                            xml += escapeXmlString(t);
                            firstT = false;
                        }
                        xml += '"';
                    }
                    xml += ">";
                    xml += escapeXmlString(prop.value);
                    xml += "</";
                    xml += safeName;
                    xml += ">";
                }
                xml += "</properties>";
            }

            xml += "</log_entry>";
            return xml;
        }

    private:
        static std::string sanitizeXmlName(const std::string &input) {
            if (input.empty()) return "_";
            std::string result;
            result.reserve(input.size() + 1);
            for (size_t i = 0; i < input.size(); ++i) {
                char c = input[i];
                bool valid = (c == '_' || c == ':') ||
                             (c >= 'A' && c <= 'Z') ||
                             (c >= 'a' && c <= 'z') ||
                             (c >= '0' && c <= '9') || c == '-' || c == '.';
                result += valid ? c : '_';
            }
            if (result.empty()) return "_";
            // XML element names cannot start with a digit, '-' or '.'.
            // Prefix with '_' instead of replacing the whole name so numeric
            // indexed keys like "0", "1" remain distinct as "_0", "_1".
            if (result[0] == '-' || result[0] == '.' || (result[0] >= '0' && result[0] <= '9')) {
                result.insert(result.begin(), '_');
            }
            return result;
        }

        static std::string escapeXmlString(const std::string &input) {
            std::string result;
            result.reserve(input.size());
            for (char c : input) {
                unsigned char uc = static_cast<unsigned char>(c);
                if (uc < 0x20 && uc != 0x09 && uc != 0x0A && uc != 0x0D) {
                    result += ' ';
                    continue;
                }
                switch (c) {
                    case '<': result += "&lt;"; break;
                    case '>': result += "&gt;"; break;
                    case '&': result += "&amp;"; break;
                    case '\'': result += "&apos;"; break;
                    case '"': result += "&quot;"; break;
                    default: result += c; break;
                }
            }
            return result;
        }
    };
} // namespace minta


// --- lunar_log/transport/transport_interface.hpp ---

#include <string>

namespace minta {

    class ITransport {
    public:
        virtual ~ITransport() = default;
        virtual void write(const std::string& formattedEntry) = 0;
    };

} // namespace minta


// --- lunar_log/transport/file_transport.hpp ---

#include <fstream>
#include <mutex>
#include <stdexcept>

namespace minta {
    class FileTransport : public ITransport {
    public:
        explicit FileTransport(const std::string &filename, bool autoFlush = true)
            : m_autoFlush(autoFlush) {
            m_file.open(filename, std::ios::app);
            if (!m_file.is_open()) {
                throw std::runtime_error("FileTransport: failed to open file: " + filename);
            }
        }

        void write(const std::string &formattedEntry) override {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (!m_file.good()) {
                m_file.clear();
                m_file << formattedEntry << '\n';
                if (!m_file.good()) {
                    if (!m_errorReported) {
                        m_errorReported = true;
                        std::fprintf(stderr, "FileTransport: write failed, some log entries may be lost\n");
                    }
                    return;
                }
                // Recovery succeeded
                m_errorReported = false;
            } else {
                m_file << formattedEntry << '\n';
            }
            if (m_autoFlush) {
                m_file << std::flush;
            }
        }

    private:
        std::ofstream m_file;
        std::mutex m_mutex;
        bool m_autoFlush;
        bool m_errorReported = false;
    };
} // namespace minta


// --- lunar_log/transport/stdout_transport.hpp ---

#include <iostream>
#include <mutex>

namespace minta {
    class StdoutTransport : public ITransport {
    public:
        void write(const std::string &formattedEntry) override {
            std::lock_guard<std::mutex> lock(m_mutex);
            std::cout << formattedEntry << '\n' << std::flush;
        }

    private:
        std::mutex m_mutex;
    };
} // namespace minta


// --- lunar_log/sink/sink_interface.hpp ---

#include <memory>
#include <atomic>
#include <mutex>
#include <vector>
#include <set>
#include <string>
#include <functional>

namespace minta {
    class LunarLog;

    using FilterPredicate = std::function<bool(const LogEntry&)>;

    class ISink {
    public:
        ISink() : m_minLevel(LogLevel::TRACE), m_hasFilters(false), m_hasTagFilters(false) {}
        virtual ~ISink() = default;

        virtual void write(const LogEntry &entry) = 0;
        virtual void flush() {}

        // --- Named sink support ---
        void setSinkName(const std::string& name) { m_sinkName = name; }
        const std::string& getSinkName() const { return m_sinkName; }

        // --- Tag routing (COW) ---
        void addOnlyTag(const std::string& tag) {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            auto newTags = std::make_shared<std::set<std::string>>(
                m_onlyTags ? *m_onlyTags : std::set<std::string>());
            newTags->insert(tag);
            m_onlyTags = std::move(newTags);
            m_hasTagFilters.store(true, std::memory_order_release);
        }
        void addExceptTag(const std::string& tag) {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            auto newTags = std::make_shared<std::set<std::string>>(
                m_exceptTags ? *m_exceptTags : std::set<std::string>());
            newTags->insert(tag);
            m_exceptTags = std::move(newTags);
            m_hasTagFilters.store(true, std::memory_order_release);
        }
        void clearOnlyTags() {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_onlyTags.reset();
            m_hasTagFilters.store(m_exceptTags && !m_exceptTags->empty(), std::memory_order_release);
        }
        void clearExceptTags() {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_exceptTags.reset();
            m_hasTagFilters.store(m_onlyTags && !m_onlyTags->empty(), std::memory_order_release);
        }
        void clearTagFilters() {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_onlyTags.reset();
            m_exceptTags.reset();
            m_hasTagFilters.store(false, std::memory_order_release);
        }
        std::set<std::string> getOnlyTags() const {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            return m_onlyTags ? *m_onlyTags : std::set<std::string>();
        }
        std::set<std::string> getExceptTags() const {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            return m_exceptTags ? *m_exceptTags : std::set<std::string>();
        }

        /// Check if this sink should accept an entry based on tag routing.
        /// Rules:
        ///   - If sink has only() tags: accept only if entry has at least one matching tag
        ///   - If sink has except() tags: reject if entry has any matching tag
        ///   - only() takes precedence over except()
        ///   - Entries without tags go to sinks that have NO only() filter
        bool shouldAcceptTags(const std::vector<std::string>& entryTags) const {
            if (!m_hasTagFilters.load(std::memory_order_acquire)) {
                return true;
            }
            std::shared_ptr<const std::set<std::string>> onlyTags;
            std::shared_ptr<const std::set<std::string>> exceptTags;
            {
                std::lock_guard<std::mutex> lock(m_tagMutex);
                onlyTags = m_onlyTags;
                exceptTags = m_exceptTags;
            }
            if (onlyTags && !onlyTags->empty()) {
                for (const auto& tag : entryTags) {
                    if (onlyTags->count(tag)) return true;
                }
                return false;
            }
            if (exceptTags && !exceptTags->empty()) {
                for (const auto& tag : entryTags) {
                    if (exceptTags->count(tag)) return false;
                }
            }
            return true;
        }

        void setMinLevel(LogLevel level) {
            m_minLevel.store(level, std::memory_order_relaxed);
        }

        LogLevel getMinLevel() const {
            return m_minLevel.load(std::memory_order_relaxed);
        }

        /// @note The predicate is invoked on the consumer thread against an
        ///       immutable snapshot.  It must be fast and non-blocking.
        ///       Filter predicates must capture state by value.  Referenced
        ///       objects must outlive the logger.
        void setFilter(FilterPredicate filter) {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filter = std::make_shared<const FilterPredicate>(std::move(filter));
            m_hasFilters.store(true, std::memory_order_release);
        }

        void clearFilter() {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filter.reset();
            m_hasFilters.store(m_filterRules && !m_filterRules->empty(), std::memory_order_release);
        }

        void addFilterRule(FilterRule rule) {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            auto newRules = std::make_shared<std::vector<FilterRule>>(
                m_filterRules ? *m_filterRules : std::vector<FilterRule>());
            newRules->push_back(std::move(rule));
            m_filterRules = std::move(newRules);
            m_hasFilters.store(true, std::memory_order_release);
        }

        void addFilterRules(std::vector<FilterRule> rules) {
            if (rules.empty()) return;
            std::lock_guard<std::mutex> lock(m_filterMutex);
            auto newRules = std::make_shared<std::vector<FilterRule>>(
                m_filterRules ? *m_filterRules : std::vector<FilterRule>());
            newRules->reserve(newRules->size() + rules.size());
            for (size_t i = 0; i < rules.size(); ++i) {
                newRules->push_back(std::move(rules[i]));
            }
            m_filterRules = std::move(newRules);
            m_hasFilters.store(true, std::memory_order_release);
        }

        void addFilterRule(const std::string& ruleStr) {
            FilterRule rule = FilterRule::parse(ruleStr);
            std::lock_guard<std::mutex> lock(m_filterMutex);
            auto newRules = std::make_shared<std::vector<FilterRule>>(
                m_filterRules ? *m_filterRules : std::vector<FilterRule>());
            newRules->push_back(std::move(rule));
            m_filterRules = std::move(newRules);
            m_hasFilters.store(true, std::memory_order_release);
        }

        void clearFilterRules() {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filterRules.reset();
            m_hasFilters.store(m_filter && static_cast<bool>(*m_filter), std::memory_order_release);
        }

        void clearAllFilters() {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filter.reset();
            m_filterRules.reset();
            m_hasFilters.store(false, std::memory_order_release);
        }

        /// Set a per-sink locale for culture-specific formatting.
        /// Forwards to the sink's formatter.
        void setLocale(const std::string& locale) {
            IFormatter* fmt = formatter();
            if (fmt) fmt->setLocale(locale);
        }

        std::string getLocale() const {
            IFormatter* fmt = formatter();
            return fmt ? fmt->getLocale() : std::string();
        }

        bool passesFilter(const LogEntry& entry) const {
            if (entry.level < m_minLevel.load(std::memory_order_relaxed)) {
                return false;
            }

            if (!m_hasFilters.load(std::memory_order_acquire)) {
                return true;
            }

            std::shared_ptr<const FilterPredicate> filter;
            std::shared_ptr<const std::vector<FilterRule>> rules;
            {
                std::lock_guard<std::mutex> lock(m_filterMutex);
                filter = m_filter;
                rules = m_filterRules;
            }

            if (filter && *filter && !(*filter)(entry)) {
                return false;
            }
            if (rules) {
                for (const auto& rule : *rules) {
                    if (!rule.evaluate(entry)) {
                        return false;
                    }
                }
            }
            return true;
        }

    protected:
        void setFormatter(std::unique_ptr<IFormatter> formatter) {
            m_formatter = std::move(formatter);
        }

        void setTransport(std::unique_ptr<ITransport> transport) {
            m_transport = std::move(transport);
        }

        IFormatter* formatter() const { return m_formatter.get(); }
        ITransport* transport() const { return m_transport.get(); }

    private:
        std::unique_ptr<IFormatter> m_formatter;
        std::unique_ptr<ITransport> m_transport;
        std::atomic<LogLevel> m_minLevel;
        std::atomic<bool> m_hasFilters;
        mutable std::mutex m_filterMutex;
        std::shared_ptr<const FilterPredicate> m_filter;
        std::shared_ptr<const std::vector<FilterRule>> m_filterRules;

        std::string m_sinkName;
        std::atomic<bool> m_hasTagFilters;
        mutable std::mutex m_tagMutex;
        std::shared_ptr<const std::set<std::string>> m_onlyTags;
        std::shared_ptr<const std::set<std::string>> m_exceptTags;

        friend class LunarLog;
        friend class LoggerConfiguration;
        friend class SinkProxy;
    };

    class BaseSink : public ISink {
    public:
        void write(const LogEntry &entry) override {
            IFormatter* fmt = formatter();
            ITransport* tp = transport();
            if (fmt && tp) {
                tp->write(fmt->format(entry));
            }
        }
    };
} // namespace minta


// --- lunar_log/sink/console_sink.hpp ---


namespace minta {
    class ConsoleSink : public BaseSink {
    public:
        ConsoleSink() {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<StdoutTransport>());
        }
    };
} // namespace minta


// --- lunar_log/sink/color_console_sink.hpp ---

#include <atomic>
#include <cstdlib>
#include <cstdio>
#include <string>

#ifdef _WIN32
#include <io.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
// windows.h defines ERROR as 0, which conflicts with LogLevel::ERROR.
#ifdef ERROR
#undef ERROR
#endif
#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
#endif
#else
#include <unistd.h>
#endif

namespace minta {
    /// ANSI-color-enabled console sink.
    ///
    /// Drop-in alternative to ConsoleSink that colorizes the [LEVEL] bracket
    /// in log output. The message body is left uncolored.
    ///
    /// Color is auto-disabled when:
    ///   - stdout is not a TTY (piped / redirected)
    ///   - `NO_COLOR` environment variable is set (any value — https://no-color.org/)
    ///   - `LUNAR_LOG_NO_COLOR` environment variable is set (non-empty)
    ///
    /// On Windows 10+, ENABLE_VIRTUAL_TERMINAL_PROCESSING is activated
    /// automatically so that ANSI escape codes render correctly.
    class ColorConsoleSink : public BaseSink {
    public:
        ColorConsoleSink() {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<StdoutTransport>());
            m_colorEnabled.store(detectColorSupport(), std::memory_order_relaxed);
        }

        /// Override color auto-detection.
        void setColor(bool enabled) { m_colorEnabled.store(enabled, std::memory_order_relaxed); }

        /// Returns true if color output is currently enabled.
        bool isColorEnabled() const { return m_colorEnabled.load(std::memory_order_relaxed); }

        // Overrides BaseSink::write() because colorization must be injected
        // between format() and transport(). BaseSink has no virtual hook for
        // post-format transforms, so a full override is required.
        void write(const LogEntry& entry) override {
            IFormatter* fmt = formatter();
            ITransport* tp = transport();
            if (fmt && tp) {
                std::string formatted = fmt->format(entry);
                if (m_colorEnabled.load(std::memory_order_relaxed)) {
                    formatted = colorize(formatted, entry.level);
                }
                tp->write(formatted);
            }
        }

        /// Insert ANSI color codes around the [LEVEL] bracket in formatted text.
        /// Only the bracket (e.g. "[INFO]") is colorized; the message body is
        /// left uncolored.  If a custom formatter omits the [LEVEL] bracket,
        /// colorization silently passes through (returns text unchanged).
        /// Public and static for testability.
        static std::string colorize(const std::string& text, LogLevel level) {
            const char* levelStr = getLevelString(level);
            std::string bracket = "[";
            bracket += levelStr;
            bracket += "]";

            size_t pos = text.find(bracket);
            if (pos == std::string::npos) return text;

            const char* color = getColorCode(level);
            const char* reset = "\033[0m";

            std::string result;
            result.reserve(text.size() + 20);
            result.append(text, 0, pos);
            result += color;
            result += bracket;
            result += reset;
            result.append(text, pos + bracket.size(), std::string::npos);
            return result;
        }

        /// Return the ANSI escape code for a log level.
        static const char* getColorCode(LogLevel level) {
            switch (level) {
                case LogLevel::TRACE: return "\033[2m";      // dim
                case LogLevel::DEBUG: return "\033[36m";     // cyan
                case LogLevel::INFO:  return "\033[32m";     // green
                case LogLevel::WARN:  return "\033[33m";     // yellow
                case LogLevel::ERROR: return "\033[31m";     // red
                case LogLevel::FATAL: return "\033[1;31m";   // bold red
                default: return "";
            }
        }

    private:
        std::atomic<bool> m_colorEnabled;

        static bool detectColorSupport() {
            // NO_COLOR standard (https://no-color.org/): mere presence disables color.
            if (std::getenv("NO_COLOR") != nullptr) return false;

            // Project-specific override: requires non-empty value.
            const char* noColor = std::getenv("LUNAR_LOG_NO_COLOR");
            if (noColor && noColor[0] != '\0') return false;

#ifdef _WIN32
            HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
            if (hOut == INVALID_HANDLE_VALUE) return false;
            DWORD mode = 0;
            if (!GetConsoleMode(hOut, &mode)) return false;
            if (!(mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)) {
                if (!SetConsoleMode(hOut, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) {
                    return false;
                }
            }
            return true;
#else
            return isatty(fileno(stdout)) != 0;
#endif
        }
    };
} // namespace minta


// --- lunar_log/sink/file_sink.hpp ---


namespace minta {
    class FileSink : public BaseSink {
    public:
        explicit FileSink(const std::string &filename) {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<FileTransport>(filename));
        }
    };
} // namespace minta


// --- lunar_log/sink/rolling_file_sink.hpp ---

#include <fstream>
#include <mutex>
#include <string>
#include <cstdio>
#include <ctime>
#include <algorithm>
#include <climits>
#include <deque>
#include <vector>

#include <sys/stat.h>
#ifdef _MSC_VER
#include <direct.h>
#include <io.h>
#else
#include <unistd.h>
#include <dirent.h>
#endif

namespace minta {

    class RollingFileSink : public ISink {
    public:
        explicit RollingFileSink(const RollingPolicy& policy)
            : m_policy(policy)
            , m_currentSize(0)
            , m_lastPeriod()
            , m_fileOpen(false)
            , m_sizeRollIndex(0)
            , m_lastPeriodCheckTime(0)
        {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            splitBasePath();
        }

        ~RollingFileSink() {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_fileOpen) {
                m_file.close();
                m_fileOpen = false;
            }
        }

        /// Set the formatter type. Must be called during initialization only,
        /// before any calls to write(). Not thread-safe with concurrent logging.
        template<typename FormatterType>
        void useFormatter() {
            setFormatter(detail::make_unique<FormatterType>());
        }

        void write(const LogEntry& entry) override {
            IFormatter* fmt = formatter();
            if (!fmt) return;
            std::string formatted = fmt->format(entry);

            std::lock_guard<std::mutex> lock(m_mutex);
            ensureOpen();
            if (needsRotation()) {
                rotate();
            }
            writeToFile(formatted);
        }

    private:
        void splitBasePath() {
            const std::string& path = m_policy.basePath();
            size_t dotPos = path.rfind('.');
            size_t slashPos = path.find_last_of("/\\");
            if (dotPos != std::string::npos && (slashPos == std::string::npos || dotPos > slashPos)) {
                m_stem = path.substr(0, dotPos);
                m_ext = path.substr(dotPos);
            } else {
                m_stem = path;
                m_ext.clear();
            }
        }

        static bool mkdirRecursive(const std::string& path) {
            if (path.empty()) return true;
            struct stat st;
            if (stat(path.c_str(), &st) == 0) return true;

            size_t slashPos = path.find_last_of("/\\");
            if (slashPos != std::string::npos && slashPos > 0) {
                if (!mkdirRecursive(path.substr(0, slashPos))) return false;
            }
#ifdef _MSC_VER
            return _mkdir(path.c_str()) == 0 || errno == EEXIST;
#else
            return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
#endif
        }

        void ensureDirectoryExists() {
            const std::string& path = m_policy.basePath();
            size_t slashPos = path.find_last_of("/\\");
            if (slashPos != std::string::npos && slashPos > 0) {
                mkdirRecursive(path.substr(0, slashPos));
            }
        }

        void ensureOpen() {
            if (m_fileOpen) return;
            ensureDirectoryExists();
            m_file.open(m_policy.basePath(), std::ios::app | std::ios::binary);
            if (!m_file.is_open()) {
                std::fprintf(stderr, "RollingFileSink: failed to open file: %s\n",
                             m_policy.basePath().c_str());
                return;
            }
            m_fileOpen = true;
            m_currentSize = getFileSize(m_policy.basePath());
            if (m_policy.rollInterval() != RollInterval::None) {
                m_lastPeriodCheckTime = std::time(nullptr);
                m_lastPeriod = currentPeriodString(m_lastPeriodCheckTime);
            }
            discoverExistingRolledFiles();
        }

        void writeToFile(const std::string& formatted) {
            if (!m_fileOpen) return;
            m_file << formatted << '\n' << std::flush;
            m_currentSize += formatted.size() + 1;
        }

        bool needsRotation() {
            if (!m_fileOpen) return false;
            if (m_policy.maxSizeBytes() > 0 && m_currentSize >= m_policy.maxSizeBytes()) {
                return true;
            }
            if (m_policy.rollInterval() != RollInterval::None) {
                std::time_t now = std::time(nullptr);
                if (now != m_lastPeriodCheckTime) {
                    m_lastPeriodCheckTime = now;
                    std::string current = currentPeriodString(now);
                    if (current != m_lastPeriod) return true;
                }
            }
            return false;
        }

        void rotate() {
            m_file.close();
            m_fileOpen = false;

            std::string rolledName = buildRolledName();
            if (std::rename(m_policy.basePath().c_str(), rolledName.c_str()) == 0) {
                m_rolledFiles.push_back(rolledName);
            } else {
                std::fprintf(stderr, "RollingFileSink: failed to rename %s to %s\n",
                             m_policy.basePath().c_str(), rolledName.c_str());
            }

            if (m_policy.rollInterval() != RollInterval::None) {
                m_lastPeriodCheckTime = std::time(nullptr);
                m_lastPeriod = currentPeriodString(m_lastPeriodCheckTime);
            }

            cleanup();

            m_file.open(m_policy.basePath(), std::ios::app | std::ios::binary);
            if (m_file.is_open()) {
                m_fileOpen = true;
                m_currentSize = getFileSize(m_policy.basePath());
            }
        }

        std::string buildRolledName() {
            bool hasSizePolicy = m_policy.maxSizeBytes() > 0;
            bool hasTimePolicy = m_policy.rollInterval() != RollInterval::None;

            if (hasTimePolicy && hasSizePolicy) {
                std::string period = m_lastPeriod;
                if (period != m_lastRolledPeriod) {
                    m_sizeRollIndex = 0;
                    m_lastRolledPeriod = period;
                }
                m_sizeRollIndex++;
                char idx[16];
                std::snprintf(idx, sizeof(idx), "%03u", m_sizeRollIndex);
                return m_stem + "." + period + "." + idx + m_ext;
            }
            if (hasTimePolicy) {
                // Time-only mode: one file per period. If rotation triggers twice
                // in the same period, the second rename overwrites the first — by
                // design, since time-only means at most one rolled file per period.
                return m_stem + "." + m_lastPeriod + m_ext;
            }
            m_sizeRollIndex++;
            char idx[16];
            std::snprintf(idx, sizeof(idx), "%03u", m_sizeRollIndex);
            return m_stem + "." + idx + m_ext;
        }

        std::string currentPeriodString(std::time_t now) const {
            std::tm tmBuf;
#ifdef _MSC_VER
            localtime_s(&tmBuf, &now);
#else
            localtime_r(&now, &tmBuf);
#endif
            char buf[32];
            if (m_policy.rollInterval() == RollInterval::Daily) {
                std::strftime(buf, sizeof(buf), "%Y-%m-%d", &tmBuf);
            } else {
                std::strftime(buf, sizeof(buf), "%Y-%m-%d.%H", &tmBuf);
            }
            return std::string(buf);
        }

        static std::uint64_t getFileSize(const std::string& path) {
            struct stat st;
            if (stat(path.c_str(), &st) != 0) return 0;
            return static_cast<std::uint64_t>(st.st_size);
        }

        static std::time_t getFileMTime(const std::string& path) {
            struct stat st;
            if (stat(path.c_str(), &st) != 0) return 0;
            return st.st_mtime;
        }

        static std::vector<std::string> listDirectory(const std::string& dirPath) {
            std::vector<std::string> entries;
#ifdef _MSC_VER
            struct _finddata_t fileinfo;
            std::string pattern = dirPath + "/*";
            intptr_t handle = _findfirst(pattern.c_str(), &fileinfo);
            if (handle == -1) return entries;
            do {
                std::string name = fileinfo.name;
                if (name != "." && name != "..") {
                    entries.push_back(name);
                }
            } while (_findnext(handle, &fileinfo) == 0);
            _findclose(handle);
#else
            DIR* dir = opendir(dirPath.c_str());
            if (!dir) return entries;
            struct dirent* ent;
            while ((ent = readdir(dir)) != nullptr) {
                std::string name = ent->d_name;
                if (name != "." && name != "..") {
                    entries.push_back(name);
                }
            }
            closedir(dir);
#endif
            return entries;
        }

        static bool allDigits(const char* s, size_t n) {
            if (n == 0) return false;
            for (size_t i = 0; i < n; ++i) {
                if (s[i] < '0' || s[i] > '9') return false;
            }
            return true;
        }

        /// Check if string matches YYYY-MM-DD pattern.
        /// @pre strlen(s) >= 10
        static bool isDatePattern(const char* s) {
            return s[0] >= '0' && s[0] <= '9' && s[1] >= '0' && s[1] <= '9' &&
                   s[2] >= '0' && s[2] <= '9' && s[3] >= '0' && s[3] <= '9' &&
                   s[4] == '-' &&
                   s[5] >= '0' && s[5] <= '9' && s[6] >= '0' && s[6] <= '9' &&
                   s[7] == '-' &&
                   s[8] >= '0' && s[8] <= '9' && s[9] >= '0' && s[9] <= '9';
        }

        static bool isValidRolledMiddle(const std::string& mid) {
            if (mid.empty()) return false;
            const char* s = mid.c_str();
            size_t len = mid.size();

            // Pure digits (size index: "001", "002", etc.)
            if (allDigits(s, len)) return true;

            // Must start with date YYYY-MM-DD (10 chars)
            if (len < 10 || !isDatePattern(s)) return false;
            if (len == 10) return true;

            // Dot must follow the date
            if (s[10] != '.') return false;
            const char* rest = s + 11;
            size_t restLen = len - 11;
            if (restLen == 0) return false;

            // YYYY-MM-DD.digits (daily+size or hourly time-only)
            if (allDigits(rest, restLen)) return true;

            // YYYY-MM-DD.HH.NNN (hourly+size)
            if (restLen > 3 && rest[0] >= '0' && rest[0] <= '9' &&
                rest[1] >= '0' && rest[1] <= '9' && rest[2] == '.') {
                return allDigits(rest + 3, restLen - 3);
            }
            return false;
        }

        static unsigned int parseDigits(const char* s) {
            unsigned int result = 0;
            while (*s >= '0' && *s <= '9') {
                unsigned int digit = static_cast<unsigned int>(*s - '0');
                if (result > (UINT_MAX - digit) / 10) return UINT_MAX;
                result = result * 10 + digit;
                ++s;
            }
            return result;
        }

        void discoverExistingRolledFiles() {
            m_rolledFiles.clear();
            m_sizeRollIndex = 0;

            // Determine directory and stem filename
            std::string dir;
            std::string stemFilename;
            {
                size_t slashPos = m_stem.find_last_of("/\\");
                if (slashPos != std::string::npos) {
                    dir = m_stem.substr(0, slashPos);
                    stemFilename = m_stem.substr(slashPos + 1);
                } else {
                    dir = ".";
                    stemFilename = m_stem;
                }
            }

            std::string prefix = stemFilename + ".";
            std::vector<std::string> entries = listDirectory(dir);

            // Collect matching rolled files with mtime for sorting
            struct RolledEntry {
                std::string path;
                std::string middle;
                std::time_t mtime;
            };
            std::vector<RolledEntry> found;

            for (size_t i = 0; i < entries.size(); ++i) {
                const std::string& name = entries[i];

                // Must start with stem prefix (e.g. "roll_size.")
                if (name.size() <= prefix.size() ||
                    name.compare(0, prefix.size(), prefix) != 0) {
                    continue;
                }

                // Must end with extension (if any) and extract middle part
                std::string middle;
                if (!m_ext.empty()) {
                    if (name.size() <= prefix.size() + m_ext.size()) continue;
                    if (name.compare(name.size() - m_ext.size(),
                                     m_ext.size(), m_ext) != 0) continue;
                    middle = name.substr(prefix.size(),
                                         name.size() - prefix.size() - m_ext.size());
                } else {
                    middle = name.substr(prefix.size());
                }

                if (middle.empty()) continue;
                if (!isValidRolledMiddle(middle)) continue;

                // Reconstruct full path matching buildRolledName format
                std::string fullPath = m_stem + "." + middle + m_ext;

                RolledEntry re;
                re.path = fullPath;
                re.middle = middle;
                re.mtime = getFileMTime(fullPath);
                found.push_back(re);
            }

            // Sort by mtime (oldest first) for correct cleanup ordering
            std::sort(found.begin(), found.end(),
                      [](const RolledEntry& a, const RolledEntry& b) {
                          return a.mtime < b.mtime;
                      });

            // Populate m_rolledFiles and recover m_sizeRollIndex
            bool hasTimePolicy = m_policy.rollInterval() != RollInterval::None;
            bool hasSizePolicy = m_policy.maxSizeBytes() > 0;

            for (size_t i = 0; i < found.size(); ++i) {
                m_rolledFiles.push_back(found[i].path);

                if (hasSizePolicy) {
                    unsigned int idx = 0;
                    const std::string& mid = found[i].middle;

                    if (!hasTimePolicy) {
                        // Size only: entire middle is the index
                        idx = parseDigits(mid.c_str());
                    } else if (!m_lastPeriod.empty() &&
                               mid.size() > m_lastPeriod.size() + 1 &&
                               mid.compare(0, m_lastPeriod.size(), m_lastPeriod) == 0 &&
                               mid[m_lastPeriod.size()] == '.') {
                        // Hybrid: period.NNN — extract NNN for current period
                        idx = parseDigits(mid.c_str() + m_lastPeriod.size() + 1);
                    }

                    if (idx > m_sizeRollIndex) {
                        m_sizeRollIndex = idx;
                    }
                }
            }
        }

        void cleanup() {
            bool hasMaxFiles = m_policy.maxFilesCount() > 0;
            bool hasMaxTotalSize = m_policy.maxTotalSizeBytes() > 0;
            if (!hasMaxFiles && !hasMaxTotalSize) return;

            if (hasMaxFiles) {
                while (m_rolledFiles.size() > m_policy.maxFilesCount()) {
                    std::remove(m_rolledFiles.front().c_str());
                    m_rolledFiles.pop_front();
                }
            }

            if (hasMaxTotalSize) {
                std::vector<std::uint64_t> sizes;
                std::uint64_t total = 0;
                for (size_t i = 0; i < m_rolledFiles.size(); ++i) {
                    std::uint64_t sz = getFileSize(m_rolledFiles[i]);
                    sizes.push_back(sz);
                    total += sz;
                }
                // sizes[removeIdx] corresponds to the current front of m_rolledFiles
                // because we increment removeIdx in lockstep with pop_front
                size_t removeIdx = 0;
                while (removeIdx < m_rolledFiles.size() && total > m_policy.maxTotalSizeBytes()) {
                    total -= sizes[removeIdx];
                    std::remove(m_rolledFiles.front().c_str());
                    m_rolledFiles.pop_front();
                    removeIdx++;
                }
            }
        }

        RollingPolicy m_policy;
        std::string m_stem;
        std::string m_ext;
        std::ofstream m_file;
        std::mutex m_mutex;
        std::uint64_t m_currentSize;
        std::string m_lastPeriod;
        std::string m_lastRolledPeriod;
        bool m_fileOpen;
        unsigned int m_sizeRollIndex;
        std::time_t m_lastPeriodCheckTime;
        std::deque<std::string> m_rolledFiles;
    };

} // namespace minta


// --- lunar_log/sink/async_sink.hpp ---

#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <vector>
#include <deque>
#include <memory>
#include <cassert>

namespace minta {

    /// Policy for handling queue overflow when the bounded queue is full.
    enum class OverflowPolicy {
        Block,       ///< Block the producer until space is available (backpressure)
        DropOldest,  ///< Drop the oldest item in the queue to make room
        DropNewest   ///< Drop the new item (default)
    };

    /// Configuration options for AsyncSink.
    struct AsyncOptions {
        size_t queueSize;            ///< Maximum number of entries in the queue
        OverflowPolicy overflowPolicy; ///< What to do when the queue is full
        size_t flushIntervalMs;      ///< Periodic flush interval in ms (0 = disabled)

        AsyncOptions()
            : queueSize(8192)
            , overflowPolicy(OverflowPolicy::DropNewest)
            , flushIntervalMs(0) {}
    };

namespace detail {

    /// Thread-safe bounded queue for LogEntry objects.
    /// Uses mutex + condition_variable + deque for C++11 compatibility.
    class BoundedQueue {
    public:
        explicit BoundedQueue(size_t capacity)
            : m_capacity(capacity > 0 ? capacity : 1)
            , m_stopped(false)
            , m_flushPending(false) {}

        /// Push an entry into the queue with the specified overflow policy.
        /// Returns true if the entry was enqueued, false if dropped.
        bool push(LogEntry&& entry, OverflowPolicy policy) {
            std::unique_lock<std::mutex> lock(m_mutex);
            if (m_stopped) return false;

            if (m_queue.size() >= m_capacity) {
                switch (policy) {
                    case OverflowPolicy::Block:
                        m_notFull.wait(lock, [this] {
                            return m_queue.size() < m_capacity || m_stopped;
                        });
                        if (m_stopped) return false;
                        break;
                    case OverflowPolicy::DropOldest:
                        m_queue.pop_front();
                        break;
                    case OverflowPolicy::DropNewest:
                        return false;
                }
            }

            m_queue.push_back(std::move(entry));
            m_notEmpty.notify_one();
            return true;
        }

        /// Drain all available entries into the output vector.
        /// Returns number of entries drained.
        size_t drain(std::vector<LogEntry>& out) {
            std::lock_guard<std::mutex> lock(m_mutex);
            size_t count = m_queue.size();
            out.reserve(out.size() + count);
            for (size_t i = 0; i < count; ++i) {
                out.push_back(std::move(m_queue.front()));
                m_queue.pop_front();
            }
            if (count > 0) {
                m_notFull.notify_all();
            }
            return count;
        }

        /// Wait until at least one entry is available or the queue is stopped.
        /// Returns false if stopped with empty queue.
        bool waitForData() {
            std::unique_lock<std::mutex> lock(m_mutex);
            // Note: acquire ordering is redundant here since the mutex already
            // provides the necessary happens-before guarantee; kept for
            // defensive clarity.
            m_notEmpty.wait(lock, [this] {
                return !m_queue.empty() || m_stopped || m_flushPending.load(std::memory_order_acquire);
            });
            return !m_queue.empty() || m_flushPending.load(std::memory_order_acquire);
        }

        /// Wait until at least one entry is available or timeout expires.
        /// Returns false if timed out or stopped with empty queue.
        bool waitForData(std::chrono::milliseconds timeout) {
            std::unique_lock<std::mutex> lock(m_mutex);
            m_notEmpty.wait_for(lock, timeout, [this] {
                return !m_queue.empty() || m_stopped || m_flushPending.load(std::memory_order_acquire);
            });
            return !m_queue.empty() || m_flushPending.load(std::memory_order_acquire);
        }

        /// Wake all waiters (used for shutdown).
        void wake() {
            m_notEmpty.notify_all();
            m_notFull.notify_all();
        }

        /// Stop the queue. All blocking operations return immediately.
        void stop() {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_stopped = true;
            m_notEmpty.notify_all();
            m_notFull.notify_all();
        }

        size_t size() const {
            std::lock_guard<std::mutex> lock(m_mutex);
            return m_queue.size();
        }

        bool empty() const {
            std::lock_guard<std::mutex> lock(m_mutex);
            return m_queue.empty();
        }

        /// Set the flush-pending flag. When true, waitForData() predicates
        /// are satisfied even if the queue is empty, unblocking the consumer
        /// so it can process a flush request.
        void setFlushPending(bool v) {
            m_flushPending.store(v, std::memory_order_release);
        }

        /// Atomically set the flush-pending flag and wake all waiters.
        /// Must be used instead of separate setFlushPending(true) + wake()
        /// to avoid lost-wakeup between flag set and notify.
        void requestFlush() {
            {
                std::lock_guard<std::mutex> lock(m_mutex);
                m_flushPending.store(true, std::memory_order_release);
            }
            m_notEmpty.notify_all();
        }

    private:
        mutable std::mutex m_mutex;
        std::condition_variable m_notEmpty;
        std::condition_variable m_notFull;
        std::deque<LogEntry> m_queue;
        size_t m_capacity;
        bool m_stopped;
        std::atomic<bool> m_flushPending;
    };

} // namespace detail

    /// Asynchronous sink decorator.
    ///
    /// Wraps any ISink-derived sink type with a dedicated queue and consumer
    /// thread. Log entries are enqueued by the producer and written by the
    /// consumer thread, decoupling slow sinks (file, network) from fast
    /// producers.
    ///
    /// The decorator pattern means existing sinks work unchanged:
    /// @code
    ///   // Wrap a FileSink in an async decorator
    ///   logger.addSink<AsyncSink<FileSink>>("app.log");
    ///
    ///   // With options
    ///   AsyncOptions opts;
    ///   opts.queueSize = 4096;
    ///   opts.overflowPolicy = OverflowPolicy::Block;
    ///   logger.addSink<AsyncSink<FileSink>>(opts, "app.log");
    /// @endcode
    ///
    /// Order guarantee: entries from a single producer are delivered in FIFO
    /// order. Multiple producers have no cross-thread ordering guarantee.
    template<typename SinkType>
    class AsyncSink : public ISink {
    public:
        /// Construct an AsyncSink with default options.
        /// All arguments are forwarded to the SinkType constructor.
        template<typename... Args>
        explicit AsyncSink(Args&&... args)
            : m_innerSink(detail::make_unique<SinkType>(std::forward<Args>(args)...))
            , m_queue(AsyncOptions().queueSize)
            , m_running(true)
            , m_opts()
            , m_droppedCount(0)
            , m_flushDone(false)
        {
            startConsumer();
        }

        /// Construct an AsyncSink with custom options.
        /// Remaining arguments are forwarded to the SinkType constructor.
        template<typename... Args>
        explicit AsyncSink(AsyncOptions opts, Args&&... args)
            : m_innerSink(detail::make_unique<SinkType>(std::forward<Args>(args)...))
            , m_queue(opts.queueSize)
            , m_running(true)
            , m_opts(opts)
            , m_droppedCount(0)
            , m_flushDone(false)
        {
            startConsumer();
        }

        ~AsyncSink() noexcept {
            m_running.store(false, std::memory_order_release);
            m_queue.stop();

            // Unblock any pending flush()
            {
                std::lock_guard<std::mutex> lock(m_flushMutex);
                m_flushDone = true;
            }
            m_flushCV.notify_all();

            if (m_thread.joinable()) {
                m_thread.join();
            }

            // Flush any remaining entries in the queue
            std::vector<LogEntry> remaining;
            m_queue.drain(remaining);
            for (size_t i = 0; i < remaining.size(); ++i) {
                try {
                    m_innerSink->write(remaining[i]);
                } catch (...) {}
            }
            try {
                if (m_innerSink) m_innerSink->flush();
            } catch (...) {}
        }

        /// Enqueue an entry for asynchronous writing.
        void write(const LogEntry& entry) override {
            LogEntry copy = detail::cloneEntry(entry);
            if (!m_queue.push(std::move(copy), m_opts.overflowPolicy)) {
                m_droppedCount.fetch_add(1, std::memory_order_relaxed);
            }
        }

        // Note: concurrent flush() callers share a single m_flushDone flag.
        // If two threads call flush() simultaneously, the later caller's completion
        // may wake the earlier waiter. Both callers' data is guaranteed enqueued
        // and will be written, but inner sink flush may not have completed for
        // the later caller. Only the return timing is coupled. This is acceptable
        // for a logging sink.

        /// Flush: wait for the consumer to finish processing all queued entries.
        void flush() override {
            if (!m_running.load(std::memory_order_acquire)) return;

            {
                std::lock_guard<std::mutex> lock(m_flushMutex);
                m_flushRequested.store(true, std::memory_order_release);
                m_flushDone = false;
            }
            m_queue.requestFlush();

            std::unique_lock<std::mutex> lock(m_flushMutex);
            m_flushCV.wait(lock, [this] {
                return m_flushDone || !m_running.load(std::memory_order_acquire);
            });
        }

        /// Number of entries dropped due to queue overflow.
        /// Wraps on unsigned overflow; practically unreachable.
        size_t droppedCount() const {
            return m_droppedCount.load(std::memory_order_relaxed);
        }

        /// Access the inner sink (for testing/inspection).
        SinkType* innerSink() { return m_innerSink.get(); }
        const SinkType* innerSink() const { return m_innerSink.get(); }

    private:
        void startConsumer() {
            m_thread = std::thread(&AsyncSink::consumerLoop, this);
        }

        void consumerLoop() {
            std::vector<LogEntry> batch;
            while (m_running.load(std::memory_order_acquire)) {
                batch.clear();

                if (m_opts.flushIntervalMs > 0) {
                    m_queue.waitForData(std::chrono::milliseconds(m_opts.flushIntervalMs));
                } else {
                    m_queue.waitForData();
                }

                m_queue.drain(batch);
                // Unconditionally clear flushPending after drain to prevent
                // consumer spin when a concurrent flush() sets the flag
                // between our setFlushPending(false) and m_flushRequested
                // clear. Any subsequent requestFlush() will re-set it.
                m_queue.setFlushPending(false);
                for (size_t i = 0; i < batch.size(); ++i) {
                    try {
                        m_innerSink->write(batch[i]);
                    } catch (...) {}
                }

                if (m_flushRequested.load(std::memory_order_acquire)) {
                    std::vector<LogEntry> extra;
                    m_queue.drain(extra);
                    for (size_t i = 0; i < extra.size(); ++i) {
                        try {
                            m_innerSink->write(extra[i]);
                        } catch (...) {}
                    }

                    // Propagate flush to inner sink so buffered sinks
                    // (e.g. BatchedSink inside HttpSink) actually deliver.
                    try {
                        if (m_innerSink) {
                            m_innerSink->flush();
                        }
                    } catch (...) {}

                    {
                        std::lock_guard<std::mutex> lock(m_flushMutex);
                        m_flushRequested.store(false, std::memory_order_release);
                        m_flushDone = true;
                    }
                    m_flushCV.notify_all();
                }
            }

            // Final drain after stop signal
            batch.clear();
            m_queue.drain(batch);
            for (size_t i = 0; i < batch.size(); ++i) {
                try {
                    m_innerSink->write(batch[i]);
                } catch (...) {}
            }

            // Unblock any pending flush on shutdown
            {
                std::lock_guard<std::mutex> lock(m_flushMutex);
                m_flushDone = true;
            }
            m_flushCV.notify_all();
        }

        std::unique_ptr<SinkType> m_innerSink;
        detail::BoundedQueue m_queue;
        std::thread m_thread;
        std::atomic<bool> m_running;
        AsyncOptions m_opts;
        std::atomic<size_t> m_droppedCount;

        std::atomic<bool> m_flushRequested{false};
        std::mutex m_flushMutex;
        std::condition_variable m_flushCV;
        bool m_flushDone;
    };

} // namespace minta


// --- lunar_log/sink/batched_sink.hpp ---

#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <vector>
#include <memory>
#include <stdexcept>
#include <cstdio>

namespace minta {

    /// Configuration options for BatchedSink.
    ///
    /// Controls batch size, flush interval, queue limits, and retry behavior.
    /// All setters return `*this` for fluent chaining:
    /// @code
    ///   BatchOptions opts;
    ///   opts.setBatchSize(200).setFlushIntervalMs(3000).setMaxRetries(5);
    /// @endcode
    ///
    /// @warning When a producer thread triggers a flush (by reaching batchSize),
    ///          it blocks for up to (timeoutMs + retryDelayMs) * (maxRetries+1).
    ///          For latency-sensitive producers, wrap in AsyncSink<BatchedSink<...>>
    ///          to offload flush work to a dedicated thread.
    struct BatchOptions {
        size_t batchSize_;         ///< Flush when buffer reaches this size
        size_t flushIntervalMs_;   ///< Periodic flush interval in ms
        size_t maxQueueSize_;      ///< Maximum buffered entries before dropping
        size_t maxRetries_;        ///< Retry count on writeBatch failure
        size_t retryDelayMs_;      ///< Delay between retries in ms

        BatchOptions()
            : batchSize_(100)
            , flushIntervalMs_(5000)
            , maxQueueSize_(10000)
            , maxRetries_(3)
            , retryDelayMs_(1000) {}

        BatchOptions& setBatchSize(size_t n) { batchSize_ = n; return *this; }
        BatchOptions& setFlushIntervalMs(size_t ms) { flushIntervalMs_ = ms; return *this; }
        BatchOptions& setMaxQueueSize(size_t n) { maxQueueSize_ = n; return *this; }
        BatchOptions& setMaxRetries(size_t n) { maxRetries_ = n; return *this; }
        BatchOptions& setRetryDelayMs(size_t ms) { retryDelayMs_ = ms; return *this; }
    };

    /// Abstract base class for batched sink implementations.
    ///
    /// Buffers log entries and delivers them in batches via the protected
    /// writeBatch() method. A background timer thread ensures entries are
    /// flushed even when the batch size threshold is not reached.
    ///
    /// Subclasses must implement writeBatch() and may optionally override
    /// onFlush() and onBatchError().
    ///
    /// @code
    ///   class MyHttpSink : public BatchedSink {
    ///   public:
    ///       MyHttpSink() : BatchedSink(BatchOptions().setBatchSize(50)) {}
    ///   protected:
    ///       void writeBatch(const std::vector<const LogEntry*>& batch) override {
    ///           // Send batch over HTTP
    ///       }
    ///   };
    /// @endcode
    class BatchedSink : public ISink {
    public:
        explicit BatchedSink(BatchOptions opts = BatchOptions())
            : m_opts(opts)
            , m_running(true)
        {
            m_buffer.reserve(m_opts.batchSize_);
            startTimer();
        }

        ~BatchedSink() noexcept {
            if (m_running.load(std::memory_order_acquire)) {
                std::fprintf(stderr, "[BatchedSink] WARNING: subclass destructor did not call "
                                     "stopAndFlush() — buffered entries may be lost.\n");
            }
            stopAndFlush();
        }

        /// Subclasses MUST call stopAndFlush() from their destructor to flush
        /// remaining entries while writeBatch() is still resolvable.
        void stopAndFlush() noexcept {
            bool expected = true;
            if (!m_running.compare_exchange_strong(expected, false,
                    std::memory_order_acq_rel)) {
                return; // already shut down
            }

            {
                std::lock_guard<std::mutex> lock(m_timerMutex);
                m_timerCV.notify_all();
            }

            if (m_timerThread.joinable()) {
                m_timerThread.join();
            }

            try {
                flushBuffer();
            } catch (...) {}
        }

        /// Buffer an entry. Triggers a flush if batchSize is reached.
        void write(const LogEntry& entry) final {
            if (!m_running.load(std::memory_order_acquire)) return;

            std::vector<LogEntry> toFlush;
            {
                std::lock_guard<std::mutex> lock(m_bufferMutex);
                if (m_opts.maxQueueSize_ > 0 && m_buffer.size() >= m_opts.maxQueueSize_) {
                    m_droppedCount.fetch_add(1, std::memory_order_relaxed);
                    return;
                }
                m_buffer.push_back(detail::cloneEntry(entry));
                if (m_buffer.size() >= m_opts.batchSize_) {
                    toFlush.swap(m_buffer);
                }
            }
            if (!toFlush.empty()) {
                doFlush(std::move(toFlush));
            }
        }

        /// Force flush all buffered entries.
        void flush() override {
            std::vector<LogEntry> toFlush;
            {
                std::lock_guard<std::mutex> lock(m_bufferMutex);
                if (m_buffer.empty()) return;
                toFlush.swap(m_buffer);
            }
            doFlush(std::move(toFlush));
        }

        /// Access options (for testing).
        const BatchOptions& options() const { return m_opts; }

        /// Number of entries dropped due to maxQueueSize overflow.
        /// Wraps on unsigned overflow; practically unreachable.
        size_t droppedCount() const {
            return m_droppedCount.load(std::memory_order_relaxed);
        }

    protected:
        /// Subclasses implement this to process a batch of entries.
        /// The pointers are valid only for the duration of this call.
        ///
        /// Default implementation is a no-op.  Subclass destructors MUST call
        /// stopAndFlush() before their vtable is destroyed; otherwise any
        /// remaining buffered entries will be silently discarded by this
        /// empty default.
        ///
        /// @warning Thread-safety: writeBatch() is serialized by m_writeMutex,
        ///          so implementations need not be thread-safe. However, long-running
        ///          writeBatch calls will block other flush paths.
        virtual void writeBatch(const std::vector<const LogEntry*>& batch) {
            (void)batch;
        }

        /// Called after a successful flush. Override for post-flush logic.
        virtual void onFlush() {}

        /// Called when writeBatch throws an exception.
        /// @param e The caught exception
        /// @param retryCount Current retry attempt (0-based)
        virtual void onBatchError(const std::exception& e, size_t retryCount) {
            (void)e;
            (void)retryCount;
        }

    private:
        void startTimer() {
            if (m_opts.flushIntervalMs_ == 0) return;
            m_timerThread = std::thread(&BatchedSink::timerLoop, this);
        }

        void timerLoop() {
            while (m_running.load(std::memory_order_acquire)) {
                std::unique_lock<std::mutex> lock(m_timerMutex);
                m_timerCV.wait_for(lock,
                    std::chrono::milliseconds(m_opts.flushIntervalMs_),
                    [this] { return !m_running.load(std::memory_order_acquire); });

                if (!m_running.load(std::memory_order_acquire)) break;

                try {
                    std::vector<LogEntry> toFlush;
                    {
                        std::lock_guard<std::mutex> bufLock(m_bufferMutex);
                        if (m_buffer.empty()) continue;
                        toFlush.swap(m_buffer);
                    }
                    doFlush(std::move(toFlush));
                } catch (...) {}
            }
        }

        /// Flush a batch with retries. Does NOT hold m_bufferMutex.
        void doFlush(std::vector<LogEntry> entries) {
            if (entries.empty()) return;

            std::vector<const LogEntry*> ptrs;
            ptrs.reserve(entries.size());
            for (size_t i = 0; i < entries.size(); ++i) {
                ptrs.push_back(&entries[i]);
            }

            bool success = false;
            for (size_t attempt = 0; attempt <= m_opts.maxRetries_; ++attempt) {
                try {
                    {
                        std::lock_guard<std::mutex> wlock(m_writeMutex);
                        writeBatch(ptrs);
                    }
                    success = true;
                    break;
                } catch (const std::exception& e) {
                    onBatchError(e, attempt);
                    if (attempt < m_opts.maxRetries_) {
                        std::this_thread::sleep_for(
                            std::chrono::milliseconds(m_opts.retryDelayMs_));
                    }
                } catch (...) {
                    break;
                }
            }

            if (success) {
                try { onFlush(); } catch (...) {}
            }
        }

        void flushBuffer() {
            std::vector<LogEntry> toFlush;
            {
                std::lock_guard<std::mutex> lock(m_bufferMutex);
                if (m_buffer.empty()) return;
                toFlush.swap(m_buffer);
            }
            doFlush(std::move(toFlush));
        }

        BatchOptions m_opts;
        std::vector<LogEntry> m_buffer;
        std::mutex m_bufferMutex;
        std::mutex m_writeMutex;
        std::thread m_timerThread;
        std::mutex m_timerMutex;
        std::condition_variable m_timerCV;
        std::atomic<bool> m_running;
        std::atomic<size_t> m_droppedCount{0};
    };

} // namespace minta


// --- lunar_log/sink/syslog_sink.hpp ---

#ifndef _WIN32

#include <syslog.h>
#include <string>

namespace minta {

    /// Configuration options for SyslogSink.
    struct SyslogOptions {
        int facility_;      ///< syslog facility (LOG_USER, LOG_LOCAL0, etc.)
        int logopt_;        ///< openlog() options (LOG_PID, LOG_NDELAY, etc.)
        bool includeLevel_; ///< Prefix messages with "[LEVEL] "

        SyslogOptions()
            : facility_(LOG_USER)
            , logopt_(LOG_PID | LOG_NDELAY)
            , includeLevel_(false) {}

        SyslogOptions& setFacility(int f) { facility_ = f; return *this; }
        SyslogOptions& setLogopt(int o) { logopt_ = o; return *this; }
        SyslogOptions& setIncludeLevel(bool b) { includeLevel_ = b; return *this; }
    };

    /// Sink that writes log entries to the POSIX syslog daemon.
    ///
    /// Uses the standard `<syslog.h>` API. No external dependencies.
    /// Available on Linux, macOS, and BSD. Not available on Windows —
    /// on Windows this header is silently skipped (no definitions are emitted).
    ///
    /// @note openlog() is a process-global call. Only one SyslogSink per process
    ///       is recommended. Multiple instances will overwrite each other's ident.
    ///
    /// @code
    ///   logger.addSink<SyslogSink>("my-app");
    ///   logger.addSink<SyslogSink>("my-app", SyslogOptions().setFacility(LOG_LOCAL0));
    /// @endcode
    class SyslogSink : public ISink {
    public:
        /// @param ident  The syslog identity string (typically the program name).
        ///               Stored internally — the pointer passed to openlog() remains
        ///               valid for the lifetime of this sink.
        /// @param opts   Syslog configuration options.
        explicit SyslogSink(const std::string& ident,
                            SyslogOptions opts = SyslogOptions())
            : m_ident(ident)
            , m_opts(opts)
        {
            // openlog() requires a pointer that remains valid until closelog().
            // m_ident is a std::string member, so c_str() is stable.
            openlog(m_ident.c_str(), m_opts.logopt_, m_opts.facility_);
        }

        ~SyslogSink() noexcept {
            closelog();
        }

        void write(const LogEntry& entry) override {
            int priority = toSyslogPriority(entry.level);

            if (m_opts.includeLevel_) {
                std::string msg = "[";
                msg += getLevelString(entry.level);
                msg += "] ";
                msg += entry.message;
                syslog(priority, "%s", msg.c_str());
            } else {
                syslog(priority, "%s", entry.message.c_str());
            }
        }

        /// Convert a LunarLog LogLevel to a syslog priority value.
        /// Public and static for testability.
        static int toSyslogPriority(LogLevel level) {
            switch (level) {
                case LogLevel::TRACE: return LOG_DEBUG;
                case LogLevel::DEBUG: return LOG_DEBUG;
                case LogLevel::INFO:  return LOG_INFO;
                case LogLevel::WARN:  return LOG_WARNING;
                case LogLevel::ERROR: return LOG_ERR;
                case LogLevel::FATAL: return LOG_CRIT;
                default: return LOG_INFO;
            }
        }

    private:
        std::string m_ident;
        SyslogOptions m_opts;
    };

} // namespace minta

#endif // !_WIN32


// --- lunar_log/sink/http_sink.hpp ---

#include <string>
#include <map>
#include <memory>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <climits>
#include <sstream>
#include <algorithm>
#include <cctype>

#ifdef _WIN32
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifdef ERROR
#undef ERROR
#endif
#include <winhttp.h>
#pragma comment(lib, "winhttp.lib")
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <pthread.h>
#include <sys/wait.h>
#include <time.h>

#ifdef MSG_NOSIGNAL
#define MSG_NOSIGNAL_COMPAT MSG_NOSIGNAL
#else
#define MSG_NOSIGNAL_COMPAT 0
#endif
#endif

namespace minta {

    /// Configuration options for HttpSink.
    ///
    /// @note DNS resolution (getaddrinfo) is not bounded by timeoutMs.
    ///       DNS may block for 30+ seconds on unresponsive resolvers.
    ///
    /// @code
    ///   HttpSinkOptions opts("http://localhost:8080/logs");
    ///   opts.setHeader("Authorization", "Bearer token123")
    ///       .setContentType("application/json")
    ///       .setBatchSize(100)
    ///       .setFlushIntervalMs(3000);
    /// @endcode
    struct HttpSinkOptions {
        std::string url;
        std::string contentType;
        std::map<std::string, std::string> headers;
        size_t timeoutMs;
        bool verifySsl;

        // Batch options (forwarded to BatchedSink)
        size_t batchSize;
        size_t flushIntervalMs;
        size_t maxRetries;
        size_t maxQueueSize;
        size_t retryDelayMs;

        explicit HttpSinkOptions(const std::string& url_)
            : url(url_)
            , contentType("application/json")
            , timeoutMs(10000)
            , verifySsl(true)
            , batchSize(50)
            , flushIntervalMs(5000)
            , maxRetries(3)
            , maxQueueSize(10000)
            , retryDelayMs(1000) {}

        HttpSinkOptions& setHeader(const std::string& key, const std::string& val) {
            headers[key] = val;
            return *this;
        }
        HttpSinkOptions& setContentType(const std::string& ct) {
            contentType = ct;
            return *this;
        }
        HttpSinkOptions& setTimeoutMs(size_t ms) {
            timeoutMs = ms;
            return *this;
        }
        HttpSinkOptions& setBatchSize(size_t n) {
            batchSize = n;
            return *this;
        }
        HttpSinkOptions& setFlushIntervalMs(size_t ms) {
            flushIntervalMs = ms;
            return *this;
        }
        HttpSinkOptions& setMaxRetries(size_t n) {
            maxRetries = n;
            return *this;
        }
        HttpSinkOptions& setMaxQueueSize(size_t n) {
            maxQueueSize = n;
            return *this;
        }
        HttpSinkOptions& setVerifySsl(bool v) {
            verifySsl = v;
            return *this;
        }
        HttpSinkOptions& setRetryDelayMs(size_t ms) {
            retryDelayMs = ms;
            return *this;
        }
    };

namespace detail {

    /// Parse a URL into scheme, host, port, and path components.
    struct ParsedUrl {
        std::string scheme;  // "http" or "https"
        std::string host;
        int port;
        std::string path;
        bool valid;

        ParsedUrl() : port(80), valid(false) {}
    };

    inline ParsedUrl parseUrl(const std::string& url) {
        ParsedUrl result;
        result.valid = false;

        // Find scheme
        size_t schemeEnd = url.find("://");
        if (schemeEnd == std::string::npos) return result;

        result.scheme = url.substr(0, schemeEnd);
        // RFC 3986 §3.1: scheme is case-insensitive
        std::transform(result.scheme.begin(), result.scheme.end(), result.scheme.begin(),
                       [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
        if (result.scheme != "http" && result.scheme != "https") return result;

        size_t hostStart = schemeEnd + 3;
        if (hostStart >= url.size()) return result;

        // Find path
        size_t pathStart = url.find('/', hostStart);
        std::string hostPort;
        if (pathStart == std::string::npos) {
            hostPort = url.substr(hostStart);
            result.path = "/";
        } else {
            hostPort = url.substr(hostStart, pathStart - hostStart);
            result.path = url.substr(pathStart);
        }

        // Note: IPv6 literal URLs (e.g. http://[::1]:8080/path) are not supported.
        // The bracket notation in the host conflicts with port-separator detection.
        if (!hostPort.empty() && hostPort[0] == '[') {
            return result; // valid=false — IPv6 not supported
        }

        // Find port
        size_t colonPos = hostPort.find(':');
        if (colonPos != std::string::npos) {
            result.host = hostPort.substr(0, colonPos);
            std::string portStr = hostPort.substr(colonPos + 1);
            if (portStr.empty()) return result;
            char* endPtr = nullptr;
            long portLong = std::strtol(portStr.c_str(), &endPtr, 10);
            if (endPtr == portStr.c_str() || *endPtr != '\0' || portLong < 1 || portLong > 65535) {
                return result;
            }
            result.port = static_cast<int>(portLong);
        } else {
            result.host = hostPort;
            result.port = (result.scheme == "https") ? 443 : 80;
        }

        if (result.host.empty()) return result;

        // Defense-in-depth: reject control characters to prevent HTTP header injection
        for (size_t i = 0; i < result.host.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(result.host[i]);
            if (c < 0x20 || c == 0x7F) return result;
        }
        for (size_t i = 0; i < result.path.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(result.path[i]);
            if (c < 0x20 || c == 0x7F) return result;
        }

        result.valid = true;
        return result;
    }

} // namespace detail

    /// HTTP/HTTPS sink that sends log batches as HTTP POST requests.
    ///
    /// Extends BatchedSink to batch log entries and send them as JSONL
    /// (newline-delimited JSON) payloads. Uses CompactJsonFormatter by default.
    ///
    /// Transport strategy:
    /// - http:// on POSIX: raw TCP socket with HTTP/1.1
    /// - https:// on POSIX: curl subprocess fallback
    /// - Windows: WinHTTP API
    ///
    /// @code
    ///   // Send logs to a local endpoint
    ///   HttpSinkOptions opts("http://localhost:8080/api/logs");
    ///   opts.setHeader("Authorization", "Bearer mytoken");
    ///   logger.addSink<HttpSink>(opts);
    ///
    ///   // Datadog example
    ///   HttpSinkOptions dd("https://http-intake.logs.datadoghq.com/api/v2/logs");
    ///   dd.setHeader("DD-API-KEY", "your-api-key");
    ///   dd.setBatchSize(100).setFlushIntervalMs(5000);
    ///   logger.addSink<HttpSink>(dd);
    /// @endcode
    class HttpSink : public BatchedSink {
    public:
        explicit HttpSink(HttpSinkOptions opts)
            : BatchedSink(makeBatchOptions(opts))
            , m_opts(std::move(opts))
            , m_formatter(detail::make_unique<CompactJsonFormatter>())
        {
            // Validate URL at construction time and cache parsed result.
            // parseUrl() sets valid=false for missing host, unsupported scheme,
            // and out-of-range port, so a single check covers all cases.
            m_parsedUrl = detail::parseUrl(m_opts.url);
            if (!m_parsedUrl.valid) {
                throw std::invalid_argument("HttpSink: invalid URL: " + m_opts.url);
            }
        }

        ~HttpSink() noexcept {
            stopAndFlush();
        }

    protected:
        void writeBatch(const std::vector<const LogEntry*>& batch) override {
            std::string body = formatBatch(batch);
            if (body.empty()) return;

            std::map<std::string, std::string> allHeaders = m_opts.headers;
            allHeaders["Content-Type"] = m_opts.contentType;
            if (allHeaders.find("User-Agent") == allHeaders.end()) {
                allHeaders["User-Agent"] = "LunarLog/1.0";
            }

            bool ok = httpPost(body, allHeaders, m_opts.timeoutMs);
            if (!ok) {
                throw std::runtime_error("HttpSink: HTTP POST failed to " + m_opts.url);
            }
        }

        void onBatchError(const std::exception& e, size_t retryCount) override {
            std::fprintf(stderr, "[HttpSink] Batch error (retry %zu): %s\n",
                        retryCount, e.what());
        }

    private:
        static BatchOptions makeBatchOptions(const HttpSinkOptions& opts) {
            BatchOptions bo;
            bo.setBatchSize(opts.batchSize)
              .setFlushIntervalMs(opts.flushIntervalMs)
              .setMaxRetries(opts.maxRetries)
              .setMaxQueueSize(opts.maxQueueSize)
              .setRetryDelayMs(opts.retryDelayMs);
            return bo;
        }

        std::string formatBatch(const std::vector<const LogEntry*>& batch) {
            std::string result;
            result.reserve(batch.size() * 256);
            for (size_t i = 0; i < batch.size(); ++i) {
                if (i > 0) result += '\n';
                result += m_formatter->format(*batch[i]);
            }
            return result;
        }

        bool httpPost(const std::string& body,
                      const std::map<std::string, std::string>& headers,
                      size_t timeoutMs) {
#ifdef _WIN32
            return httpPostWinHTTP(body, headers, timeoutMs);
#else
            if (m_parsedUrl.scheme == "https") {
                return httpPostCurl(m_opts.url, body, headers, timeoutMs);
            }
            return httpPostPosix(m_parsedUrl.host, m_parsedUrl.port, m_parsedUrl.path,
                                body, headers, timeoutMs);
#endif
        }

#ifndef _WIN32
        bool httpPostPosix(const std::string& host, int port,
                          const std::string& path, const std::string& body,
                          const std::map<std::string, std::string>& headers,
                          size_t timeoutMs) {
            // Absolute deadline: caps total elapsed time across all syscalls
            // to prevent slow-drip attacks that reset per-call timeouts.
            struct timespec deadline;
            clock_gettime(CLOCK_MONOTONIC, &deadline);
            deadline.tv_sec += static_cast<time_t>(timeoutMs / 1000);
            deadline.tv_nsec += static_cast<long>((timeoutMs % 1000) * 1000000L);
            if (deadline.tv_nsec >= 1000000000L) {
                deadline.tv_sec += 1;
                deadline.tv_nsec -= 1000000000L;
            }

            auto remainingMs = [&]() -> long {
                struct timespec now;
                clock_gettime(CLOCK_MONOTONIC, &now);
                long ms = (deadline.tv_sec - now.tv_sec) * 1000L
                        + (deadline.tv_nsec - now.tv_nsec) / 1000000L;
                return ms > 0 ? ms : 0;
            };

            // Resolve host
            struct addrinfo hints, *res = nullptr;
            std::memset(&hints, 0, sizeof(hints));
            hints.ai_family = AF_UNSPEC;  // IPv4 + IPv6
            hints.ai_socktype = SOCK_STREAM;

            std::string portStr = std::to_string(port);
            // NOTE: getaddrinfo() has no portable timeout mechanism on POSIX.
            // DNS resolution may block for 30+ seconds (system resolver timeout),
            // causing total elapsed time to exceed timeoutMs by the DNS duration.
            // The CLOCK_MONOTONIC deadline still bounds all subsequent socket operations.
            // TODO(future): consider getaddrinfo_a (glibc) or a dedicated resolver
            //               thread for portable DNS timeout support.
            int gaiResult = getaddrinfo(host.c_str(), portStr.c_str(), &hints, &res);
            if (gaiResult != 0 || !res) {
                if (res) freeaddrinfo(res);
                return false;
            }

            int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
            if (sockfd < 0) {
                freeaddrinfo(res);
                return false;
            }

            struct ScopedSocket {
                int fd;
                explicit ScopedSocket(int f) : fd(f) {}
                ~ScopedSocket() { if (fd >= 0) { ::close(fd); } }
                ScopedSocket(const ScopedSocket&) = delete;
                ScopedSocket& operator=(const ScopedSocket&) = delete;
            };
            ScopedSocket guard(sockfd);

#ifdef SO_NOSIGPIPE
            {
                int one = 1;
                setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &one, sizeof(one));
            }
#endif

            // Set non-blocking for connect timeout
            int flags = fcntl(sockfd, F_GETFL, 0);
            if (flags < 0) return false;
            if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) < 0) return false;

            int connectResult = connect(sockfd, res->ai_addr, res->ai_addrlen);
            freeaddrinfo(res);

            if (connectResult < 0) {
                if (errno != EINPROGRESS) {
                    return false;
                }
                // Wait for connection with timeout
                struct pollfd pfd;
                pfd.fd = sockfd;
                pfd.events = POLLOUT;
                pfd.revents = 0;

                int sel;
                do {
                    long rm = remainingMs();
                    if (rm <= 0) { sel = 0; break; }
                    sel = poll(&pfd, 1, static_cast<int>(rm > static_cast<long>(INT_MAX) ? INT_MAX : rm));
                } while (sel < 0 && errno == EINTR);
                if (sel <= 0) {
                    return false;
                }

                int so_error = 0;
                socklen_t len = sizeof(so_error);
                getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);
                if (so_error != 0) {
                    return false;
                }
            }

            // Set back to blocking
            if (fcntl(sockfd, F_SETFL, flags) < 0) return false;

            // SO_SNDTIMEO / SO_RCVTIMEO are set once. remainingMs() guards loop
            // entry so no new calls start after deadline, but the last in-flight
            // call may overshoot by up to the remaining value at time of setting.
            // Acceptable for a logging transport.
            // TODO(future): re-set SO_SNDTIMEO/SO_RCVTIMEO before each send/recv
            //               using remainingMs() for strict per-call deadline adherence.
            {
                long rm = remainingMs();
                if (rm <= 0) return false;
                struct timeval tv;
                tv.tv_sec = static_cast<long>(rm / 1000);
                tv.tv_usec = static_cast<long>((rm % 1000) * 1000);
                setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
                setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
            }

            // Build HTTP request
            std::string request;
            request += "POST " + path + " HTTP/1.1\r\n";
            std::string hostHeader = host;
            // httpPostPosix handles http:// only; default port is 80.
            if (port != 80) {
                hostHeader += ":" + std::to_string(port);
            }
            request += "Host: " + hostHeader + "\r\n";
            request += "Content-Length: " + std::to_string(body.size()) + "\r\n";
            request += "Connection: close\r\n";
            for (std::map<std::string, std::string>::const_iterator it = headers.begin();
                 it != headers.end(); ++it) {
                request += it->first + ": " + it->second + "\r\n";
            }
            request += "\r\n";
            request += body;

            // Send
            ssize_t totalSent = 0;
            ssize_t requestLen = static_cast<ssize_t>(request.size());
            const char* ptr = request.c_str();
            while (totalSent < requestLen) {
                if (remainingMs() <= 0) return false;
                size_t remaining = static_cast<size_t>(requestLen - totalSent);
                ssize_t sent;
                do {
                    sent = send(sockfd, ptr + totalSent, remaining, MSG_NOSIGNAL_COMPAT);
                } while (sent < 0 && errno == EINTR);
                if (sent <= 0) {
                    return false;
                }
                totalSent += sent;
            }

            // Read HTTP status line in bulk (up to 256 B per recv) to reduce
            // syscall overhead.  Accumulate until \r\n for TCP segmentation.
            std::string responseBuf;
            responseBuf.reserve(256);
            {
                char buf[256];
                while (responseBuf.size() < 4096) {
                    if (remainingMs() <= 0) break;
                    ssize_t n;
                    do { n = ::recv(sockfd, buf, sizeof(buf) - 1, 0); }
                    while (n < 0 && errno == EINTR);
                    if (n <= 0) break;
                    responseBuf.append(buf, static_cast<size_t>(n));
                    if (responseBuf.find("\r\n") != std::string::npos) break;
                }
            }

            if (responseBuf.empty()) return false;

            // Expected: "HTTP/1.1 200 OK\r\n"
            size_t spacePos = responseBuf.find(' ');
            if (spacePos == std::string::npos) return false;
            char* endPtr = nullptr;
            long statusCode = std::strtol(responseBuf.c_str() + spacePos + 1, &endPtr, 10);
            bool success = (endPtr != responseBuf.c_str() + spacePos + 1 && statusCode >= 200 && statusCode < 300);

            // Drain remaining response body to avoid TCP RST on socket close
            if (remainingMs() > 0) {
                char drain[1024];
                ssize_t n;
                do {
                    do { n = ::recv(sockfd, drain, sizeof(drain), 0); }
                    while (n < 0 && errno == EINTR);
                } while (n > 0 && remainingMs() > 0);
            }

            return success;
        }

        // CWE-78 fix: uses fork/execvp instead of popen to avoid shell injection.
        // argv elements go directly to curl with no shell interpretation.
        // Requires C++11 or later (SSO guaranteed, no COW string implementations).
        // argv strings are valid in child process after fork() due to value semantics.
        bool httpPostCurl(const std::string& url, const std::string& body,
                         const std::map<std::string, std::string>& headers,
                         size_t timeoutMs) {
            std::vector<std::string> args;
            args.push_back("curl");
            args.push_back("--silent");
            args.push_back("--fail");
            args.push_back("-o");
            args.push_back("/dev/null");
            args.push_back("-X");
            args.push_back("POST");
            if (!m_opts.verifySsl) {
                args.push_back("--insecure");
            }
            args.push_back("--max-time");
            {
                size_t maxTimeSec = (timeoutMs + 999) / 1000;
                if (maxTimeSec == 0) maxTimeSec = 1;
                args.push_back(std::to_string(maxTimeSec));
            }

            for (std::map<std::string, std::string>::const_iterator it = headers.begin();
                 it != headers.end(); ++it) {
                bool clean = true;
                for (size_t ci = 0; ci < it->first.size() && clean; ++ci) {
                    unsigned char ch = static_cast<unsigned char>(it->first[ci]);
                    if (ch < 0x20 || ch == 0x7F) clean = false;
                }
                for (size_t ci = 0; ci < it->second.size() && clean; ++ci) {
                    unsigned char ch = static_cast<unsigned char>(it->second[ci]);
                    if (ch < 0x20 || ch == 0x7F) clean = false;
                }
                if (!clean) continue;
                args.push_back("-H");
                args.push_back(it->first + ": " + it->second);
            }

            args.push_back("--data-binary");
            args.push_back("@-");
            args.push_back(url);

            std::vector<char*> argv;
            argv.reserve(args.size() + 1);
            for (size_t i = 0; i < args.size(); ++i) {
                argv.push_back(const_cast<char*>(args[i].c_str()));
            }
            argv.push_back(nullptr);

            // Absolute deadline: caps total elapsed time (pipe write + child wait)
            // to prevent 2*timeoutMs blocking.
            struct timespec deadline;
            clock_gettime(CLOCK_MONOTONIC, &deadline);
            deadline.tv_sec += static_cast<time_t>(timeoutMs / 1000);
            deadline.tv_nsec += static_cast<long>((timeoutMs % 1000) * 1000000L);
            if (deadline.tv_nsec >= 1000000000L) {
                deadline.tv_sec += 1;
                deadline.tv_nsec -= 1000000000L;
            }
            auto remainingMs = [&]() -> long {
                struct timespec now;
                clock_gettime(CLOCK_MONOTONIC, &now);
                long ms = (deadline.tv_sec - now.tv_sec) * 1000L
                        + (deadline.tv_nsec - now.tv_nsec) / 1000000L;
                return ms > 0 ? ms : 0;
            };

            int pipefd[2];
#if defined(__linux__) || defined(__FreeBSD__)
            if (pipe2(pipefd, O_CLOEXEC) != 0) return false;
#else
            if (pipe(pipefd) != 0) return false;
            fcntl(pipefd[0], F_SETFD, FD_CLOEXEC);
            fcntl(pipefd[1], F_SETFD, FD_CLOEXEC);
#endif

            pid_t pid = fork();
            if (pid < 0) {
                close(pipefd[0]);
                close(pipefd[1]);
                return false;
            }

            if (pid == 0) {
                // Child: wire pipe read-end to stdin, discard stdout/stderr
                close(pipefd[1]);
                dup2(pipefd[0], STDIN_FILENO);
                close(pipefd[0]);

                int devnull = open("/dev/null", O_WRONLY);
                if (devnull >= 0) {
                    dup2(devnull, STDOUT_FILENO);
                    dup2(devnull, STDERR_FILENO);
                    close(devnull);
                }

                execvp("curl", argv.data());
                _exit(127);
            }

            // Parent: write body then wait
            close(pipefd[0]);

            // Block SIGPIPE so broken-pipe returns EPIPE instead of killing the process.
            // If the child exits early (exec failure, connection refused), the pipe read-end
            // closes and write() would otherwise raise SIGPIPE with the default handler.
            struct ScopedSigpipeBlock {
                sigset_t m_old;
                ScopedSigpipeBlock() {
                    sigset_t block;
                    sigemptyset(&block);
                    sigaddset(&block, SIGPIPE);
                    pthread_sigmask(SIG_BLOCK, &block, &m_old);
                }
                ~ScopedSigpipeBlock() {
                    pthread_sigmask(SIG_SETMASK, &m_old, nullptr);
                }
            };

            bool writeOk = true;
            {
                ScopedSigpipeBlock sigGuard;
                const char* data = body.c_str();
                size_t remaining = body.size();

                struct pollfd wfd;
                wfd.fd = pipefd[1];
                wfd.events = POLLOUT;
                while (remaining > 0) {
                    long rem = remainingMs();
                    if (rem <= 0) { writeOk = false; break; }
                    int pr;
                    do { pr = ::poll(&wfd, 1, static_cast<int>(rem > static_cast<long>(INT_MAX) ? INT_MAX : rem)); }
                    while (pr < 0 && errno == EINTR);
                    if (pr <= 0) { writeOk = false; break; }
                    ssize_t w;
                    do { w = ::write(pipefd[1], data, remaining); }
                    while (w < 0 && errno == EINTR);
                    if (w <= 0) { writeOk = false; break; }
                    data += w;
                    remaining -= static_cast<size_t>(w);
                }
                close(pipefd[1]);
            }

            int status = 0;
            // WNOHANG poll loop bounded by deadline
            while (true) {
                pid_t w;
                do { w = waitpid(pid, &status, WNOHANG); }
                while (w < 0 && errno == EINTR);
                if (w > 0) break;           // child exited
                if (w < 0) return false;    // error
                // w == 0: still running
                long rem = remainingMs();
                if (rem <= 0) {
                    kill(pid, SIGTERM);
                    // Wait up to 200ms for graceful exit before SIGKILL
                    for (int gi = 0; gi < 20; ++gi) {
                        pid_t gw;
                        do { gw = waitpid(pid, &status, WNOHANG); }
                        while (gw < 0 && errno == EINTR);
                        if (gw > 0) return false;
                        struct timespec gts = {0, 10000000L}; // 10ms
                        nanosleep(&gts, nullptr);
                    }
                    kill(pid, SIGKILL);
                    waitpid(pid, &status, 0);  // reap — SIGKILL is unconditional
                    return false;
                }
                long sleepMs = std::min(rem, 50L);
                struct timespec ts = { sleepMs / 1000, (sleepMs % 1000) * 1000000L };
                nanosleep(&ts, nullptr);
            }

            if (!writeOk) return false;
            return WIFEXITED(status) && WEXITSTATUS(status) == 0;
        }
#endif // !_WIN32

#ifdef _WIN32
        struct WinHttpHandleGuard {
            HINTERNET h;
            explicit WinHttpHandleGuard(HINTERNET handle) : h(handle) {}
            ~WinHttpHandleGuard() { if (h) WinHttpCloseHandle(h); }
            operator HINTERNET() const { return h; }
            WinHttpHandleGuard(const WinHttpHandleGuard&) = delete;
            WinHttpHandleGuard& operator=(const WinHttpHandleGuard&) = delete;
        };

        static std::wstring utf8ToWide(const std::string& str) {
            if (str.empty()) return std::wstring();
            int needed = MultiByteToWideChar(CP_UTF8, 0, str.c_str(),
                             static_cast<int>(str.size()), nullptr, 0);
            if (needed <= 0) return std::wstring(str.begin(), str.end());
            std::wstring result(static_cast<size_t>(needed), L'\0');
            MultiByteToWideChar(CP_UTF8, 0, str.c_str(),
                static_cast<int>(str.size()), &result[0], needed);
            return result;
        }

        bool httpPostWinHTTP(const std::string& body,
                            const std::map<std::string, std::string>& headers,
                            size_t timeoutMs) {
            std::wstring wHost = utf8ToWide(m_parsedUrl.host);
            std::wstring wPath = utf8ToWide(m_parsedUrl.path);

            WinHttpHandleGuard hSession(WinHttpOpen(L"LunarLog/1.0",
                WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                WINHTTP_NO_PROXY_NAME,
                WINHTTP_NO_PROXY_BYPASS, 0));
            if (!hSession) return false;

            DWORD timeout = static_cast<DWORD>(timeoutMs);
            WinHttpSetTimeouts(hSession, timeout, timeout, timeout, timeout);

            WinHttpHandleGuard hConnect(WinHttpConnect(hSession,
                wHost.c_str(),
                static_cast<INTERNET_PORT>(m_parsedUrl.port), 0));
            if (!hConnect) return false;

            DWORD flags = (m_parsedUrl.scheme == "https") ? WINHTTP_FLAG_SECURE : 0;
            WinHttpHandleGuard hRequest(WinHttpOpenRequest(hConnect,
                L"POST", wPath.c_str(),
                NULL, WINHTTP_NO_REFERER,
                WINHTTP_DEFAULT_ACCEPT_TYPES, flags));
            if (!hRequest) return false;

            if (!m_opts.verifySsl) {
                DWORD secFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA
                               | SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE
                               | SECURITY_FLAG_IGNORE_CERT_CN_INVALID
                               | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;
                WinHttpSetOption(hRequest, WINHTTP_OPTION_SECURITY_FLAGS,
                                 &secFlags, sizeof(secFlags));
            }

            for (std::map<std::string, std::string>::const_iterator it = headers.begin();
                 it != headers.end(); ++it) {
                std::string headerLine = it->first + ": " + it->second;
                std::wstring wHeader = utf8ToWide(headerLine);
                WinHttpAddRequestHeaders(hRequest, wHeader.c_str(),
                    static_cast<DWORD>(wHeader.size()),
                    WINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE);
            }

            BOOL sendOk = WinHttpSendRequest(hRequest,
                WINHTTP_NO_ADDITIONAL_HEADERS, 0,
                static_cast<LPVOID>(const_cast<char*>(body.c_str())),
                static_cast<DWORD>(body.size()),
                static_cast<DWORD>(body.size()), 0);
            if (!sendOk) return false;

            if (!WinHttpReceiveResponse(hRequest, NULL)) return false;

            DWORD statusCode = 0;
            DWORD statusSize = sizeof(statusCode);
            WinHttpQueryHeaders(hRequest,
                WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                WINHTTP_HEADER_NAME_BY_INDEX,
                &statusCode, &statusSize, WINHTTP_NO_HEADER_INDEX);

            return (statusCode >= 200 && statusCode < 300);
        }
#endif // _WIN32

        HttpSinkOptions m_opts;
        detail::ParsedUrl m_parsedUrl;
        std::unique_ptr<CompactJsonFormatter> m_formatter;
    };

} // namespace minta


// --- lunar_log/log_manager.hpp ---

#include <vector>
#include <memory>
#include <atomic>
#include <functional>
#include <mutex>
#include <stdexcept>
#include <unordered_map>
#include <string>

namespace minta {
    class LogManager {
    public:
        LogManager() : m_loggingStarted(false), m_nextAutoIndex(0) {}

        /// Move constructor — used by the builder pattern.
        /// Safe only when no logging has started (no concurrent access).
        LogManager(LogManager&& other) noexcept
            : m_sinks(std::move(other.m_sinks))
            , m_loggingStarted(other.m_loggingStarted.load(std::memory_order_relaxed))
            , m_sinkNames(std::move(other.m_sinkNames))
            , m_nextAutoIndex(other.m_nextAutoIndex)
        {
            other.m_loggingStarted.store(false, std::memory_order_relaxed);
            other.m_nextAutoIndex = 0;
        }

        LogManager& operator=(LogManager&&) = delete;
        LogManager(const LogManager&) = delete;
        LogManager& operator=(const LogManager&) = delete;

        // Add all sinks before any log calls are made.
        //
        // There is a TOCTOU race between the m_loggingStarted check and the
        // push_back: two threads could both pass the check concurrently. This
        // is acceptable because the documented contract requires all sinks to
        // be added before any log calls, so well-behaved callers never hit
        // this window. The atomic check is a best-effort safety net, not a
        // thread-safe gate.
        void addSink(std::unique_ptr<ISink> sink) {
            if (m_loggingStarted.load(std::memory_order_acquire)) {
                throw std::logic_error("Cannot add sinks after logging has started");
            }
            // Auto-name unnamed sinks, skipping collisions with user-named sinks
            std::string autoName;
            do {
                autoName = "sink_" + std::to_string(m_nextAutoIndex++);
            } while (m_sinkNames.count(autoName) > 0);
            sink->setSinkName(autoName);
            m_sinks.push_back(std::move(sink));
            m_sinkNames[autoName] = m_sinks.size() - 1;
        }

        /// Add a named sink. Throws std::invalid_argument if name is duplicate.
        void addSink(const std::string& name, std::unique_ptr<ISink> sink) {
            if (m_loggingStarted.load(std::memory_order_acquire)) {
                throw std::logic_error("Cannot add sinks after logging has started");
            }
            if (m_sinkNames.count(name)) {
                throw std::invalid_argument("Duplicate sink name: " + name);
            }
            sink->setSinkName(name);
            m_sinks.push_back(std::move(sink));
            m_sinkNames[name] = m_sinks.size() - 1;
            m_nextAutoIndex++; // keep auto index advancing
        }

        /// Get sink index by name. Throws std::invalid_argument if not found.
        size_t getSinkIndex(const std::string& name) const {
            auto it = m_sinkNames.find(name);
            if (it == m_sinkNames.end()) {
                throw std::invalid_argument("Unknown sink name: " + name);
            }
            return it->second;
        }

        bool isLoggingStarted() const {
            return m_loggingStarted.load(std::memory_order_acquire);
        }

        /// Get sink pointer by index.
        ISink* getSink(size_t index) {
            requireValidIndex(index);
            return m_sinks[index].get();
        }

        const ISink* getSink(size_t index) const {
            requireValidIndex(index);
            return m_sinks[index].get();
        }

        /// Filter pipeline: global min level (caller) -> global predicate -> global DSL rules
        ///                -> per-sink tag routing -> per-sink min level -> per-sink predicate -> per-sink DSL rules.
        /// Global filter state is passed as COW shared_ptr snapshots — no mutex
        /// needed here because the caller snapshots under lock before calling.
        void log(const LogEntry &entry,
                 const std::shared_ptr<const FilterPredicate>& globalFilter,
                 const std::shared_ptr<const std::vector<FilterRule>>& globalFilterRules) {
            if (!m_loggingStarted.load(std::memory_order_relaxed)) {
                m_loggingStarted.store(true, std::memory_order_release);
            }

            if (globalFilter || globalFilterRules) {
                try {
                    if (globalFilter && *globalFilter && !(*globalFilter)(entry)) return;
                    if (globalFilterRules) {
                        for (const auto& rule : *globalFilterRules) {
                            if (!rule.evaluate(entry)) return;
                        }
                    }
                } catch (...) {
                    // Bad global filter — fail-open: let the entry through
                    // rather than silently dropping it for all sinks.
                }
            }

            for (const auto &sink : m_sinks) {
                try {
                    if (!sink->shouldAcceptTags(entry.tags)) continue;
                    if (sink->passesFilter(entry)) {
                        sink->write(entry);
                    }
                } catch (...) {
                    // One bad sink must not prevent subsequent sinks from running.
                }
            }
        }

        void setSinkLevel(size_t index, LogLevel level) {
            requireValidIndex(index);
            m_sinks[index]->setMinLevel(level);
        }

        void setSinkFilter(size_t index, FilterPredicate filter) {
            requireValidIndex(index);
            m_sinks[index]->setFilter(std::move(filter));
        }

        void clearSinkFilter(size_t index) {
            requireValidIndex(index);
            m_sinks[index]->clearFilter();
        }

        void addSinkFilterRule(size_t index, const std::string& ruleStr) {
            requireValidIndex(index);
            m_sinks[index]->addFilterRule(ruleStr);
        }

        void clearSinkFilterRules(size_t index) {
            requireValidIndex(index);
            m_sinks[index]->clearFilterRules();
        }

        void clearAllSinkFilters(size_t index) {
            requireValidIndex(index);
            m_sinks[index]->clearAllFilters();
        }

        void setSinkLocale(size_t index, const std::string& locale) {
            requireValidIndex(index);
            m_sinks[index]->setLocale(locale);
        }

        void flushSinks() {
            for (auto& sink : m_sinks) {
                try {
                    sink->flush();
                } catch (...) {}
            }
        }

    private:
        void requireValidIndex(size_t index) const {
            if (index >= m_sinks.size()) {
                throw std::out_of_range("Sink index out of range");
            }
        }

        std::vector<std::unique_ptr<ISink> > m_sinks;
        std::atomic<bool> m_loggingStarted;
        std::unordered_map<std::string, size_t> m_sinkNames;
        size_t m_nextAutoIndex;
        // NOTE: The global filter state (predicate, DSL rules, mutex) lives in
        // LunarLog and is passed into log() by reference.  A future cleanup
        // could bundle these into a GlobalFilterConfig struct owned here.
    };
} // namespace minta


// --- lunar_log/log_source.hpp ---

#include <atomic>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <type_traits>
#include <set>
#include <functional>
#include <map>
#include <unordered_map>
#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <cstdio>
#include <climits>
#include <cmath>
#include <sstream>
#include <list>

namespace minta {

    /// Tag type for disambiguating named-sink overloads from unnamed ones (H3).
    /// Use: logger.addSink<ConsoleSink>(named("console"))
    /// This prevents SFINAE ambiguity when SinkType is constructible from std::string.
    struct SinkName {
        std::string value;
        explicit SinkName(const std::string& n) : value(n) {}
        explicit SinkName(const char* n) : value(n) {}
    };

    /// Convenience factory for SinkName.
    inline SinkName named(const std::string& name) { return SinkName(name); }
    inline SinkName named(const char* name) { return SinkName(name); }

namespace detail {
    /// Parse [bracketed] tag prefixes from a message template.
    /// Tags must be at the start, contain only alphanumeric, hyphens, underscores.
    /// Brackets must be immediately adjacent: "[a][b] msg" parses two tags,
    /// but "[a] [b] msg" only parses one because the space breaks the scan.
    /// Returns the tags and the remaining message (stripped of tag prefixes).
    inline std::pair<std::vector<std::string>, std::string> parseTags(const std::string& messageTemplate) {
        std::vector<std::string> tags;
        size_t pos = 0;
        while (pos < messageTemplate.size() && messageTemplate[pos] == '[') {
            size_t close = messageTemplate.find(']', pos + 1);
            if (close == std::string::npos) break;
            std::string tag = messageTemplate.substr(pos + 1, close - pos - 1);
            // Validate tag: alphanumeric + hyphens + underscores only
            bool valid = !tag.empty();
            for (size_t i = 0; i < tag.size() && valid; ++i) {
                char c = tag[i];
                if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') || c == '-' || c == '_')) {
                    valid = false;
                }
            }
            if (!valid) break;
            tags.push_back(std::move(tag));
            pos = close + 1;
        }
        // Fast path: no tags found — pair construction still copies
        // messageTemplate, but avoids the substr + whitespace-strip work.
        if (tags.empty()) {
            return {tags, messageTemplate};
        }
        // Strip leading whitespace (spaces and tabs) after tags
        while (pos < messageTemplate.size() && (messageTemplate[pos] == ' ' || messageTemplate[pos] == '\t')) ++pos;
        return {tags, messageTemplate.substr(pos)};
    }
    using ScopeFrame = std::vector<std::pair<std::string, std::string>>;
    using ScopeStack = std::list<ScopeFrame>;
    using ScopeFrameIter = ScopeStack::iterator;

    inline ScopeStack& threadScopeStack() {
        thread_local ScopeStack stack;
        return stack;
    }

} // namespace detail

    class LoggerConfiguration;
    class LogScope;

    class LunarLog {
    public:
        explicit LunarLog(LogLevel minLevel = LogLevel::INFO, bool addDefaultConsoleSink = true)
            : m_minLevel(minLevel)
            , m_isRunning(true)
            , m_rateLimitWindowStart(std::chrono::steady_clock::now().time_since_epoch().count())
            , m_logCount(0)
            , m_captureSourceLocation(false)
            , m_hasCustomContext(false)
            , m_sinkWriteInProgress(false)
            , m_templateCacheSize(128)
            , m_hasGlobalFilters(false)
            , m_rateLimitMaxLogs(1000)
            , m_rateLimitWindowMs(1000)
            , m_threadStarted(false) {
            if (addDefaultConsoleSink) {
                addSink<ConsoleSink>();
            }
            ensureProcessingThread();
        }

        // NOTE: LunarLog must outlive all logging threads. Destroying LunarLog
        // while other threads are still calling log methods is undefined behavior.
        ~LunarLog() noexcept {
            if (m_threadStarted.load(std::memory_order_acquire)) {
                flush();
                m_isRunning = false;
                m_logCV.notify_one();
                if (m_logThread.joinable()) {
                    m_logThread.join();
                }
            }
        }

        LunarLog(const LunarLog &) = delete;
        LunarLog &operator=(const LunarLog &) = delete;

        /// Move constructor — only safe before logging starts (used by builder).
        LunarLog(LunarLog &&other) noexcept
            : m_minLevel(other.m_minLevel.load(std::memory_order_relaxed))
            , m_isRunning(true)
            , m_rateLimitWindowStart(other.m_rateLimitWindowStart.load(std::memory_order_relaxed))
            , m_logCount(0)
            , m_logManager(std::move(other.m_logManager))
            , m_customContext(std::move(other.m_customContext))
            , m_captureSourceLocation(other.m_captureSourceLocation.load(std::memory_order_relaxed))
            , m_hasCustomContext(other.m_hasCustomContext.load(std::memory_order_relaxed))
            , m_sinkWriteInProgress(false)
            , m_templateCache(std::move(other.m_templateCache))
            , m_templateCacheSize(other.m_templateCacheSize)
            , m_hasGlobalFilters(other.m_hasGlobalFilters.load(std::memory_order_relaxed))
            , m_globalFilter(std::move(other.m_globalFilter))
            , m_globalFilterRules(std::move(other.m_globalFilterRules))
            , m_hasLocale(other.m_hasLocale.load(std::memory_order_relaxed))
            , m_locale(std::move(other.m_locale))
            , m_enrichers(std::move(other.m_enrichers))
            , m_hasEnrichers(other.m_hasEnrichers.load(std::memory_order_relaxed))
            , m_rateLimitMaxLogs(other.m_rateLimitMaxLogs)
            , m_rateLimitWindowMs(other.m_rateLimitWindowMs)
            , m_threadStarted(false)
        {
            other.m_isRunning.store(false, std::memory_order_relaxed);
        }

        LunarLog &operator=(LunarLog &&) = delete;

        /// Create a fluent builder for configuring a new LunarLog instance.
        static LoggerConfiguration configure();

        void setMinLevel(LogLevel level) {
            m_minLevel.store(level, std::memory_order_relaxed);
        }

        LogLevel getMinLevel() const {
            return m_minLevel.load(std::memory_order_relaxed);
        }

        void setCaptureSourceLocation(bool capture) {
            m_captureSourceLocation.store(capture, std::memory_order_relaxed);
        }

        bool getCaptureSourceLocation() const {
            return m_captureSourceLocation.load(std::memory_order_relaxed);
        }

        /// Set rate-limit parameters (max messages per window).
        /// Must be called during setup, before the first log call.
        /// Corresponds to LoggerConfiguration::rateLimit() in the builder API.
        void setRateLimit(size_t maxLogs, std::chrono::milliseconds window) {
            m_rateLimitMaxLogs = maxLogs;
            m_rateLimitWindowMs = static_cast<long long>(window.count());
        }

        /// @deprecated Use setCaptureSourceLocation instead.
        inline void setCaptureContext(bool capture) {
            setCaptureSourceLocation(capture);
        }

        /// @deprecated Use getCaptureSourceLocation instead.
        inline bool getCaptureContext() const {
            return getCaptureSourceLocation();
        }

        /// @warning Do not call flush() from within a sink write() implementation.
        ///          flush() acquires the queue mutex and waits for sink writes to
        ///          complete, so calling it from inside write() will deadlock.
        void flush() {
            if (!m_threadStarted.load(std::memory_order_acquire)) return;
            {
                std::unique_lock<std::mutex> lock(m_queueMutex);
                m_flushCV.wait(lock, [this] {
                    return m_logQueue.empty() && !m_sinkWriteInProgress.load(std::memory_order_relaxed);
                });
            }
            m_logManager.flushSinks();
        }

        /// Add an unnamed sink (auto-named "sink_0", "sink_1", etc.).
        /// SFINAE: only viable when SinkType is constructible from Args.
        template<typename SinkType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(Args &&... args) {
            m_logManager.addSink(detail::make_unique<SinkType>(std::forward<Args>(args)...));
        }

        /// Add an unnamed sink with a custom formatter.
        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_base_of<IFormatter, FormatterType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(std::move(sink));
        }

        /// Add a named sink: addSink<ConsoleSink>(named("console"))
        /// Uses SinkName tag type to avoid SFINAE ambiguity with unnamed overloads.
        template<typename SinkType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const SinkName& sinkName, Args &&... args) {
            m_logManager.addSink(sinkName.value, detail::make_unique<SinkType>(std::forward<Args>(args)...));
        }

        /// Add a named sink with a custom formatter:
        /// addSink<FileSink, JsonFormatter>(named("json-out"), "app.jsonl")
        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_base_of<IFormatter, FormatterType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const SinkName& sinkName, Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(sinkName.value, std::move(sink));
        }

        /// Convenience: addSink<SinkType>("name", args...) still works via
        /// const std::string& overload. This is unambiguous because SinkName
        /// is explicit-only from string, so implicit conversions go here.
        template<typename SinkType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const std::string& name, Args &&... args) {
            m_logManager.addSink(name, detail::make_unique<SinkType>(std::forward<Args>(args)...));
        }

        /// Named sink with formatter via string name.
        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_base_of<IFormatter, FormatterType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const std::string& name, Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(name, std::move(sink));
        }

        void addCustomSink(std::unique_ptr<ISink> sink) {
            m_logManager.addSink(std::move(sink));
        }

        void addCustomSink(const std::string& name, std::unique_ptr<ISink> sink) {
            m_logManager.addSink(name, std::move(sink));
        }

        /// Get a SinkProxy for configuring a named sink.
        /// Throws std::invalid_argument if name is not found.
        SinkProxy sink(const std::string& name);

        template<typename... Args>
        void log(LogLevel level, const std::string &messageTemplate, const Args &... args) {
            logInternal(level, "", 0, "", messageTemplate, args...);
        }

        template<typename... Args>
        void logWithSourceLocation(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            logInternal(level, file, line, function, messageTemplate, args...);
        }

        /// @deprecated Use logWithSourceLocation instead.
        template<typename... Args>
        void logWithContext(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            logWithSourceLocation(level, file, line, function, messageTemplate, args...);
        }

        template<typename... Args>
        void logWithSourceLocationAndException(LogLevel level, const char* file, int line, const char* function,
                                               const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            logInternalWithException(level, file, line, function, ex, messageTemplate, args...);
        }

        template<typename... Args>
        void trace(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::TRACE, messageTemplate, args...);
        }

        template<typename... Args>
        void debug(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::DEBUG, messageTemplate, args...);
        }

        template<typename... Args>
        void info(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::INFO, messageTemplate, args...);
        }

        template<typename... Args>
        void warn(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::WARN, messageTemplate, args...);
        }

        template<typename... Args>
        void error(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::ERROR, messageTemplate, args...);
        }

        template<typename... Args>
        void fatal(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::FATAL, messageTemplate, args...);
        }

        template<typename... Args>
        void log(LogLevel level, const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            logInternalWithException(level, "", 0, "", ex, messageTemplate, args...);
        }

        void log(LogLevel level, const std::exception& ex) {
            logInternalWithException(level, "", 0, "", ex, detail::safeWhat(ex));
        }

        template<typename... Args>
        void trace(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::TRACE, ex, messageTemplate, args...);
        }
        void trace(const std::exception& ex) { log(LogLevel::TRACE, ex); }

        template<typename... Args>
        void debug(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::DEBUG, ex, messageTemplate, args...);
        }
        void debug(const std::exception& ex) { log(LogLevel::DEBUG, ex); }

        template<typename... Args>
        void info(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::INFO, ex, messageTemplate, args...);
        }
        void info(const std::exception& ex) { log(LogLevel::INFO, ex); }

        template<typename... Args>
        void warn(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::WARN, ex, messageTemplate, args...);
        }
        void warn(const std::exception& ex) { log(LogLevel::WARN, ex); }

        template<typename... Args>
        void error(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::ERROR, ex, messageTemplate, args...);
        }
        void error(const std::exception& ex) { log(LogLevel::ERROR, ex); }

        template<typename... Args>
        void fatal(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::FATAL, ex, messageTemplate, args...);
        }
        void fatal(const std::exception& ex) { log(LogLevel::FATAL, ex); }

        /// @note The predicate is invoked on the consumer thread against an
        ///       immutable snapshot.  It must be fast and non-blocking.
        ///       Filter predicates must capture state by value.  Referenced
        ///       objects must outlive the logger.
        void setFilter(FilterPredicate filter) {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilter = std::make_shared<const FilterPredicate>(std::move(filter));
            m_hasGlobalFilters.store(true, std::memory_order_release);
        }

        void clearFilter() {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilter.reset();
            m_hasGlobalFilters.store(m_globalFilterRules && !m_globalFilterRules->empty(), std::memory_order_release);
        }

        void addFilterRule(const std::string& ruleStr) {
            FilterRule rule = FilterRule::parse(ruleStr);
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            auto newRules = std::make_shared<std::vector<FilterRule>>(
                m_globalFilterRules ? *m_globalFilterRules : std::vector<FilterRule>());
            newRules->push_back(std::move(rule));
            m_globalFilterRules = std::move(newRules);
            m_hasGlobalFilters.store(true, std::memory_order_release);
        }

        void clearFilterRules() {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilterRules.reset();
            m_hasGlobalFilters.store(m_globalFilter && static_cast<bool>(*m_globalFilter), std::memory_order_release);
        }

        void clearAllFilters() {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilter.reset();
            m_globalFilterRules.reset();
            m_hasGlobalFilters.store(false, std::memory_order_release);
        }

        /// Add compact filter rules (space-separated, AND-combined).
        /// Syntax: "WARN+", "~keyword", "!~keyword", "ctx:key", "ctx:key=val",
        /// "tpl:pattern", "!tpl:pattern". See Compact-Filter wiki page.
        /// Thread-safe — acquires global filter mutex.
        void filter(const std::string& compactExpr) {
            std::vector<FilterRule> rules = detail::parseCompactFilter(compactExpr);
            if (rules.empty()) return;
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            auto newRules = std::make_shared<std::vector<FilterRule>>(
                m_globalFilterRules ? *m_globalFilterRules : std::vector<FilterRule>());
            newRules->reserve(newRules->size() + rules.size());
            for (size_t i = 0; i < rules.size(); ++i) {
                newRules->push_back(std::move(rules[i]));
            }
            m_globalFilterRules = std::move(newRules);
            m_hasGlobalFilters.store(true, std::memory_order_release);
        }

        void setSinkLevel(size_t sinkIndex, LogLevel level) {
            m_logManager.setSinkLevel(sinkIndex, level);
        }

        void setSinkFilter(size_t sinkIndex, FilterPredicate filter) {
            m_logManager.setSinkFilter(sinkIndex, std::move(filter));
        }

        void clearSinkFilter(size_t sinkIndex) {
            m_logManager.clearSinkFilter(sinkIndex);
        }

        void addSinkFilterRule(size_t sinkIndex, const std::string& ruleStr) {
            m_logManager.addSinkFilterRule(sinkIndex, ruleStr);
        }

        void clearSinkFilterRules(size_t sinkIndex) {
            m_logManager.clearSinkFilterRules(sinkIndex);
        }

        void clearAllSinkFilters(size_t sinkIndex) {
            m_logManager.clearAllSinkFilters(sinkIndex);
        }

        void setContext(const std::string& key, const std::string& value) {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext[key] = value;
            m_hasCustomContext.store(true, std::memory_order_release);
        }

        void clearContext(const std::string& key) {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext.erase(key);
            m_hasCustomContext.store(!m_customContext.empty(), std::memory_order_release);
        }

        void clearAllContext() {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext.clear();
            m_hasCustomContext.store(false, std::memory_order_release);
        }

        LogScope scope(std::initializer_list<std::pair<std::string, std::string>> pairs);

        /// Set the maximum number of cached template parse results.
        /// Setting to 0 disables caching and clears existing entries.
        /// Shrinking to a non-zero value does NOT trim existing entries —
        /// they remain accessible for lookups but no new entries are
        /// inserted until the map size drops below the new cap.
        void setTemplateCacheSize(size_t size) {
            std::lock_guard<std::mutex> lock(m_cacheMutex);
            m_templateCacheSize = size;
            if (size == 0) {
                m_templateCache.clear();
            }
        }

        void setLocale(const std::string& locale) {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            m_locale = locale;
            m_hasLocale.store(locale != "C" && locale != "POSIX" && !locale.empty(), std::memory_order_release);
        }

        std::string getLocale() const {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            return m_locale;
        }

        /// Set a per-sink locale. The sink's formatter will use this locale
        /// to re-render culture-specific format specifiers, overriding the
        /// logger-level locale for that sink only.
        void setSinkLocale(size_t sinkIndex, const std::string& locale) {
            m_logManager.setSinkLocale(sinkIndex, locale);
        }

        /// Register an enricher that attaches metadata to every log entry.
        /// Enrichers run in registration order before explicit context
        /// (setContext / scoped context), so explicit context wins on
        /// key collisions.
        ///
        /// @throws std::logic_error if called after the first log entry
        ///         has been emitted. All enrichers must be registered
        ///         during logger configuration, before any logging begins.
        void enrich(EnricherFn fn) {
            if (m_logManager.isLoggingStarted()) {
                throw std::logic_error("Cannot add enrichers after logging has started");
            }
            m_enrichers.push_back(std::move(fn));
            m_hasEnrichers.store(true, std::memory_order_release);
        }

    private:
        friend class LoggerConfiguration;

        struct BuilderTag {};
        explicit LunarLog(BuilderTag)
            : m_minLevel(LogLevel::TRACE)
            , m_isRunning(true)
            , m_rateLimitWindowStart(std::chrono::steady_clock::now().time_since_epoch().count())
            , m_logCount(0)
            , m_captureSourceLocation(false)
            , m_hasCustomContext(false)
            , m_sinkWriteInProgress(false)
            , m_templateCacheSize(128)
            , m_hasGlobalFilters(false)
            , m_rateLimitMaxLogs(1000)
            , m_rateLimitWindowMs(1000)
            , m_threadStarted(false) {
        }

        void ensureProcessingThread() {
            if (!m_threadStarted.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> lock(m_queueMutex);
                if (!m_threadStarted.load(std::memory_order_relaxed)) {
                    m_logThread = std::thread(&LunarLog::processLogQueue, this);
                    m_threadStarted.store(true, std::memory_order_release);
                }
            }
        }

        std::atomic<LogLevel> m_minLevel;
        std::atomic<bool> m_isRunning;
        std::atomic<long long> m_rateLimitWindowStart;
        std::atomic<size_t> m_logCount;
        std::mutex m_queueMutex;
        std::mutex m_contextMutex;
        std::condition_variable m_logCV;
        std::condition_variable m_flushCV;
        std::queue<LogEntry> m_logQueue;
        std::thread m_logThread;
        LogManager m_logManager;
        std::map<std::string, std::string> m_customContext;
        std::atomic<bool> m_captureSourceLocation;
        std::atomic<bool> m_hasCustomContext;
        std::atomic<bool> m_sinkWriteInProgress;

        struct PlaceholderInfo {
            std::string name;
            std::string fullContent;
            std::string spec;
            size_t startPos;
            size_t endPos;
            char operator_;  // '@' (destructure), '$' (stringify), or 0 (none)
            std::vector<detail::Transform> transforms;
            int indexedArg;  // >= 0 for indexed ({0},{1},...), -1 for named
            int alignment;   // >0 right-align, <0 left-align, 0 = none
        };

        std::mutex m_cacheMutex;
        std::unordered_map<std::string, std::shared_ptr<const std::vector<PlaceholderInfo>>> m_templateCache;
        size_t m_templateCacheSize;

        std::mutex m_globalFilterMutex;
        std::atomic<bool> m_hasGlobalFilters;
        std::shared_ptr<const FilterPredicate> m_globalFilter;
        std::shared_ptr<const std::vector<FilterRule>> m_globalFilterRules;

        mutable std::mutex m_localeMutex;
        std::atomic<bool> m_hasLocale{false};
        std::string m_locale = "C";

        std::vector<EnricherFn> m_enrichers;
        std::atomic<bool> m_hasEnrichers{false};

        size_t m_rateLimitMaxLogs;
        long long m_rateLimitWindowMs;
        std::atomic<bool> m_threadStarted;

        static std::vector<PlaceholderInfo> extractPlaceholders(const std::string &messageTemplate) {
            std::vector<PlaceholderInfo> placeholders;
            detail::forEachPlaceholder(messageTemplate, [&](const detail::ParsedPlaceholder& ph) {
                placeholders.push_back({ph.name, ph.fullContent, ph.spec, ph.startPos, ph.endPos, ph.op, ph.transforms, ph.indexedArg, ph.alignment});
            });
            return placeholders;
        }

        template<typename... Args>
        void logInternal(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            if (!m_isRunning.load(std::memory_order_acquire)) return;
            if (level < m_minLevel.load(std::memory_order_relaxed)) return;
            if (!rateLimitCheck()) return;

            std::vector<std::string> values{toString(args)...};
            emitLogEntry(level, file, line, function, messageTemplate, values);
        }

        template<typename... Args>
        void logInternalWithException(LogLevel level, const char* file, int line, const char* function,
                                      const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            if (!m_isRunning.load(std::memory_order_acquire)) return;
            if (level < m_minLevel.load(std::memory_order_relaxed)) return;
            if (!rateLimitCheck()) return;

            std::vector<std::string> values{toString(args)...};
            detail::ExceptionInfo exInfo = detail::extractExceptionInfo(ex);
            emitLogEntry(level, file, line, function, messageTemplate, values, exInfo);
        }

        /// Non-exception overload (hot path) — avoids constructing ExceptionInfo.
        void emitLogEntry(LogLevel level, const char* file, int line, const char* function,
                          const std::string &messageTemplate, std::vector<std::string>& values) {
            emitLogEntryImpl(level, file, line, function, messageTemplate, values, nullptr);
        }

        /// Exception overload — attaches ExceptionInfo to the log entry.
        void emitLogEntry(LogLevel level, const char* file, int line, const char* function,
                          const std::string &messageTemplate, std::vector<std::string>& values,
                          detail::ExceptionInfo& exInfo) {
            emitLogEntryImpl(level, file, line, function, messageTemplate, values, &exInfo);
        }

        void emitLogEntryImpl(LogLevel level, const char* file, int line, const char* function,
                              const std::string &messageTemplate, std::vector<std::string>& values,
                              detail::ExceptionInfo* exInfo) {
            auto now = std::chrono::system_clock::now();

            auto tagResult = detail::parseTags(messageTemplate);
            std::vector<std::string> entryTags = std::move(tagResult.first);
            const std::string& effectiveTemplate = entryTags.empty() ? messageTemplate : tagResult.second;

            uint32_t hash = detail::fnv1a(effectiveTemplate);
            std::shared_ptr<const std::vector<PlaceholderInfo>> placeholdersPtr;
            bool cacheHit = false;
            {
                std::lock_guard<std::mutex> cacheLock(m_cacheMutex);
                if (m_templateCacheSize > 0) {
                    auto it = m_templateCache.find(effectiveTemplate);
                    if (it != m_templateCache.end()) {
                        placeholdersPtr = it->second;
                        cacheHit = true;
                    }
                }
            }
            if (!cacheHit) {
                auto parsed = extractPlaceholders(effectiveTemplate);
                placeholdersPtr = std::make_shared<const std::vector<PlaceholderInfo>>(std::move(parsed));
                std::lock_guard<std::mutex> cacheLock(m_cacheMutex);
                if (m_templateCacheSize > 0) {
                    if (m_templateCache.size() < m_templateCacheSize) {
                        m_templateCache[effectiveTemplate] = placeholdersPtr;
                    }
                }
            }

            std::string localeCopy = "C";
            if (m_hasLocale.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> localeLock(m_localeMutex);
                localeCopy = m_locale;
            }

            std::vector<std::string> warnings = validatePlaceholders(effectiveTemplate, *placeholdersPtr, values);
            std::string message = formatMessage(effectiveTemplate, *placeholdersPtr, values, localeCopy);
            auto argumentPairs = mapArgumentsToPlaceholders(*placeholdersPtr, values);
            auto properties = mapProperties(*placeholdersPtr, values);

            bool captureCtx = m_captureSourceLocation.load(std::memory_order_relaxed);
            std::map<std::string, std::string> contextCopy;
            if (m_hasCustomContext.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> contextLock(m_contextMutex);
                contextCopy = m_customContext;
            }

            auto& scopeStack = detail::threadScopeStack();
            if (!scopeStack.empty()) {
                for (const auto& frame : scopeStack) {
                    for (const auto& kv : frame) {
                        contextCopy[kv.first] = kv.second;
                    }
                }
            }

            bool hasEnrichers = m_hasEnrichers.load(std::memory_order_acquire);

            LogEntry entry(
                level, std::move(message), now, effectiveTemplate, hash,
                std::move(argumentPairs),
                captureCtx ? file : "", captureCtx ? line : 0, captureCtx ? function : "",
                std::map<std::string, std::string>(),
                std::move(properties), std::move(entryTags), std::move(localeCopy),
                std::this_thread::get_id()
            );

            if (exInfo) {
                entry.exception = detail::make_unique<detail::ExceptionInfo>(std::move(*exInfo));
            }

            if (hasEnrichers) {
                for (const auto& enricher : m_enrichers) {
                    // Enricher exceptions are swallowed to prevent logging
                    // from crashing the application.
                    try {
                        enricher(entry);
                    } catch (...) {}
                }
                // Explicit context (setContext / scoped) overwrites enricher
                // values — key-by-key merge required for correct precedence.
                for (const auto& kv : contextCopy) {
                    entry.customContext[kv.first] = kv.second;
                }
            } else {
                // Fast path: no enrichers registered — move the entire context
                // map into the entry in O(1) instead of copying key-by-key.
                entry.customContext = std::move(contextCopy);
            }

            ensureProcessingThread();

            std::unique_lock<std::mutex> lock(m_queueMutex);
            m_logQueue.push(std::move(entry));

            for (const auto& warning : warnings) {
                uint32_t warnHash = detail::fnv1a(warning);
                m_logQueue.emplace(LogEntry(
                    /* level */        LogLevel::WARN,
                    /* message */      warning,
                    /* timestamp */    now,
                    /* templateStr */  warning,
                    /* templateHash */ warnHash,
                    /* arguments */    {},
                    /* file */         captureCtx ? file : "",
                    /* line */         captureCtx ? line : 0,
                    /* function */     captureCtx ? function : "",
                    /* customContext */{},
                    /* properties */   {},
                    /* tags */         {},
                    /* locale */       "C",
                    /* threadId */     std::this_thread::get_id()
                ));
            }

            lock.unlock();
            m_logCV.notify_one();
        }

        void snapshotGlobalFilters(
            std::shared_ptr<const FilterPredicate>& filter,
            std::shared_ptr<const std::vector<FilterRule>>& rules) {
            if (m_hasGlobalFilters.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> flock(m_globalFilterMutex);
                filter = m_globalFilter;
                rules  = m_globalFilterRules;
            }
        }

        void processLogQueue() {
            while (m_isRunning) {
                std::unique_lock<std::mutex> lock(m_queueMutex);
                m_logCV.wait(lock, [this] { return !m_logQueue.empty() || !m_isRunning; });

                while (!m_logQueue.empty()) {
                    auto entry = std::move(m_logQueue.front());
                    m_logQueue.pop();
                    m_sinkWriteInProgress.store(true, std::memory_order_relaxed);
                    lock.unlock();

                    try {
                        std::shared_ptr<const FilterPredicate> globalFilter;
                        std::shared_ptr<const std::vector<FilterRule>> globalRules;
                        snapshotGlobalFilters(globalFilter, globalRules);
                        m_logManager.log(entry, globalFilter, globalRules);
                    } catch (...) {}

                    // Re-acquire lock BEFORE clearing sinkWriteInProgress and
                    // notifying, so that flush() cannot miss the state change.
                    // Without this, flush() can check the predicate (seeing
                    // sinkWriteInProgress==true), then we set it to false and
                    // notify, and THEN flush() enters wait — a classic lost wakeup.
                    lock.lock();
                    m_sinkWriteInProgress.store(false, std::memory_order_relaxed);
                    m_flushCV.notify_all();
                }
            }

            {
                std::unique_lock<std::mutex> lock(m_queueMutex);
                while (!m_logQueue.empty()) {
                    auto entry = std::move(m_logQueue.front());
                    m_logQueue.pop();
                    m_sinkWriteInProgress.store(true, std::memory_order_relaxed);
                    lock.unlock();
                    try {
                        std::shared_ptr<const FilterPredicate> globalFilter;
                        std::shared_ptr<const std::vector<FilterRule>> globalRules;
                        snapshotGlobalFilters(globalFilter, globalRules);
                        m_logManager.log(entry, globalFilter, globalRules);
                    } catch (...) {}
                    lock.lock();
                    m_sinkWriteInProgress.store(false, std::memory_order_relaxed);
                    m_flushCV.notify_all();
                }
            }
        }

        // Rate limiting is best-effort under concurrent access.
        //
        // When the window expires, the first thread to win the CAS resets
        // m_rateLimitWindowStart and stores m_logCount to 1 (counting its own
        // message). Concurrent threads that already read the old window but
        // lose the CAS retry and see the new window; their subsequent
        // fetch_add on m_logCount races with the store(1), so a small number
        // of messages at the window boundary may be silently lost or allowed
        // beyond the limit. This is acceptable for a best-effort rate limiter.
        bool rateLimitCheck() {
            auto now = std::chrono::steady_clock::now();
            long long nowNs = now.time_since_epoch().count();
            long long windowStart = m_rateLimitWindowStart.load(std::memory_order_relaxed);

            for (;;) {
                auto durationMs = std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::steady_clock::duration(nowNs - windowStart)).count();
                if (durationMs < m_rateLimitWindowMs) break;
                if (m_rateLimitWindowStart.compare_exchange_weak(windowStart, nowNs,
                        std::memory_order_relaxed, std::memory_order_relaxed)) {
                    // Release so that the new count is visible to threads that
                    // subsequently read it with acquire in fetch_add below.
                    m_logCount.store(1, std::memory_order_release);
                    return true;
                }
            }
            // Acquire pairs with the release-store above: if a window reset just
            // happened, this thread sees the updated count before incrementing.
            size_t count = m_logCount.fetch_add(1, std::memory_order_acquire);
            if (count >= m_rateLimitMaxLogs) {
                return false;
            }
            return true;
        }

        static bool isWhitespaceOnly(const std::string &s) {
            for (size_t i = 0; i < s.size(); ++i) {
                if (!std::isspace(static_cast<unsigned char>(s[i]))) return false;
            }
            return !s.empty();
        }

        static std::vector<std::string> validatePlaceholders(
            const std::string &templateStr,
            const std::vector<PlaceholderInfo> &placeholders,
            const std::vector<std::string> &values) {
            std::vector<std::string> warnings;
            std::set<std::string> uniquePlaceholders;

            for (const auto &ph : placeholders) {
                if (ph.name.empty()) {
                    warnings.push_back("Warning: Template \"" + templateStr + "\" has empty placeholder");
                } else if (isWhitespaceOnly(ph.name)) {
                    warnings.push_back("Warning: Template \"" + templateStr + "\" has whitespace-only placeholder name");
                } else if (ph.indexedArg < 0 && !uniquePlaceholders.insert(ph.name).second) {
                    warnings.push_back("Warning: Template \"" + templateStr + "\" has duplicate placeholder name: " + ph.name);
                }
            }

            std::set<size_t> usedSlots;
            size_t namedOrdinal = 0;
            for (size_t i = 0; i < placeholders.size(); ++i) {
                const auto &ph = placeholders[i];
                size_t slot = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                usedSlots.insert(slot);
            }

            if (usedSlots.size() < values.size()) {
                warnings.push_back("Warning: More values provided than placeholders");
            }

            bool hasMissingSlot = false;
            for (std::set<size_t>::const_iterator it = usedSlots.begin(); it != usedSlots.end(); ++it) {
                if (*it >= values.size()) {
                    hasMissingSlot = true;
                    break;
                }
            }
            if (hasMissingSlot) {
                warnings.push_back("Warning: More placeholders than provided values");
            }

            return warnings;
        }

        template<typename T>
        static std::string toString(const T &value) {
            std::ostringstream oss;
            oss << value;
            return oss.str();
        }

        static std::string toString(const std::string &value) {
            return value;
        }

        static std::string toString(const char *value) {
            if (!value) return "(null)";
            return std::string(value);
        }

        static std::string toString(std::nullptr_t) {
            return "(null)";
        }

        static std::string toString(int value) {
            return std::to_string(value);
        }

        static std::string toString(long value) {
            return std::to_string(value);
        }

        static std::string toString(long long value) {
            return std::to_string(value);
        }

        static std::string toString(unsigned int value) {
            return std::to_string(value);
        }

        static std::string toString(unsigned long value) {
            return std::to_string(value);
        }

        static std::string toString(unsigned long long value) {
            return std::to_string(value);
        }

        static std::string toString(bool value) {
            return value ? "true" : "false";
        }

        static std::string toString(double value) {
            char buf[64];
            std::snprintf(buf, sizeof(buf), "%.15g", value);
            // Locale-safety: some locales use ',' as decimal separator;
            // ensure consistent '.' for downstream parsers (e.g. JSON).
            for (char *p = buf; *p; ++p) { if (*p == ',') *p = '.'; }
            return std::string(buf);
        }

        static std::string toString(float value) {
            char buf[64];
            std::snprintf(buf, sizeof(buf), "%.9g", static_cast<double>(value));
            // Locale-safety: same as toString(double).
            for (char *p = buf; *p; ++p) { if (*p == ',') *p = '.'; }
            return std::string(buf);
        }

        // ----------------------------------------------------------------
        // Format helpers — delegate to detail:: namespace implementations.
        // Kept as private statics for internal use within LunarLog.
        // ----------------------------------------------------------------

        static int safeStoi(const std::string &s, int fallback = 0) {
            return detail::safeStoi(s, fallback);
        }

        static bool tryParseDouble(const std::string &s, double &out) {
            return detail::tryParseDouble(s, out);
        }

        static bool isNumericString(const std::string &s) {
            double ignored;
            return detail::tryParseDouble(s, ignored);
        }

        static double parseDouble(const std::string &s) {
            double val = 0.0;
            detail::tryParseDouble(s, val);
            return val;
        }

        /// Apply a format spec to a value, with locale for culture-specific specs.
        /// Delegates to detail::applyFormat which handles all specs including
        /// culture-specific ones (:n, :N, :d, :D, :t, :T, :f, :F).
        static std::string applyFormat(const std::string &value, const std::string &spec, const std::string &locale = "C") {
            return detail::applyFormat(value, spec, locale);
        }

        static std::pair<std::string, std::string> splitPlaceholder(const std::string &placeholder) {
            return detail::splitPlaceholder(placeholder);
        }

        static std::string formatMessage(const std::string &messageTemplate,
            const std::vector<PlaceholderInfo> &placeholders, const std::vector<std::string> &values,
            const std::string &locale = "C") {
            return detail::walkTemplate(messageTemplate, placeholders, values, locale);
        }

        static std::vector<std::pair<std::string, std::string>> mapArgumentsToPlaceholders(
            const std::vector<PlaceholderInfo> &placeholders, const std::vector<std::string> &values) {
            std::vector<std::pair<std::string, std::string>> argumentPairs;

            size_t namedOrdinal = 0;
            for (size_t i = 0; i < placeholders.size(); ++i) {
                const auto &ph = placeholders[i];
                size_t valueIdx = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                if (valueIdx < values.size()) {
                    argumentPairs.emplace_back(ph.name, values[valueIdx]);
                }
            }

            return argumentPairs;
        }

        /// Map placeholders to PlaceholderProperty entries for structured formatters.
        /// @param placeholders Parsed placeholder metadata (includes operator info).
        /// @param values       Positional argument strings (from toString() conversion).
        /// Properties is the richer representation: it carries operator context (@/$)
        /// that arguments (simple name-value pairs) do not, enabling formatters to
        /// choose type-aware serialization (e.g. JSON native types for @).
        /// @note Properties are populated unconditionally — even when no operators
        ///       are used — so that structured formatters (JSON, XML) always have
        ///       access to placeholder names.  The per-message overhead is a single
        ///       reserve + N moves for typical placeholder counts (< 10), which is
        ///       negligible relative to I/O.
        static std::vector<PlaceholderProperty> mapProperties(
            const std::vector<PlaceholderInfo> &placeholders, const std::vector<std::string> &values) {
            std::vector<PlaceholderProperty> props;
            props.reserve(placeholders.size());
            std::set<std::string> seen;

            size_t namedOrdinal = 0;
            for (size_t i = 0; i < placeholders.size(); ++i) {
                const auto &ph = placeholders[i];
                size_t valueIdx = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                if (valueIdx >= values.size()) continue;
                if (!seen.insert(ph.name).second) continue;
                char effectiveOp = ph.operator_;
                std::vector<std::string> transformSpecs;
                for (size_t ti = 0; ti < ph.transforms.size(); ++ti) {
                    const auto &t = ph.transforms[ti];
                    if (t.name == "expand") effectiveOp = '@';
                    else if (t.name == "str") effectiveOp = '$';
                    if (t.arg.empty()) {
                        transformSpecs.push_back(t.name);
                    } else {
                        transformSpecs.push_back(t.name + ":" + t.arg);
                    }
                }
                props.push_back({ph.name, values[valueIdx], effectiveOp, std::move(transformSpecs)});
            }

            return props;
        }
    };

    /// RAII scoped context that injects key-value pairs into log entries
    /// for the lifetime of the scope.
    ///
    /// NOTE: Scoped context is **thread-wide**, not per-logger instance.
    /// All LunarLog instances on the same thread share the same scope stack.
    /// If you use multiple loggers on one thread, scoped context will appear
    /// in log entries from all of them. This is by design — most applications
    /// use a single logger, and thread-wide scoping avoids the complexity of
    /// passing logger pointers into scope objects.
    class LogScope {
    public:
        LogScope(const LogScope&) = delete;
        LogScope& operator=(const LogScope&) = delete;

        LogScope(LogScope&& other) noexcept
            : m_active(other.m_active), m_iter(other.m_iter) {
            other.m_active = false;
        }

        LogScope& operator=(LogScope&& other) noexcept {
            if (this != &other) {
                if (m_active) {
                    detail::threadScopeStack().erase(m_iter);
                }
                m_active = other.m_active;
                m_iter = other.m_iter;
                other.m_active = false;
            }
            return *this;
        }

        ~LogScope() noexcept {
            if (m_active) {
                detail::threadScopeStack().erase(m_iter);
            }
        }

        /// Append a key-value pair to this scope's frame.
        /// If the same key is added multiple times, the last value wins
        /// (later entries overwrite earlier ones during collection).
        LogScope& add(const std::string& key, const std::string& value) {
            if (m_active) {
                m_iter->emplace_back(key, value);
            }
            return *this;
        }

    private:
        friend class LunarLog;

        explicit LogScope(std::initializer_list<std::pair<std::string, std::string>> pairs)
            : m_active(true) {
            auto& stack = detail::threadScopeStack();
            stack.emplace_back(pairs.begin(), pairs.end());
            m_iter = std::prev(stack.end());
        }

        bool m_active = false;
        detail::ScopeFrameIter m_iter;
    };

    inline LogScope LunarLog::scope(std::initializer_list<std::pair<std::string, std::string>> pairs) {
        return LogScope(pairs);
    }

    class ContextScope {
    public:
        ContextScope(LunarLog& logger, const std::string& key, const std::string& value)
            : m_logger(logger), m_key(key) {
            m_logger.setContext(key, value);
        }

        ~ContextScope() noexcept {
            m_logger.clearContext(m_key);
        }

        ContextScope(const ContextScope &) = delete;
        ContextScope &operator=(const ContextScope &) = delete;
        ContextScope(ContextScope &&) = delete;
        ContextScope &operator=(ContextScope &&) = delete;

    private:
        LunarLog& m_logger;
        std::string m_key;
    };

    inline SinkProxy LunarLog::sink(const std::string& name) {
        size_t idx = m_logManager.getSinkIndex(name);
        return SinkProxy(m_logManager.getSink(idx), m_logManager.isLoggingStarted());
    }

    inline LoggerConfiguration LunarLog::configure() {
        return LoggerConfiguration();
    }

    inline LunarLog LoggerConfiguration::build() {
        if (m_built) {
            throw std::logic_error(
                "LoggerConfiguration::build() already called");
        }
        m_built = true;

        // Create a bare LunarLog — no default console sink, no thread.
        LunarLog logger(LunarLog::BuilderTag{});

        // Apply global settings via friend access.
        logger.m_minLevel.store(m_minLevel, std::memory_order_relaxed);
        logger.m_captureSourceLocation.store(
            m_captureSourceLocation, std::memory_order_relaxed);
        logger.m_rateLimitMaxLogs  = m_rateLimitMaxLogs;
        logger.m_rateLimitWindowMs = m_rateLimitWindowMs;
        logger.setTemplateCacheSize(m_templateCacheSize);

        if (!m_locale.empty()) {
            logger.setLocale(m_locale);
        }

        // Register enrichers (must happen before first log entry).
        for (size_t i = 0; i < m_enrichers.size(); ++i) {
            logger.enrich(std::move(m_enrichers[i]));
        }

        // Add compact filter expressions.
        for (size_t i = 0; i < m_filterCompact.size(); ++i) {
            logger.filter(m_filterCompact[i]);
        }

        // Add DSL filter rules.
        for (size_t i = 0; i < m_filterRules.size(); ++i) {
            logger.addFilterRule(m_filterRules[i]);
        }

        // Add sinks.
        if (m_sinks.empty()) {
            std::fprintf(stderr, "[LunarLog] Warning: build() called with no "
                                 "sinks — logger will silently discard all "
                                 "messages.\n");
        }
        for (size_t i = 0; i < m_sinks.size(); ++i) {
            if (m_sinks[i].hasName) {
                logger.addCustomSink(m_sinks[i].name,
                                     std::move(m_sinks[i].sink));
            } else {
                logger.addCustomSink(std::move(m_sinks[i].sink));
            }
        }

        // Start the background processing thread.
        logger.ensureProcessingThread();

        // Safe to return by move: LunarLog's move constructor transfers all
        // internal state (queue, sinks, atomics, enrichers, filters).  The
        // processing thread has not yet received any log entries at this point
        // because ensureProcessingThread() only starts the thread — it does
        // not produce entries.  The moved-from instance is left in a valid
        // but empty state (m_isRunning == false).
        return logger;
    }

} // namespace minta


// --- lunar_log/macros.hpp ---

#ifndef LUNAR_LOG_NO_MACROS

// Generic macro --- level check avoids argument evaluation when disabled
#define LUNAR_LOG(logger, level, ...) \
    do { \
        auto& lunar_log_ref_ = (logger); \
        auto  lunar_log_lvl_ = (level); \
        if (lunar_log_lvl_ >= lunar_log_ref_.getMinLevel()) { \
            lunar_log_ref_.logWithSourceLocation( \
                lunar_log_lvl_, __FILE__, __LINE__, \
                __func__, \
                __VA_ARGS__); \
        } \
    } while (0)

#define LUNAR_TRACE(logger, ...) LUNAR_LOG((logger), ::minta::LogLevel::TRACE, __VA_ARGS__)
#define LUNAR_DEBUG(logger, ...) LUNAR_LOG((logger), ::minta::LogLevel::DEBUG, __VA_ARGS__)
#define LUNAR_INFO(logger, ...)  LUNAR_LOG((logger), ::minta::LogLevel::INFO,  __VA_ARGS__)
#define LUNAR_WARN(logger, ...)  LUNAR_LOG((logger), ::minta::LogLevel::WARN,  __VA_ARGS__)
#define LUNAR_ERROR(logger, ...) LUNAR_LOG((logger), ::minta::LogLevel::ERROR, __VA_ARGS__)
#define LUNAR_FATAL(logger, ...) LUNAR_LOG((logger), ::minta::LogLevel::FATAL, __VA_ARGS__)

// Exception variants
#define LUNAR_LOG_EX(logger, level, ex, ...) \
    do { \
        auto& lunar_log_ref_ = (logger); \
        auto  lunar_log_lvl_ = (level); \
        if (lunar_log_lvl_ >= lunar_log_ref_.getMinLevel()) { \
            lunar_log_ref_.logWithSourceLocationAndException( \
                lunar_log_lvl_, __FILE__, __LINE__, \
                __func__, \
                (ex), __VA_ARGS__); \
        } \
    } while (0)

#define LUNAR_TRACE_EX(logger, ex, ...) LUNAR_LOG_EX((logger), ::minta::LogLevel::TRACE, (ex), __VA_ARGS__)
#define LUNAR_DEBUG_EX(logger, ex, ...) LUNAR_LOG_EX((logger), ::minta::LogLevel::DEBUG, (ex), __VA_ARGS__)
#define LUNAR_INFO_EX(logger, ex, ...)  LUNAR_LOG_EX((logger), ::minta::LogLevel::INFO,  (ex), __VA_ARGS__)
#define LUNAR_WARN_EX(logger, ex, ...)  LUNAR_LOG_EX((logger), ::minta::LogLevel::WARN,  (ex), __VA_ARGS__)
#define LUNAR_ERROR_EX(logger, ex, ...) LUNAR_LOG_EX((logger), ::minta::LogLevel::ERROR, (ex), __VA_ARGS__)
#define LUNAR_FATAL_EX(logger, ex, ...) LUNAR_LOG_EX((logger), ::minta::LogLevel::FATAL, (ex), __VA_ARGS__)

#endif // LUNAR_LOG_NO_MACROS


#define LUNAR_LOG_CONTEXT __FILE__, __LINE__, __func__

#endif // LUNAR_LOG_SINGLE_HEADER_HPP
