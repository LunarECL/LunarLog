// LunarLog - Single Header
// https://github.com/LunarECL/LunarLog
// Auto-generated by tools/generate_single_header.py
//
// Usage: just include this file.

#ifndef LUNAR_LOG_SINGLE_HEADER_HPP
#define LUNAR_LOG_SINGLE_HEADER_HPP

// --- lunar_log/core/log_level.hpp ---

// Windows.h defines ERROR as 0, which conflicts with the ERROR enum member.
// Undefine it here so LogLevel::ERROR is always usable regardless of include order.
#ifdef ERROR
#undef ERROR
#endif

namespace minta {
    enum class LogLevel {
        TRACE,
        DEBUG,
        INFO,
        WARN,
        ERROR,
        FATAL
    };

    inline const char *getLevelString(LogLevel level) {
        switch (level) {
            case LogLevel::TRACE: return "TRACE";
            case LogLevel::DEBUG: return "DEBUG";
            case LogLevel::INFO: return "INFO";
            case LogLevel::WARN: return "WARN";
            case LogLevel::ERROR: return "ERROR";
            case LogLevel::FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }
} // namespace minta


// --- lunar_log/core/log_common.hpp ---

#include <string>
#include <chrono>
#include <ctime>
#include <cstdio>
#include <cstdint>
#include <memory>
#include <sstream>
#include <iomanip>
#include <locale>
#include <cstdlib>
#include <cerrno>
#include <cmath>
#include <climits>
#include <vector>
#include <unordered_map>
#include <utility>


namespace minta {
namespace detail {
    template<typename T, typename... Args>
    inline std::unique_ptr<T> make_unique(Args&&... args) {
#if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
        return std::make_unique<T>(std::forward<Args>(args)...);
#else
        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
#endif
    }

    /// FNV-1a hash (32-bit) for template grouping.
    inline uint32_t fnv1a(const std::string &s) {
        uint32_t hash = 0x811c9dc5u;
        for (size_t i = 0; i < s.size(); ++i) {
            hash ^= static_cast<uint32_t>(static_cast<unsigned char>(s[i]));
            hash *= 0x01000193u;
        }
        return hash;
    }

    /// Format a uint32_t as an 8-char lowercase hex string.
    inline std::string toHexString(uint32_t value) {
        char buf[9];
        std::snprintf(buf, sizeof(buf), "%08x", value);
        return std::string(buf);
    }

    inline std::string formatTimestamp(const std::chrono::system_clock::time_point &time) {
        auto nowTime = std::chrono::system_clock::to_time_t(time);
        auto nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(time.time_since_epoch()) % 1000;

        std::tm tmBuf;
#if defined(_MSC_VER)
        localtime_s(&tmBuf, &nowTime);
#else
        localtime_r(&nowTime, &tmBuf);
#endif

        char buf[32];
        size_t pos = std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &tmBuf);
        if (pos == 0) {
            buf[0] = '\0';
        }
        // Defensive: ensure non-negative milliseconds for pre-epoch time points
        std::snprintf(buf + pos, sizeof(buf) - pos, ".%03d", static_cast<int>((nowMs.count() + 1000) % 1000));
        return std::string(buf);
    }
    // ----------------------------------------------------------------
    // Format helpers (shared by LunarLog and detail::reformatMessage)
    // ----------------------------------------------------------------

    /// Safely parse an integer from a string. Returns fallback on failure.
    inline int safeStoi(const std::string &s, int fallback = 0) {
        if (s.empty()) return fallback;
        for (size_t i = 0; i < s.size(); ++i) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) return fallback;
        }
        try { return std::stoi(s); } catch (...) { return fallback; }
    }

    /// Parse non-negative integer index safely with overflow clamping.
    /// Returns false if the input is empty or contains non-digits.
    inline bool tryParseIndex(const std::string &s, int &out) {
        if (s.empty()) return false;
        unsigned long long v = 0;
        for (size_t i = 0; i < s.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(s[i]);
            if (!std::isdigit(c)) return false;
            unsigned int digit = static_cast<unsigned int>(c - '0');
            if (v > (static_cast<unsigned long long>(INT_MAX) - digit) / 10ULL) {
                out = INT_MAX;
                return true;
            }
            v = v * 10ULL + digit;
        }
        out = static_cast<int>(v);
        return true;
    }

    /// Try to parse a string as a double. Returns true on success and sets out.
    inline bool tryParseDouble(const std::string &s, double &out) {
        if (s.empty()) return false;
        const char* start = s.c_str();
        char* end = nullptr;
        errno = 0;
        double val = std::strtod(start, &end);
        if (errno == ERANGE || end == start || static_cast<size_t>(end - start) != s.size()) {
            errno = 0;
            return false;
        }
        errno = 0;
        if (std::isinf(val) || std::isnan(val)) return false;
        out = val;
        return true;
    }

    inline double clampForLongLong(double val) {
        if (val != val) return 0.0;
        static const double kMinLL = static_cast<double>(LLONG_MIN + 1);
        static const double kMaxLL = std::nextafter(static_cast<double>(LLONG_MAX), 0.0);
        if (val < kMinLL) return kMinLL;
        if (val > kMaxLL) return kMaxLL;
        return val;
    }

    /// Format a double into a string using the given printf format.
    inline std::string snprintfDouble(const char* fmt, double val) {
        int needed = std::snprintf(nullptr, 0, fmt, val);
        if (needed < 0) return std::string();
        if (static_cast<size_t>(needed) < 256) {
            char stackBuf[256];
            std::snprintf(stackBuf, sizeof(stackBuf), fmt, val);
            return std::string(stackBuf);
        }
        std::vector<char> heapBuf(static_cast<size_t>(needed) + 1);
        std::snprintf(heapBuf.data(), heapBuf.size(), fmt, val);
        return std::string(heapBuf.data());
    }

    /// Format a double with precision.
    inline std::string snprintfDoublePrecision(const char* fmt, int precision, double val) {
        int needed = std::snprintf(nullptr, 0, fmt, precision, val);
        if (needed < 0) return std::string();
        if (static_cast<size_t>(needed) < 256) {
            char stackBuf[256];
            std::snprintf(stackBuf, sizeof(stackBuf), fmt, precision, val);
            return std::string(stackBuf);
        }
        std::vector<char> heapBuf(static_cast<size_t>(needed) + 1);
        std::snprintf(heapBuf.data(), heapBuf.size(), fmt, precision, val);
        return std::string(heapBuf.data());
    }

    /// Split "name:spec" into (name, spec). Returns (placeholder, "") if no colon.
    inline std::pair<std::string, std::string> splitPlaceholder(const std::string &placeholder) {
        size_t colonPos = placeholder.rfind(':');
        if (colonPos == std::string::npos) {
            return std::make_pair(placeholder, std::string());
        }
        return std::make_pair(placeholder.substr(0, colonPos), placeholder.substr(colonPos + 1));
    }

    // ----------------------------------------------------------------
    // Culture-specific formatting utilities
    // ----------------------------------------------------------------

    inline std::locale tryCreateLocale(const std::string& name) {
        if (name.empty() || name == "C" || name == "POSIX") {
            return std::locale::classic();
        }
        // Thread-local multi-entry cache: handles the realistic multi-sink
        // case (3-4 locales) without thrashing. Capped at 8 entries to
        // prevent unbounded growth from programmatic locale creation.
        thread_local std::unordered_map<std::string, std::locale> cache;
        auto it = cache.find(name);
        if (it != cache.end()) {
            return it->second;
        }
        std::locale result = std::locale::classic();
        try {
            result = std::locale(name);
        } catch (...) {
            if (name.find('.') == std::string::npos) {
                try {
                    result = std::locale(name + ".UTF-8");
                } catch (...) {}
            }
        }
        if (cache.size() < 8) {
            cache.emplace(name, result);
        }
        return result;
    }

    /// Format a number with locale-specific thousand/decimal separators.
    /// Used by the :n and :N format specs.
    inline std::string formatCultureNumber(const std::string& value, const std::string& localeName) {
        double numVal;
        if (!tryParseDouble(value, numVal)) return value;

        std::locale loc = tryCreateLocale(localeName);
        std::ostringstream oss;
        oss.imbue(loc);

        bool hasSciNotation = (value.find('e') != std::string::npos ||
                               value.find('E') != std::string::npos);
        if (hasSciNotation) {
            oss << std::fixed << std::setprecision(6) << numVal;
        } else {
            size_t dotPos = value.find('.');
            int precision = 0;
            if (dotPos != std::string::npos) {
                precision = static_cast<int>(value.size() - dotPos - 1);
                if (precision > 15) precision = 15;
            }
            oss << std::fixed << std::setprecision(precision) << numVal;
        }
        return oss.str();
    }

    /// Format a unix timestamp as a locale-aware date/time string.
    /// Used by the :d, :D, :t, :T, :f, :F format specs.
    inline std::string formatCultureDateTime(const std::string& value, char spec, const std::string& localeName) {
        double tsVal;
        if (!tryParseDouble(value, tsVal)) return value;

        time_t t = static_cast<time_t>(tsVal);
        std::tm tmBuf;
#if defined(_MSC_VER)
        localtime_s(&tmBuf, &t);
#else
        localtime_r(&t, &tmBuf);
#endif

        const char* fmt = nullptr;
        switch (spec) {
            case 'd': fmt = "%x"; break;                           // short date
            case 'D': fmt = "%A, %B %d, %Y"; break;               // long date
            case 't': fmt = "%H:%M"; break;                        // short time
            case 'T': fmt = "%H:%M:%S"; break;                     // long time
            case 'f': fmt = "%A, %B %d, %Y %H:%M"; break;         // full date + short time
            case 'F': fmt = "%A, %B %d, %Y %H:%M:%S"; break;      // full date + long time
            default: return value;
        }

        std::locale loc = tryCreateLocale(localeName);
        std::ostringstream oss;
        oss.imbue(loc);
        oss << std::put_time(&tmBuf, fmt);
        std::string result = oss.str();
        return result.empty() ? value : result;
    }

    // ----------------------------------------------------------------
    // Complete format spec application with locale support
    // ----------------------------------------------------------------

    /// Apply a format spec to a string value, with optional locale for culture specs.
    /// Handles all existing specs (.Nf, Nf, C, X, E, P, 0N) plus culture specs (n, N, d, D, t, T, f, F).
    inline std::string applyFormat(const std::string &value, const std::string &spec, const std::string &locale = "C") {
        if (spec.empty()) return value;

        double numVal;

        // Culture-specific: locale-aware number (n / N)
        if (spec == "n" || spec == "N") {
            return formatCultureNumber(value, locale);
        }

        // Culture-specific: date/time (d, D, t, T, f, F)
        if (spec.size() == 1) {
            char c = spec[0];
            if (c == 'd' || c == 'D' || c == 't' || c == 'T' || c == 'f' || c == 'F') {
                return formatCultureDateTime(value, c, locale);
            }
        }

        // Fixed-point: .Nf (e.g. ".2f", ".4f")
        if (spec.size() >= 2 && spec[0] == '.' && spec.back() == 'f') {
            if (!tryParseDouble(value, numVal)) return value;
            std::string digits = spec.substr(1, spec.size() - 2);
            int precision = safeStoi(digits, 6);
            if (precision > 50) precision = 50;
            return snprintfDoublePrecision("%.*f", precision, numVal);
        }

        // Fixed-point shorthand: Nf (e.g. "2f", "4f")
        if (spec.size() >= 2 && spec.back() == 'f' && std::isdigit(static_cast<unsigned char>(spec[0]))) {
            if (!tryParseDouble(value, numVal)) return value;
            int precision = safeStoi(spec.substr(0, spec.size() - 1), 6);
            if (precision > 50) precision = 50;
            return snprintfDoublePrecision("%.*f", precision, numVal);
        }

        // Currency: C or c
        if (spec == "C" || spec == "c") {
            if (!tryParseDouble(value, numVal)) return value;
            if (numVal < 0) {
                std::string formatted = snprintfDouble("%.2f", -numVal);
                if (formatted == "0.00") return "$0.00";
                return "-$" + formatted;
            } else {
                std::string formatted = snprintfDouble("%.2f", numVal);
                return "$" + formatted;
            }
        }

        // Hex: X (upper) or x (lower)
        if (spec == "X" || spec == "x") {
            if (!tryParseDouble(value, numVal)) return value;
            char buf[64];
            numVal = clampForLongLong(numVal);
            long long intVal = static_cast<long long>(numVal);
            unsigned long long uval;
            std::string result;
            if (intVal < 0) {
                result = "-";
                uval = 0ULL - static_cast<unsigned long long>(intVal);
            } else {
                uval = static_cast<unsigned long long>(intVal);
            }
            if (spec == "X") {
                std::snprintf(buf, sizeof(buf), "%llX", uval);
            } else {
                std::snprintf(buf, sizeof(buf), "%llx", uval);
            }
            result += buf;
            return result;
        }

        // Scientific: E (upper) or e (lower)
        if (spec == "E" || spec == "e") {
            if (!tryParseDouble(value, numVal)) return value;
            char buf[64];
            if (spec == "E") {
                std::snprintf(buf, sizeof(buf), "%E", numVal);
            } else {
                std::snprintf(buf, sizeof(buf), "%e", numVal);
            }
            return std::string(buf);
        }

        // Percentage: P or p
        if (spec == "P" || spec == "p") {
            if (!tryParseDouble(value, numVal)) return value;
            double pct = numVal * 100.0;
            if (!std::isfinite(pct)) pct = numVal;
            return snprintfDouble("%.2f", pct) + "%";
        }

        // Zero-padded integer: 0N (e.g. "04", "08")
        if (spec.size() >= 2 && spec[0] == '0' && std::isdigit(static_cast<unsigned char>(spec[1]))) {
            if (!tryParseDouble(value, numVal)) return value;
            char buf[64];
            numVal = clampForLongLong(numVal);
            int width = safeStoi(spec.substr(1), 1);
            if (width > 50) width = 50;
            long long intVal = static_cast<long long>(numVal);
            if (intVal < 0) {
                unsigned long long absVal = 0ULL - static_cast<unsigned long long>(intVal);
                std::snprintf(buf, sizeof(buf), "-%0*llu", width, absVal);
            } else {
                std::snprintf(buf, sizeof(buf), "%0*lld", width, intVal);
            }
            return std::string(buf);
        }

        // Unknown spec — return value as-is
        return value;
    }

    // ----------------------------------------------------------------
    // Shared placeholder iterator — single source of truth for
    // operator stripping, validation, and name/spec splitting.
    // ----------------------------------------------------------------

    /// Return true when every character in @p name is an ASCII digit.
    /// Used to distinguish indexed placeholders ({0}, {1}) from named ones ({user}).
    inline bool isIndexedPlaceholder(const std::string &name) {
        if (name.empty()) return false;
        for (size_t i = 0; i < name.size(); ++i) {
            if (!std::isdigit(static_cast<unsigned char>(name[i]))) return false;
        }
        return true;
    }

    struct ParsedPlaceholder {
        size_t startPos;
        size_t endPos;
        std::string name;
        std::string fullContent;
        std::string spec;
        char op;  // '@', '$', or 0
        std::vector<Transform> transforms;
        int indexedArg;  // >= 0 for indexed ({0},{1},...), -1 for named
        int alignment;   // >0 right-align, <0 left-align, 0 = none
    };

    /// Maximum alignment width to prevent excessive memory allocation.
    /// Placeholders like {name,999999999} are clamped to this value.
    static const int MAX_ALIGNMENT_WIDTH = 1024;

    inline int parseAlignment(const std::string &s) {
        if (s.empty()) return 0;
        size_t start = 0;
        if (s[0] == '-') start = 1;
        if (start >= s.size()) return 0;
        for (size_t i = start; i < s.size(); ++i) {
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) return 0;
        }
        try {
            int val = std::stoi(s);
            // Clamp to reasonable range to prevent excessive allocations
            if (val > MAX_ALIGNMENT_WIDTH) val = MAX_ALIGNMENT_WIDTH;
            if (val < -MAX_ALIGNMENT_WIDTH) val = -MAX_ALIGNMENT_WIDTH;
            return val;
        } catch (...) { return 0; }
    }

    inline std::string applyAlignment(const std::string &value, int alignment) {
        if (alignment == 0) return value;
        // Guard against INT_MIN: negating INT_MIN is undefined behavior
        // (signed integer overflow). Treat as max right-alignment.
        if (alignment == INT_MIN) alignment = -INT_MAX;
        size_t width = static_cast<size_t>(alignment < 0 ? -alignment : alignment);
        // Clamp width to prevent excessive memory allocation (defense-in-depth;
        // parseAlignment already clamps, but alignment may originate elsewhere).
        if (width > static_cast<size_t>(MAX_ALIGNMENT_WIDTH))
            width = static_cast<size_t>(MAX_ALIGNMENT_WIDTH);
        size_t charCount = utf8CharCount(value);
        if (charCount >= width) return value;
        size_t padding = width - charCount;
        if (alignment > 0) {
            return std::string(padding, ' ') + value;
        } else {
            return value + std::string(padding, ' ');
        }
    }

    inline size_t resolveValueSlot(int indexedArg, size_t namedOrdinal) {
        return indexedArg >= 0
            ? static_cast<size_t>(indexedArg)
            : namedOrdinal;
    }

    template<typename Callback>
    inline void forEachPlaceholder(const std::string &templateStr, Callback callback) {
        for (size_t i = 0; i < templateStr.length(); ++i) {
            if (templateStr[i] == '{') {
                if (i + 1 < templateStr.length() && templateStr[i + 1] == '{') {
                    ++i;
                    continue;
                }
                size_t endPos = templateStr.find('}', i);
                if (endPos == std::string::npos) break;
                std::string content = templateStr.substr(i + 1, endPos - i - 1);
                char op = 0;
                std::string nameContent = content;
                if (!content.empty() && (content[0] == '@' || content[0] == '$')) {
                    op = content[0];
                    nameContent = content.substr(1);
                    if (nameContent.empty() || nameContent[0] == '@' || nameContent[0] == '$'
                        || !(std::isalnum(static_cast<unsigned char>(nameContent[0])) || nameContent[0] == '_')) {
                        i = endPos;
                        continue;
                    }
                }
                std::string nameSpec = nameContent;
                std::vector<Transform> transforms;
                size_t pipePos = nameContent.find('|');
                if (pipePos != std::string::npos) {
                    nameSpec = nameContent.substr(0, pipePos);
                    transforms = parseTransforms(nameContent.substr(pipePos + 1));
                }
                auto parts = splitPlaceholder(nameSpec);
                int alignment = 0;
                std::string cleanName = parts.first;
                size_t commaPos = cleanName.find(',');
                if (commaPos != std::string::npos) {
                    alignment = parseAlignment(cleanName.substr(commaPos + 1));
                    cleanName.resize(commaPos);
                }
                int idxArg = -1;
                if (isIndexedPlaceholder(cleanName)) {
                    int parsed = -1;
                    if (tryParseIndex(cleanName, parsed)) idxArg = parsed;
                }
                callback(ParsedPlaceholder{i, endPos, cleanName, content, parts.second, op, std::move(transforms), idxArg, alignment});
                i = endPos;
            } else if (templateStr[i] == '}') {
                if (i + 1 < templateStr.length() && templateStr[i + 1] == '}') {
                    ++i;
                }
            }
        }
    }

    // ----------------------------------------------------------------
    // Shared template walker — single source of truth for the
    // template-walk algorithm used by both reformatMessage and
    // LunarLog::formatMessage.  Parameterized on placeholder type
    // (works with ParsedPlaceholder and LunarLog::PlaceholderInfo;
    // both expose startPos, endPos, spec).
    // ----------------------------------------------------------------

    template<typename PlaceholderType>
    inline std::string walkTemplate(const std::string &templateStr,
                                    const std::vector<PlaceholderType> &placeholders,
                                    const std::vector<std::string> &values,
                                    const std::string &locale) {
        std::string result;
        result.reserve(templateStr.length());
        size_t phIdx = 0;
        size_t pos = 0;
        size_t namedOrdinal = 0;

        while (pos < templateStr.length()) {
            if (phIdx < placeholders.size() && pos == placeholders[phIdx].startPos) {
                size_t valueIdx = resolveValueSlot(placeholders[phIdx].indexedArg, namedOrdinal);
                if (placeholders[phIdx].indexedArg < 0) {
                    ++namedOrdinal;
                }
                if (valueIdx < values.size()) {
                    std::string formatted = applyFormat(values[valueIdx], placeholders[phIdx].spec, locale);
                    if (!placeholders[phIdx].transforms.empty()) {
                        formatted = applyTransforms(formatted, placeholders[phIdx].transforms);
                    }
                    if (placeholders[phIdx].alignment != 0) {
                        formatted = applyAlignment(formatted, placeholders[phIdx].alignment);
                    }
                    result += formatted;
                } else if (placeholders[phIdx].indexedArg >= 0) {
                    // Indexed out-of-range renders as empty string
                } else {
                    result.append(templateStr, pos, placeholders[phIdx].endPos - pos + 1);
                }
                pos = placeholders[phIdx].endPos + 1;
                ++phIdx;
            } else if (templateStr[pos] == '{' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '{') {
                result += '{';
                pos += 2;
            } else if (templateStr[pos] == '}' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '}') {
                result += '}';
                pos += 2;
            } else {
                size_t litStart = pos;
                ++pos;
                while (pos < templateStr.length()) {
                    if (phIdx < placeholders.size() && pos == placeholders[phIdx].startPos) break;
                    if (templateStr[pos] == '{' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '{') break;
                    if (templateStr[pos] == '}' && pos + 1 < templateStr.length() && templateStr[pos + 1] == '}') break;
                    ++pos;
                }
                result.append(templateStr, litStart, pos - litStart);
            }
        }
        return result;
    }

    // ----------------------------------------------------------------
    // Message re-rendering with a different locale
    // ----------------------------------------------------------------

    inline std::string reformatMessage(const std::string &templateStr,
                                       const std::vector<std::string> &values,
                                       const std::string &locale) {
        std::vector<ParsedPlaceholder> spans;
        forEachPlaceholder(templateStr, [&](const ParsedPlaceholder& ph) {
            spans.push_back(ph);
        });
        return walkTemplate(templateStr, spans, values, locale);
    }

} // namespace detail
} // namespace minta


// --- lunar_log/core/log_entry.hpp ---

#include <string>
#include <chrono>
#include <cstdint>
#include <vector>
#include <map>
#include <thread>

namespace minta {
    struct PlaceholderProperty {
        std::string name;
        std::string value;
        char op;  // '@' (destructure), '$' (stringify), or 0 (none)
        std::vector<std::string> transforms;
    };

    struct LogEntry {
        LogLevel level = LogLevel::INFO;
        std::string message;
        std::chrono::system_clock::time_point timestamp;
        std::string templateStr;
        uint32_t templateHash = 0;
        std::vector<std::pair<std::string, std::string>> arguments;
        std::string file;
        int line = 0;
        std::string function;
        std::map<std::string, std::string> customContext;
        std::vector<PlaceholderProperty> properties;
        std::vector<std::string> tags;
        std::string locale = "C";
        std::thread::id threadId;
        std::string exceptionType;
        std::string exceptionMessage;
        std::string exceptionChain;

        LogEntry() = default;

        /// Backward-compatible positional constructor for custom formatters.
        LogEntry(LogLevel level_, std::string message_, std::chrono::system_clock::time_point timestamp_,
                 std::string templateStr_, uint32_t templateHash_,
                 std::vector<std::pair<std::string, std::string>> arguments_,
                 std::string file_, int line_, std::string function_,
                 std::map<std::string, std::string> customContext_,
                 std::vector<PlaceholderProperty> properties_,
                 std::vector<std::string> tags_ = {},
                 std::string locale_ = "C",
                 std::thread::id threadId_ = std::thread::id(),
                 std::string exceptionType_ = "",
                 std::string exceptionMessage_ = "",
                 std::string exceptionChain_ = "")
            : level(level_), message(std::move(message_)), timestamp(timestamp_),
              templateStr(std::move(templateStr_)), templateHash(templateHash_),
              arguments(std::move(arguments_)),
              file(std::move(file_)), line(line_), function(std::move(function_)),
              customContext(std::move(customContext_)), properties(std::move(properties_)),
              tags(std::move(tags_)),
              locale(std::move(locale_)),
              threadId(threadId_),
              exceptionType(std::move(exceptionType_)),
              exceptionMessage(std::move(exceptionMessage_)),
              exceptionChain(std::move(exceptionChain_)) {}
    };
} // namespace minta


// --- lunar_log/core/filter_rule.hpp ---

#include <string>
#include <stdexcept>

namespace minta {

    /// A single DSL filter rule parsed from a string.
    ///
    /// Supported syntax:
    ///   level >= LEVEL  /  level == LEVEL  /  level != LEVEL
    ///   message contains 'text'
    ///   message startswith 'text'
    ///   context has 'key'
    ///   context key == 'value'
    ///   template == 'exact template'
    ///   template contains 'partial'
    ///   not <rule>
    ///
    /// Multiple rules are AND-combined externally (each must return true).
    class FilterRule {
    public:
        /// Parse a rule string into a FilterRule.
        /// Throws std::invalid_argument on unrecognized syntax.
        ///
        /// String values are delimited by outer single quotes with no escape
        /// sequences. Embedded quotes work by accident (outermost pair is
        /// stripped). There is no way to match a value that both starts and
        /// ends with a single quote.
        static FilterRule parse(const std::string& rule) {
            std::string trimmed = trim(rule);
            if (trimmed.empty()) {
                throw std::invalid_argument("Empty filter rule");
            }

            bool negated = false;
            if (startsWith(trimmed, "not ")) {
                negated = true;
                trimmed = trim(trimmed.substr(4));
                if (trimmed.empty()) {
                    throw std::invalid_argument("Empty rule after 'not'");
                }
            }

            FilterRule r;
            r.m_negated = negated;

            // level >= LEVEL  /  level == LEVEL  /  level != LEVEL
            if (startsWith(trimmed, "level ")) {
                std::string rest = trim(trimmed.substr(6));
                if (startsWith(rest, ">= ")) {
                    r.m_type = RuleType::LevelGe;
                    r.m_level = parseLevel(trim(rest.substr(3)));
                } else if (startsWith(rest, "== ")) {
                    r.m_type = RuleType::LevelEq;
                    r.m_level = parseLevel(trim(rest.substr(3)));
                } else if (startsWith(rest, "!= ")) {
                    r.m_type = RuleType::LevelNe;
                    r.m_level = parseLevel(trim(rest.substr(3)));
                } else {
                    throw std::invalid_argument("Invalid level operator in rule: " + rule);
                }
                return r;
            }

            // message contains 'text'  /  message startswith 'text'
            if (startsWith(trimmed, "message ")) {
                std::string rest = trim(trimmed.substr(8));
                if (startsWith(rest, "contains ")) {
                    r.m_type = RuleType::MessageContains;
                    r.m_value = extractQuoted(trim(rest.substr(9)), rule);
                } else if (startsWith(rest, "startswith ")) {
                    r.m_type = RuleType::MessageStartsWith;
                    r.m_value = extractQuoted(trim(rest.substr(11)), rule);
                } else {
                    throw std::invalid_argument("Invalid message operator in rule: " + rule);
                }
                return r;
            }

            // context has 'key'  /  context key == 'value'
            // NOTE: Context keys containing spaces are not supported.
            // The parser splits on whitespace, so "context my key == 'val'"
            // would be misinterpreted.
            if (startsWith(trimmed, "context ")) {
                std::string rest = trim(trimmed.substr(8));
                if (startsWith(rest, "has ")) {
                    r.m_type = RuleType::ContextHas;
                    r.m_value = extractQuoted(trim(rest.substr(4)), rule);
                } else {
                    size_t spacePos = rest.find(' ');
                    if (spacePos == std::string::npos) {
                        throw std::invalid_argument("Invalid context rule: " + rule);
                    }
                    std::string key = rest.substr(0, spacePos);
                    std::string afterKey = trim(rest.substr(spacePos + 1));
                    if (startsWith(afterKey, "== ")) {
                        r.m_type = RuleType::ContextKeyEq;
                        r.m_key = key;
                        r.m_value = extractQuoted(trim(afterKey.substr(3)), rule);
                    } else {
                        throw std::invalid_argument("Invalid context operator in rule: " + rule);
                    }
                }
                return r;
            }

            // template == 'exact template'  /  template contains 'partial'
            if (startsWith(trimmed, "template ")) {
                std::string rest = trim(trimmed.substr(9));
                if (startsWith(rest, "== ")) {
                    r.m_type = RuleType::TemplateEq;
                    r.m_value = extractQuoted(trim(rest.substr(3)), rule);
                } else if (startsWith(rest, "contains ")) {
                    r.m_type = RuleType::TemplateContains;
                    r.m_value = extractQuoted(trim(rest.substr(9)), rule);
                } else {
                    throw std::invalid_argument("Invalid template operator in rule: " + rule);
                }
                return r;
            }

            throw std::invalid_argument("Unrecognized filter rule: " + rule);
        }

        /// Evaluate this rule against a log entry.
        /// Returns true if the entry passes (should be kept).
        bool evaluate(const LogEntry& entry) const {
            bool result = false;
            switch (m_type) {
                case RuleType::LevelGe:
                    result = entry.level >= m_level;
                    break;
                case RuleType::LevelEq:
                    result = entry.level == m_level;
                    break;
                case RuleType::LevelNe:
                    result = entry.level != m_level;
                    break;
                case RuleType::MessageContains:
                    result = entry.message.find(m_value) != std::string::npos;
                    break;
                case RuleType::MessageStartsWith:
                    result = entry.message.size() >= m_value.size() &&
                             entry.message.compare(0, m_value.size(), m_value) == 0;
                    break;
                case RuleType::ContextHas:
                    result = entry.customContext.count(m_value) > 0;
                    break;
                case RuleType::ContextKeyEq:
                    {
                        auto it = entry.customContext.find(m_key);
                        result = it != entry.customContext.end() && it->second == m_value;
                    }
                    break;
                case RuleType::TemplateEq:
                    result = entry.templateStr == m_value;
                    break;
                case RuleType::TemplateContains:
                    result = entry.templateStr.find(m_value) != std::string::npos;
                    break;
            }
            return m_negated ? !result : result;
        }

    private:
        enum class RuleType {
            LevelGe,
            LevelEq,
            LevelNe,
            MessageContains,
            MessageStartsWith,
            ContextHas,
            ContextKeyEq,
            TemplateEq,
            TemplateContains
        };

        RuleType m_type;
        bool m_negated;
        LogLevel m_level;
        std::string m_value;
        std::string m_key;

        FilterRule() : m_type(RuleType::LevelGe), m_negated(false), m_level(LogLevel::TRACE) {}

        static LogLevel parseLevel(const std::string& s) {
            if (s == "TRACE") return LogLevel::TRACE;
            if (s == "DEBUG") return LogLevel::DEBUG;
            if (s == "INFO")  return LogLevel::INFO;
            if (s == "WARN")  return LogLevel::WARN;
            if (s == "ERROR") return LogLevel::ERROR;
            if (s == "FATAL") return LogLevel::FATAL;
            throw std::invalid_argument("Unknown log level: " + s);
        }

        /// Extract a single-quoted string value, e.g. 'hello world'.
        static std::string extractQuoted(const std::string& s, const std::string& rule) {
            if (s.size() >= 2 && s.front() == '\'' && s.back() == '\'') {
                return s.substr(1, s.size() - 2);
            }
            throw std::invalid_argument("Expected single-quoted string in rule: " + rule);
        }

        static std::string trim(const std::string& s) {
            size_t start = 0;
            while (start < s.size() && (s[start] == ' ' || s[start] == '\t')) ++start;
            size_t end = s.size();
            while (end > start && (s[end - 1] == ' ' || s[end - 1] == '\t')) --end;
            return s.substr(start, end - start);
        }

        static bool startsWith(const std::string& s, const std::string& prefix) {
            return s.size() >= prefix.size() && s.compare(0, prefix.size(), prefix) == 0;
        }
    };

} // namespace minta


// --- lunar_log/core/compact_filter.hpp ---

#include <string>
#include <vector>
#include <stdexcept>
#include <cctype>

namespace minta {
namespace detail {

    inline std::string compactToUpper(const std::string& s) {
        std::string result;
        result.reserve(s.size());
        for (size_t i = 0; i < s.size(); ++i) {
            result += static_cast<char>(std::toupper(static_cast<unsigned char>(s[i])));
        }
        return result;
    }

    inline std::string compactStripQuotes(const std::string& s) {
        if (s.size() >= 2) {
            char first = s.front();
            char last = s.back();
            if ((first == '"' && last == '"') || (first == '\'' && last == '\'')) {
                return s.substr(1, s.size() - 2);
            }
        }
        return s;
    }

    /// Wrap a value in single quotes for DSL consumption.
    /// Throws if the value contains a single quote (cannot be safely
    /// represented in the DSL's outermost-quote-stripping parser).
    inline std::string compactDslQuote(const std::string& s) {
        for (size_t i = 0; i < s.size(); ++i) {
            if (s[i] == '\'') {
                throw std::invalid_argument(
                    "Compact filter value cannot contain single quotes (DSL limitation). "
                    "Use addFilterRule() or setFilter() predicate instead. Value: " + s);
            }
        }
        return "'" + s + "'";
    }

    inline bool compactIsLevelName(const std::string& upper) {
        return upper == "TRACE" || upper == "DEBUG" || upper == "INFO" ||
               upper == "WARN"  || upper == "WARNING" || upper == "ERROR" || upper == "FATAL";
    }

    inline FilterRule parseCompactToken(const std::string& token) {
        if (token.empty()) {
            throw std::invalid_argument("Empty compact filter token");
        }

        if (token.size() >= 2 && token.back() == '+') {
            std::string levelStr = compactToUpper(token.substr(0, token.size() - 1));
            if (compactIsLevelName(levelStr)) {
                if (levelStr == "WARNING") levelStr = "WARN";
                return FilterRule::parse("level >= " + levelStr);
            }
        }

        if (token.size() > 5 && token[0] == '!' && token[1] == 't' &&
            token[2] == 'p' && token[3] == 'l' && token[4] == ':') {
            std::string pattern = compactStripQuotes(token.substr(5));
            return FilterRule::parse("not template == " + compactDslQuote(pattern));
        }

        if (token.size() > 4 && token[0] == 't' && token[1] == 'p' &&
            token[2] == 'l' && token[3] == ':') {
            std::string pattern = compactStripQuotes(token.substr(4));
            return FilterRule::parse("template == " + compactDslQuote(pattern));
        }

        if (token.size() > 2 && token[0] == '!' && token[1] == '~') {
            std::string keyword = compactStripQuotes(token.substr(2));
            if (keyword.empty()) {
                throw std::invalid_argument("Empty keyword in compact filter: " + token);
            }
            return FilterRule::parse("not message contains " + compactDslQuote(keyword));
        }

        if (token.size() > 1 && token[0] == '~') {
            std::string keyword = compactStripQuotes(token.substr(1));
            if (keyword.empty()) {
                throw std::invalid_argument("Empty keyword in compact filter: " + token);
            }
            return FilterRule::parse("message contains " + compactDslQuote(keyword));
        }

        if (token.size() > 4 && token[0] == 'c' && token[1] == 't' &&
            token[2] == 'x' && token[3] == ':') {
            std::string rest = token.substr(4);
            size_t eqPos = std::string::npos;
            bool inQuote = false;
            char quoteChar = 0;
            for (size_t j = 0; j < rest.size(); ++j) {
                if (!inQuote && (rest[j] == '"' || rest[j] == '\'')) {
                    inQuote = true;
                    quoteChar = rest[j];
                } else if (inQuote && rest[j] == quoteChar) {
                    inQuote = false;
                } else if (!inQuote && rest[j] == '=') {
                    eqPos = j;
                    break;
                }
            }

            if (eqPos != std::string::npos && eqPos > 0) {
                std::string key = compactStripQuotes(rest.substr(0, eqPos));
                std::string val = compactStripQuotes(rest.substr(eqPos + 1));
                if (key.empty()) {
                    throw std::invalid_argument("Empty context key in compact filter: " + token);
                }
                if (val.empty()) {
                    throw std::invalid_argument("Empty context value in compact filter: " + token);
                }
                return FilterRule::parse("context " + key + " == " + compactDslQuote(val));
            } else {
                std::string key = compactStripQuotes(rest);
                return FilterRule::parse("context has " + compactDslQuote(key));
            }
        }

        // Catch bare prefixes that fall through because size guards above
        // use strict > (e.g., token.size() > 4 for ctx:). Keep in sync.
        if (token == "ctx:" || token == "tpl:" || token == "!tpl:") {
            throw std::invalid_argument("Missing value after '" + token + "' in compact filter");
        }
        throw std::invalid_argument("Unrecognized compact filter token: " + token);
    }

    /// Parse a compact filter expression string into FilterRule objects.
    /// Tokens are space-separated and AND-combined.
    /// Syntax: LEVEL+, ~keyword, !~keyword, ctx:key, ctx:key=val, tpl:pattern, !tpl:pattern
    /// Level names are case-insensitive. Keywords are case-sensitive.
    inline std::vector<FilterRule> parseCompactFilter(const std::string& expr) {
        std::vector<FilterRule> rules;
        if (expr.empty()) return rules;

        std::vector<std::string> tokens;
        size_t i = 0;
        while (i < expr.size()) {
            while (i < expr.size() && (expr[i] == ' ' || expr[i] == '\t')) ++i;
            if (i >= expr.size()) break;

            std::string token;
            while (i < expr.size() && expr[i] != ' ' && expr[i] != '\t') {
                if (expr[i] == '"' || expr[i] == '\'') {
                    char quote = expr[i];
                    token += quote;
                    ++i;
                    while (i < expr.size() && expr[i] != quote) {
                        token += expr[i];
                        ++i;
                    }
                    if (i >= expr.size()) {
                        throw std::invalid_argument(
                            "Unterminated quote in compact filter expression");
                    }
                    token += expr[i];
                    ++i;
                } else {
                    token += expr[i];
                    ++i;
                }
            }
            if (!token.empty()) {
                tokens.push_back(token);
            }
        }

        for (size_t t = 0; t < tokens.size(); ++t) {
            rules.push_back(parseCompactToken(tokens[t]));
        }

        return rules;
    }

} // namespace detail
} // namespace minta


// --- lunar_log/core/rolling_policy.hpp ---

#include <string>
#include <cstdint>

namespace minta {

    enum class RollInterval {
        None,
        Daily,
        Hourly
    };

    class RollingPolicy {
    public:
        /// Size-based rolling: rotate when the current file reaches maxBytes.
        static RollingPolicy size(const std::string& path, std::uint64_t maxBytes) {
            RollingPolicy p;
            p.m_basePath = path;
            p.m_maxSizeBytes = maxBytes;
            p.m_rollInterval = RollInterval::None;
            return p;
        }

        /// Daily time-based rolling.
        static RollingPolicy daily(const std::string& path) {
            RollingPolicy p;
            p.m_basePath = path;
            p.m_maxSizeBytes = 0;
            p.m_rollInterval = RollInterval::Daily;
            return p;
        }

        /// Hourly time-based rolling.
        static RollingPolicy hourly(const std::string& path) {
            RollingPolicy p;
            p.m_basePath = path;
            p.m_maxSizeBytes = 0;
            p.m_rollInterval = RollInterval::Hourly;
            return p;
        }

        /// Maximum number of rolled files to keep (0 = unlimited).
        RollingPolicy& maxFiles(unsigned int n) {
            m_maxFiles = n;
            return *this;
        }

        /// Maximum size per file (enables hybrid size+time rolling).
        RollingPolicy& maxSize(std::uint64_t bytes) {
            m_maxSizeBytes = bytes;
            return *this;
        }

        /// Maximum total size of all rolled files combined (0 = unlimited).
        /// When exceeded, the oldest rolled files are deleted until under the limit.
        RollingPolicy& maxTotalSize(std::uint64_t bytes) {
            m_maxTotalSize = bytes;
            return *this;
        }

        // --- Accessors ---
        const std::string& basePath()         const { return m_basePath; }
        std::uint64_t      maxSizeBytes()     const { return m_maxSizeBytes; }
        RollInterval       rollInterval()     const { return m_rollInterval; }
        unsigned int       maxFilesCount()    const { return m_maxFiles; }
        std::uint64_t      maxTotalSizeBytes() const { return m_maxTotalSize; }

    private:
        RollingPolicy() : m_maxSizeBytes(0), m_rollInterval(RollInterval::None), m_maxFiles(0), m_maxTotalSize(0) {}

        std::string    m_basePath;
        std::uint64_t  m_maxSizeBytes;
        RollInterval   m_rollInterval;
        unsigned int   m_maxFiles;
        std::uint64_t  m_maxTotalSize;
    };

} // namespace minta


// --- lunar_log/transform/pipe_transform.hpp ---

#include <string>
#include <vector>
#include <cstdlib>
#include <cerrno>
#include <cmath>
#include <cstdio>
#include <cctype>
#include <climits>

namespace minta {
namespace detail {

    // ----------------------------------------------------------------
    // Pipe Transform — parse and apply "|transform" chains
    // ----------------------------------------------------------------

    struct Transform {
        std::string name;
        std::string arg;
    };

    // --- Private helpers (number parsing, UTF-8) ---

    /// Parse a double from string. Separate from detail::tryParseDouble
    /// to keep pipe_transform.hpp self-contained (no log_common.hpp dep).
    inline bool pipeParseDouble(const std::string &s, double &out) {
        if (s.empty()) return false;
        const char *start = s.c_str();
        char *end = nullptr;
        errno = 0;
        double val = std::strtod(start, &end);
        if (errno == ERANGE || end == start ||
            static_cast<size_t>(end - start) != s.size()) {
            errno = 0;
            return false;
        }
        errno = 0;
        if (std::isinf(val) || std::isnan(val)) return false;
        out = val;
        return true;
    }

    /// Safe int parser for transform arguments.
    inline int pipeSafeStoi(const std::string &s, int fallback = 0) {
        if (s.empty()) return fallback;
        for (size_t i = 0; i < s.size(); ++i) {
            if (i == 0 && s[i] == '-') continue;
            if (!std::isdigit(static_cast<unsigned char>(s[i]))) return fallback;
        }
        try { return std::stoi(s); } catch (...) { return fallback; }
    }

    /// Count UTF-8 codepoints in a string.
    inline size_t utf8CharCount(const std::string &s) {
        size_t count = 0;
        for (size_t i = 0; i < s.size(); ) {
            unsigned char c = static_cast<unsigned char>(s[i]);
            if (c < 0x80)        i += 1;
            else if ((c & 0xE0) == 0xC0) i += 2;
            else if ((c & 0xF0) == 0xE0) i += 3;
            else if ((c & 0xF8) == 0xF0) i += 4;
            else                 i += 1; // invalid byte, skip
            ++count;
        }
        return count;
    }

    /// Truncate a string to maxChars UTF-8 codepoints.
    inline std::string utf8Truncate(const std::string &s, size_t maxChars) {
        size_t count = 0;
        size_t bytePos = 0;
        while (bytePos < s.size() && count < maxChars) {
            unsigned char c = static_cast<unsigned char>(s[bytePos]);
            size_t charLen = 1;
            if (c < 0x80)        charLen = 1;
            else if ((c & 0xE0) == 0xC0) charLen = 2;
            else if ((c & 0xF0) == 0xE0) charLen = 3;
            else if ((c & 0xF8) == 0xF0) charLen = 4;
            // Clamp to string boundary to avoid reading past end
            if (bytePos + charLen > s.size()) break;
            bytePos += charLen;
            ++count;
        }
        return s.substr(0, bytePos);
    }

    /// Serialise a Transform back to its pipe-syntax string form.
    inline std::string transformToString(const Transform &t) {
        if (t.arg.empty()) return t.name;
        return t.name + ":" + t.arg;
    }

    /// Clamp a double to the representable long long range (prevents UB on cast).
    inline double pipeClampLL(double val) {
        if (val != val) return 0.0; // NaN
        static const double kMinLL = static_cast<double>(LLONG_MIN + 1);
        static const double kMaxLL = std::nextafter(static_cast<double>(LLONG_MAX), 0.0);
        if (val < kMinLL) return kMinLL;
        if (val > kMaxLL) return kMaxLL;
        return val;
    }

    // ----------------------------------------------------------------
    // Transform parsing
    // ----------------------------------------------------------------

    /// Parse "comma|truncate:10|quote" into [{comma,""}, {truncate,"10"}, {quote,""}]
    inline std::vector<Transform> parseTransforms(const std::string &pipeStr) {
        std::vector<Transform> result;
        if (pipeStr.empty()) return result;

        size_t start = 0;
        while (start <= pipeStr.size()) {
            size_t end = pipeStr.find('|', start);
            if (end == std::string::npos) end = pipeStr.size();
            if (end > start) {
                std::string token = pipeStr.substr(start, end - start);
                size_t colonPos = token.find(':');
                if (colonPos != std::string::npos) {
                    result.push_back({token.substr(0, colonPos),
                                      token.substr(colonPos + 1)});
                } else {
                    result.push_back({token, std::string()});
                }
            }
            start = end + 1;
        }
        return result;
    }

    // ----------------------------------------------------------------
    // Built-in String Transforms
    // ----------------------------------------------------------------

    inline std::string transformUpper(const std::string &value) {
        std::string result = value;
        for (size_t i = 0; i < result.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(result[i]);
            if (c >= 'a' && c <= 'z') result[i] = static_cast<char>(c - 32);
        }
        return result;
    }

    inline std::string transformLower(const std::string &value) {
        std::string result = value;
        for (size_t i = 0; i < result.size(); ++i) {
            unsigned char c = static_cast<unsigned char>(result[i]);
            if (c >= 'A' && c <= 'Z') result[i] = static_cast<char>(c + 32);
        }
        return result;
    }

    inline std::string transformTrim(const std::string &value) {
        if (value.empty()) return value;
        size_t start = 0;
        while (start < value.size() &&
               std::isspace(static_cast<unsigned char>(value[start]))) ++start;
        if (start == value.size()) return std::string();
        size_t end = value.size();
        while (end > start &&
               std::isspace(static_cast<unsigned char>(value[end - 1]))) --end;
        return value.substr(start, end - start);
    }

    /// Limit to N UTF-8 codepoints; append ellipsis if truncated.
    inline std::string transformTruncate(const std::string &value,
                                         const std::string &arg) {
        int n = pipeSafeStoi(arg, -1);
        if (n < 0) return value; // invalid / missing arg
        size_t maxChars = static_cast<size_t>(n);
        size_t charCount = utf8CharCount(value);
        if (charCount <= maxChars) return value;
        // U+2026 HORIZONTAL ELLIPSIS (3 bytes in UTF-8)
        return utf8Truncate(value, maxChars) + "\xe2\x80\xa6";
    }

    /// Right-pad with spaces to N UTF-8 codepoints.
    inline std::string transformPad(const std::string &value,
                                    const std::string &arg) {
        int n = pipeSafeStoi(arg, 0);
        if (n <= 0) return value;
        size_t charCount = utf8CharCount(value);
        if (charCount >= static_cast<size_t>(n)) return value;
        return value + std::string(static_cast<size_t>(n) - charCount, ' ');
    }

    /// Left-pad with spaces to N UTF-8 codepoints.
    inline std::string transformPadLeft(const std::string &value,
                                        const std::string &arg) {
        int n = pipeSafeStoi(arg, 0);
        if (n <= 0) return value;
        size_t charCount = utf8CharCount(value);
        if (charCount >= static_cast<size_t>(n)) return value;
        return std::string(static_cast<size_t>(n) - charCount, ' ') + value;
    }

    /// Wrap in double quotes.
    inline std::string transformQuote(const std::string &value) {
        return "\"" + value + "\"";
    }

    // ----------------------------------------------------------------
    // Built-in Number Transforms
    // ----------------------------------------------------------------

    /// Thousands separator: 1234567 -> "1,234,567", 1234567.89 -> "1,234,567.89"
    inline std::string transformComma(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;

        // Normalize scientific notation to fixed-point
        std::string work = value;
        if (value.find('e') != std::string::npos ||
            value.find('E') != std::string::npos) {
            char buf[64];
            if (numVal == std::floor(numVal) && std::fabs(numVal) < 1e15) {
                std::snprintf(buf, sizeof(buf), "%.0f", numVal);
            } else {
                std::snprintf(buf, sizeof(buf), "%.15g", numVal);
            }
            work = std::string(buf);
        }

        // Split on decimal point
        size_t dotPos = work.find('.');
        std::string intPart = (dotPos != std::string::npos)
                                  ? work.substr(0, dotPos)
                                  : work;
        std::string decPart = (dotPos != std::string::npos)
                                  ? work.substr(dotPos)
                                  : std::string();

        // Handle sign
        std::string prefix;
        if (!intPart.empty() && (intPart[0] == '-' || intPart[0] == '+')) {
            prefix = intPart.substr(0, 1);
            intPart = intPart.substr(1);
        }

        // Add commas every 3 digits from the right
        std::string result;
        int len = static_cast<int>(intPart.size());
        for (int i = 0; i < len; ++i) {
            if (i > 0 && (len - i) % 3 == 0) {
                result += ',';
            }
            result += intPart[i];
        }

        return prefix + result + decPart;
    }

    /// Hex with 0x prefix: 255 -> "0xff"
    inline std::string transformHex(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        long long intVal = static_cast<long long>(pipeClampLL(numVal));
        char buf[64];
        if (intVal < 0) {
            unsigned long long uval = 0ULL - static_cast<unsigned long long>(intVal);
            std::snprintf(buf, sizeof(buf), "-0x%llx", uval);
        } else {
            std::snprintf(buf, sizeof(buf), "0x%llx",
                          static_cast<unsigned long long>(intVal));
        }
        return std::string(buf);
    }

    /// Octal with 0 prefix: 8 -> "010"
    inline std::string transformOct(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        long long intVal = static_cast<long long>(pipeClampLL(numVal));
        char buf[64];
        if (intVal < 0) {
            unsigned long long uval = 0ULL - static_cast<unsigned long long>(intVal);
            std::snprintf(buf, sizeof(buf), "-0%llo", uval);
        } else if (intVal == 0) {
            return "0";
        } else {
            std::snprintf(buf, sizeof(buf), "0%llo",
                          static_cast<unsigned long long>(intVal));
        }
        return std::string(buf);
    }

    /// Binary with 0b prefix: 10 -> "0b1010"
    inline std::string transformBin(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        long long intVal = static_cast<long long>(pipeClampLL(numVal));
        bool negative = intVal < 0;
        unsigned long long uval = negative
            ? (0ULL - static_cast<unsigned long long>(intVal))
            : static_cast<unsigned long long>(intVal);

        if (uval == 0) return "0b0";

        std::string bits;
        unsigned long long tmp = uval;
        while (tmp > 0) {
            bits = static_cast<char>('0' + static_cast<int>(tmp & 1)) + bits;
            tmp >>= 1;
        }

        std::string result = negative ? "-0b" : "0b";
        result += bits;
        return result;
    }

    /// Human-readable bytes: 1048576 -> "1.0 MB"
    inline std::string transformBytes(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;

        static const char *units[] = {"B", "KB", "MB", "GB", "TB", "PB"};
        static const int unitCount = 6;

        double absVal = std::fabs(numVal);
        double displayVal = absVal;
        int unitIdx = 0;

        while (displayVal >= 1024.0 && unitIdx < unitCount - 1) {
            displayVal /= 1024.0;
            ++unitIdx;
        }

        if (numVal < 0) displayVal = -displayVal;

        char buf[64];
        if (unitIdx == 0) {
            std::snprintf(buf, sizeof(buf), "%lld B",
                          static_cast<long long>(numVal));
        } else {
            std::snprintf(buf, sizeof(buf), "%.1f %s", displayVal,
                          units[unitIdx]);
        }
        return std::string(buf);
    }

    /// Human-readable time from milliseconds: 3661000 -> "1h 1m 1s"
    inline std::string transformDuration(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;

        long long totalMs = static_cast<long long>(pipeClampLL(numVal));
        bool negative = totalMs < 0;
        if (negative) {
            // Avoid signed negation UB on LLONG_MIN by using unsigned arithmetic
            unsigned long long uMs = static_cast<unsigned long long>(-(totalMs + 1)) + 1u;
            totalMs = static_cast<long long>(uMs);
        }

        long long totalSec = totalMs / 1000;
        long long ms = totalMs % 1000;
        long long hours = totalSec / 3600;
        long long remaining = totalSec % 3600;
        long long minutes = remaining / 60;
        long long seconds = remaining % 60;

        std::string result;
        if (negative) result += "-";

        if (totalSec == 0 && ms == 0) {
            return result + "0s";
        }

        if (totalSec == 0) {
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%lldms", ms);
            return result + buf;
        }

        bool first = true;
        if (hours > 0) {
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%lldh", hours);
            result += buf;
            first = false;
        }
        if (minutes > 0) {
            if (!first) result += " ";
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%lldm", minutes);
            result += buf;
            first = false;
        }
        if (seconds > 0 || (hours == 0 && minutes == 0)) {
            if (!first) result += " ";
            char buf[32];
            std::snprintf(buf, sizeof(buf), "%llds", seconds);
            result += buf;
        }

        return result;
    }

    /// Percentage: 0.856 -> "85.6%"
    inline std::string transformPct(const std::string &value) {
        double numVal;
        if (!pipeParseDouble(value, numVal)) return value;
        double pct = numVal * 100.0;
        char buf[64];
        std::snprintf(buf, sizeof(buf), "%.1f%%", pct);
        return std::string(buf);
    }

    // ----------------------------------------------------------------
    // Structural Transforms
    // ----------------------------------------------------------------

    /// Force JSON serialization of the value.
    inline std::string transformJson(const std::string &value) {
        if (value == "true" || value == "false") return value;
        if (value == "(null)") return "null";

        double numVal;
        if (pipeParseDouble(value, numVal)) {
            char buf[64];
            if (numVal == static_cast<double>(static_cast<long long>(numVal)) &&
                std::fabs(numVal) < 1e15) {
                std::snprintf(buf, sizeof(buf), "%lld",
                              static_cast<long long>(numVal));
            } else {
                std::snprintf(buf, sizeof(buf), "%.15g", numVal);
            }
            return std::string(buf);
        }

        // String — wrap in quotes with JSON escaping
        std::string result = "\"";
        for (size_t i = 0; i < value.size(); ++i) {
            char c = value[i];
            switch (c) {
                case '"':  result += "\\\""; break;
                case '\\': result += "\\\\"; break;
                case '\b': result += "\\b";  break;
                case '\f': result += "\\f";  break;
                case '\n': result += "\\n";  break;
                case '\r': result += "\\r";  break;
                case '\t': result += "\\t";  break;
                default:
                    if (static_cast<unsigned char>(c) < 0x20) {
                        char esc[8];
                        std::snprintf(esc, sizeof(esc), "\\u%04x",
                                      static_cast<unsigned char>(c));
                        result += esc;
                    } else {
                        result += c;
                    }
            }
        }
        result += '"';
        return result;
    }

    /// Output the detected C++ type name.
    inline std::string transformType(const std::string &value) {
        if (value == "true" || value == "false") return "bool";
        if (value == "(null)") return "nullptr_t";

        double numVal;
        if (pipeParseDouble(value, numVal)) {
            if (value.find('.') == std::string::npos &&
                value.find('e') == std::string::npos &&
                value.find('E') == std::string::npos) {
                return "int";
            }
            return "double";
        }
        return "string";
    }

    // ----------------------------------------------------------------
    // Transform pipeline — apply left to right
    // ----------------------------------------------------------------

    /// Apply a sequence of transforms to a formatted value.
    /// Structural transforms (expand, str) are no-ops on the string —
    /// they affect property metadata and are handled in mapProperties.
    /// Unknown transforms pass the value through unchanged (fail-open).
    inline std::string applyTransforms(const std::string &value,
                                       const std::vector<Transform> &transforms) {
        if (transforms.empty()) return value;
        std::string result = value;
        for (size_t i = 0; i < transforms.size(); ++i) {
            const std::string &name = transforms[i].name;
            const std::string &arg  = transforms[i].arg;

            // Structural — skip (handled elsewhere)
            if (name == "expand" || name == "str") continue;

            // String transforms
            if      (name == "upper")    result = transformUpper(result);
            else if (name == "lower")    result = transformLower(result);
            else if (name == "trim")     result = transformTrim(result);
            else if (name == "truncate") result = transformTruncate(result, arg);
            else if (name == "pad")      result = transformPad(result, arg);
            else if (name == "padl")     result = transformPadLeft(result, arg);
            else if (name == "quote")    result = transformQuote(result);

            // Number transforms
            else if (name == "comma")    result = transformComma(result);
            else if (name == "hex")      result = transformHex(result);
            else if (name == "oct")      result = transformOct(result);
            else if (name == "bin")      result = transformBin(result);
            else if (name == "bytes")    result = transformBytes(result);
            else if (name == "duration") result = transformDuration(result);
            else if (name == "pct")      result = transformPct(result);

            // Structural value transforms
            else if (name == "json")     result = transformJson(result);
            else if (name == "type")     result = transformType(result);

            // Unknown transform — fail-open, value passes through
        }
        return result;
    }

} // namespace detail
} // namespace minta


// --- lunar_log/formatter/formatter_interface.hpp ---

#include <string>
#include <vector>
#include <mutex>

namespace minta {
    class IFormatter {
    public:
        virtual ~IFormatter() = default;

        virtual std::string format(const LogEntry &entry) const = 0;

        /// Set the per-sink locale for culture-specific format specifiers.
        /// When set (non-empty), the formatter re-renders the message using
        /// this locale instead of the logger-level locale stored in the entry.
        /// Thread-safe: can be called concurrently with format().
        void setLocale(const std::string& locale) {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            m_locale = locale;
        }

        std::string getLocale() const {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            return m_locale;
        }

    protected:
        /// Re-render the entry's message with this formatter's locale.
        /// Returns the original message if no per-sink locale is set or
        /// if the per-sink locale matches the entry's locale.
        std::string localizedMessage(const LogEntry &entry) const {
            // Copy locale under lock, then use the copy outside.
            std::string localeCopy;
            {
                std::lock_guard<std::mutex> lock(m_localeMutex);
                localeCopy = m_locale;
            }
            if (localeCopy.empty() || localeCopy == entry.locale) {
                return entry.message;
            }
            // Textually-different locale names may resolve to the same
            // locale (e.g. "en_US" vs "en_US.UTF-8") — skip re-render.
            {
                auto resolved1 = detail::tryCreateLocale(localeCopy);
                auto resolved2 = detail::tryCreateLocale(entry.locale);
                if (resolved1.name() == resolved2.name()) {
                    return entry.message;
                }
            }
            std::vector<detail::ParsedPlaceholder> spans;
            detail::forEachPlaceholder(entry.templateStr, [&](const detail::ParsedPlaceholder& ph) {
                spans.push_back(ph);
            });
            size_t maxSlot = 0;
            size_t namedOrdinal = 0;
            for (size_t i = 0; i < spans.size(); ++i) {
                size_t slot = detail::resolveValueSlot(spans[i].indexedArg, namedOrdinal);
                if (spans[i].indexedArg < 0) ++namedOrdinal;
                if (slot + 1 > maxSlot) maxSlot = slot + 1;
            }
            std::vector<std::string> values(maxSlot);
            // Use slot/placeholder order as captured in entry.arguments.
            // Do not collapse by placeholder name: duplicate names may carry
            // distinct positional values (e.g. "{x} {x}" with args 1,2).
            namedOrdinal = 0;
            size_t argCursor = 0;
            for (size_t i = 0; i < spans.size(); ++i) {
                const auto &ph = spans[i];
                size_t slot = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                if (slot < values.size() && argCursor < entry.arguments.size()) {
                    values[slot] = entry.arguments[argCursor].second;
                    ++argCursor;
                }
            }
            return detail::walkTemplate(entry.templateStr, spans, values, localeCopy);
        }

    private:
        mutable std::mutex m_localeMutex;
        std::string m_locale;
    };
} // namespace minta


// --- lunar_log/formatter/human_readable_formatter.hpp ---

#include <string>

namespace minta {
    class HumanReadableFormatter : public IFormatter {
    public:
        /// Set the output template for this formatter.
        /// Must be called before logging begins (same contract as
        /// useFormatter / addSink). Not safe to call concurrently
        /// with format().
        void setOutputTemplate(const std::string& templateStr) {
            if (templateStr.empty()) {
                m_outputTemplate = detail::OutputTemplate();
                m_hasTemplate = false;
            } else {
                m_outputTemplate = detail::OutputTemplate(templateStr);
                m_hasTemplate = true;
            }
        }

        std::string format(const LogEntry &entry) const override {
            if (m_hasTemplate) {
                return m_outputTemplate.render(entry, localizedMessage(entry));
            }
            return formatDefault(entry);
        }

    private:
        detail::OutputTemplate m_outputTemplate;
        bool m_hasTemplate = false;

        std::string formatDefault(const LogEntry &entry) const {
            std::string result;
            result.reserve(80 + entry.message.size() + entry.file.size() + entry.function.size());
            result += detail::formatTimestamp(entry.timestamp);
            result += " [";
            result += getLevelString(entry.level);
            result += "] ";
            result += localizedMessage(entry);

            if (!entry.file.empty()) {
                result += " [";
                result += entry.file;
                result += ':';
                result += std::to_string(entry.line);
                result += ' ';
                result += entry.function;
                result += ']';
            }

            if (!entry.customContext.empty()) {
                result += " {";
                bool first = true;
                for (const auto &ctx : entry.customContext) {
                    if (!first) result += ", ";
                    result += ctx.first;
                    result += '=';
                    if (ctx.second.find(',') != std::string::npos ||
                        ctx.second.find('=') != std::string::npos ||
                        ctx.second.find('"') != std::string::npos) {
                        result += '"';
                        for (char c : ctx.second) {
                            if (c == '"') result += '\\';
                            result += c;
                        }
                        result += '"';
                    } else {
                        result += ctx.second;
                    }
                    first = false;
                }
                result += '}';
            }

            if (!entry.exceptionType.empty()) {
                result += "\n  ";
                result += entry.exceptionType;
                result += ": ";
                result += entry.exceptionMessage;
                if (!entry.exceptionChain.empty()) {
                    const std::string& chain = entry.exceptionChain;
                    size_t pos = 0;
                    while (pos < chain.size()) {
                        size_t nl = chain.find('\n', pos);
                        result += "\n  --- ";
                        if (nl == std::string::npos) {
                            result.append(chain, pos, chain.size() - pos);
                            break;
                        }
                        result.append(chain, pos, nl - pos);
                        pos = nl + 1;
                    }
                }
            }

            return result;
        }
    };
} // namespace minta


// --- lunar_log/formatter/json_detail.hpp ---

#include <string>
#include <cstdio>
#include <cstdlib>
#include <cerrno>
#include <cmath>

// Platform-specific includes for locale-independent strtod.
// strtod_l / _strtod_l lets us parse with the "C" locale regardless
// of the process-wide locale set via setlocale().
#if defined(_MSC_VER)
    #include <locale.h>
#elif defined(__APPLE__)
    #include <xlocale.h>
#elif defined(__GLIBC__) || defined(__FreeBSD__)
    #include <locale.h>
#endif

namespace minta {
namespace detail {
namespace json {

    /// Locale-independent strtod.  Prevents the global C locale from
    /// interfering with JSON number parsing (e.g. locales that use ','
    /// as the decimal separator would cause plain strtod to reject "3.14").
    ///
    /// Uses strtod_l / _strtod_l where available (glibc, macOS, MSVC).
    /// Falls back to plain strtod on other platforms -- the output-side
    /// comma-to-dot replacement still produces valid JSON, but '.' in
    /// the *input* may be misinterpreted under a non-"C" locale on those
    /// platforms.
    inline double strtodLocaleIndependent(const char* str, char** endptr) {
#if defined(_MSC_VER)
        static _locale_t c_locale = _create_locale(LC_ALL, "C");
        return _strtod_l(str, endptr, c_locale);
#elif defined(__GLIBC__) || defined(__APPLE__) || defined(__FreeBSD__)
        static locale_t c_locale = newlocale(LC_ALL_MASK, "C", (locale_t)0);
        return strtod_l(str, endptr, c_locale);
#else
        return std::strtod(str, endptr);
#endif
    }

    /// Escape a string for inclusion in JSON output.
    /// Handles special characters (quotes, backslash, control chars).
    /// UTF-8 multi-byte sequences (>= 0x80) pass through unescaped.
    inline std::string escapeJsonString(const std::string &input) {
        std::string result;
        result.reserve(input.size());
        for (char c : input) {
            switch (c) {
                case '"': result += R"(\")"; break;
                case '\\': result += R"(\\)"; break;
                case '\b': result += R"(\b)"; break;
                case '\f': result += R"(\f)"; break;
                case '\n': result += R"(\n)"; break;
                case '\r': result += R"(\r)"; break;
                case '\t': result += R"(\t)"; break;
                default:
                    if ('\x00' <= c && c <= '\x1f') {
                        char buf[8];
                        std::snprintf(buf, sizeof(buf), "\\u%04x",
                                     static_cast<unsigned char>(c));
                        result += buf;
                    } else {
                        result += c;
                    }
            }
        }
        return result;
    }

    /// Attempt to emit a JSON-native value for @ (destructure) properties.
    /// Values arrive as strings (post-toString conversion), so original type
    /// info is lost.  This function uses string-based heuristics: "true"/"false"
    /// become JSON booleans, numeric-looking strings become JSON numbers.
    /// Known limitation: a string argument "true" becomes boolean true, and
    /// "3.14" becomes number 3.14.  Use the $ (stringify) operator to force
    /// string representation when this coercion is undesirable.
    /// Note: nullptr/"(null)" is emitted as the string "(null)", not JSON null,
    /// since the MessageTemplates spec does not mandate null handling.
    inline std::string toJsonNativeValue(const std::string &value) {
        if (value == "true" || value == "false") {
            return value;
        }

        if (value.empty()) {
            return "\"\"";
        }

        const char* start = value.c_str();
        char* end = nullptr;
        errno = 0;
        double numVal = strtodLocaleIndependent(start, &end);
        if (errno == 0 && end != start
            && static_cast<size_t>(end - start) == value.size()
            && std::isfinite(numVal)) {
            // Re-serialize from the parsed double to guarantee valid JSON.
            // strtod accepts inputs like "+42", " 42", "0x1A" which are
            // NOT valid JSON numbers, so we cannot return the original string.
            char buf[64];
            if (numVal == static_cast<double>(static_cast<long long>(numVal))
                && std::fabs(numVal) < 1e15) {
                std::snprintf(buf, sizeof(buf), "%lld",
                             static_cast<long long>(numVal));
            } else {
                std::snprintf(buf, sizeof(buf), "%.15g", numVal);
            }
            // Locale-safety: some locales use ',' as decimal separator.
            // Replace with '.' to guarantee valid JSON numbers.
            for (char *p = buf; *p; ++p) {
                if (*p == ',') *p = '.';
            }
            return std::string(buf);
        }
        errno = 0;

        std::string result = "\"";
        result += escapeJsonString(value);
        result += '"';
        return result;
    }

} // namespace json
} // namespace detail
} // namespace minta


// --- lunar_log/formatter/json_formatter.hpp ---

#include <string>

namespace minta {
    class JsonFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::string levelStr = getLevelString(entry.level);
            std::string tsStr = detail::formatTimestamp(entry.timestamp);
            std::string msgEsc = detail::json::escapeJsonString(localizedMessage(entry));

            std::string json;
            json.reserve(64 + levelStr.size() + tsStr.size() + msgEsc.size());
            json += R"({"level":")";
            json += levelStr;
            json += R"(","timestamp":")";
            json += tsStr;
            json += R"(","message":")";
            json += msgEsc;
            json += '"';

            if (!entry.templateStr.empty()) {
                json += R"(,"messageTemplate":")";
                json += detail::json::escapeJsonString(entry.templateStr);
                json += R"(","templateHash":")";
                json += detail::toHexString(entry.templateHash);
                json += '"';
            }

            if (!entry.file.empty()) {
                std::string fileEsc = detail::json::escapeJsonString(entry.file);
                std::string funcEsc = detail::json::escapeJsonString(entry.function);
                json += R"(,"file":")";
                json += fileEsc;
                json += R"(","line":)";
                json += std::to_string(entry.line);
                json += R"(,"function":")";
                json += funcEsc;
                json += '"';
            }

            if (!entry.customContext.empty()) {
                json += R"(,"context":{)";
                bool first = true;
                for (const auto &ctx : entry.customContext) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(ctx.first);
                    json += R"(":")";
                    json += detail::json::escapeJsonString(ctx.second);
                    json += '"';
                    first = false;
                }
                json += '}';
            }

            if (!entry.tags.empty()) {
                json += R"(,"tags":[)";
                bool first = true;
                for (const auto &tag : entry.tags) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(tag);
                    json += '"';
                    first = false;
                }
                json += ']';
            }

            if (!entry.exceptionType.empty()) {
                json += R"(,"exception":{"type":")";
                json += detail::json::escapeJsonString(entry.exceptionType);
                json += R"(","message":")";
                json += detail::json::escapeJsonString(entry.exceptionMessage);
                json += '"';
                if (!entry.exceptionChain.empty()) {
                    json += R"(,"chain":")";
                    json += detail::json::escapeJsonString(entry.exceptionChain);
                    json += '"';
                }
                json += '}';
            }

            if (!entry.properties.empty()) {
                json += R"(,"properties":{)";
                bool first = true;
                for (const auto &prop : entry.properties) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(prop.name);
                    json += R"(":)";
                    if (prop.op == '@') {
                        json += detail::json::toJsonNativeValue(prop.value);
                    } else {
                        json += '"';
                        json += detail::json::escapeJsonString(prop.value);
                        json += '"';
                    }
                    first = false;
                }
                json += '}';

                bool hasTransforms = false;
                for (const auto &prop : entry.properties) {
                    if (!prop.transforms.empty()) { hasTransforms = true; break; }
                }
                if (hasTransforms) {
                    json += R"(,"transforms":{)";
                    bool firstProp = true;
                    for (const auto &prop : entry.properties) {
                        if (prop.transforms.empty()) continue;
                        if (!firstProp) json += ',';
                        json += '"';
                        json += detail::json::escapeJsonString(prop.name);
                        json += R"(":[)";
                        bool firstT = true;
                        for (const auto &t : prop.transforms) {
                            if (!firstT) json += ',';
                            json += '"';
                            json += detail::json::escapeJsonString(t);
                            json += '"';
                            firstT = false;
                        }
                        json += ']';
                        firstProp = false;
                    }
                    json += '}';
                }
            }

            json += '}';
            return json;
        }

    };
} // namespace minta


// --- lunar_log/formatter/compact_json_formatter.hpp ---

#include <string>
#include <cstdio>
#include <atomic>

namespace minta {
    /// Compact JSON formatter producing single-line JSONL output optimized for
    /// log pipelines (ELK, Datadog, Loki).  Uses short property names with @
    /// prefix following the CLEF (Compact Log Event Format) convention.
    ///
    /// System fields:
    ///   @t  = timestamp (ISO 8601, UTC, ms precision)
    ///   @l  = level (3-char: TRC, DBG, INF, WRN, ERR, FTL; omitted for INFO)
    ///   @mt = message template
    ///   @m  = rendered message (optional, off by default)
    ///   @i  = template hash (included when template is present)
    ///   @x  = exception info (type: message, with nested chain if present)
    ///
    /// Properties and context are flattened to top level.  User property names
    /// starting with @ are escaped to @@ to prevent collision with system fields.
    /// The @l field is omitted for INFO level (parsers assume INFO when absent).
    class CompactJsonFormatter : public IFormatter {
    public:
        CompactJsonFormatter() : m_includeRenderedMessage(false) {}

        /// Enable/disable the @m (rendered message) field.
        /// Default is false (off).  Thread-safe.
        void includeRenderedMessage(bool include) {
            m_includeRenderedMessage.store(include, std::memory_order_relaxed);
        }

        bool isRenderedMessageIncluded() const {
            return m_includeRenderedMessage.load(std::memory_order_relaxed);
        }

        std::string format(const LogEntry &entry) const override {
            std::string json;
            json.reserve(128);

            // @t - timestamp (ISO 8601, UTC, ms precision)
            json += R"({"@t":")";
            json += formatTimestampUtc(entry.timestamp);
            json += '"';

            // @l - level (omitted for INFO)
            if (entry.level != LogLevel::INFO) {
                json += R"(,"@l":")";
                json += getCompactLevel(entry.level);
                json += '"';
            }

            // @mt - message template (always present)
            json += R"(,"@mt":")";
            if (!entry.templateStr.empty()) {
                json += detail::json::escapeJsonString(entry.templateStr);
            } else {
                json += detail::json::escapeJsonString(entry.message);
            }
            json += '"';

            // @i - template hash (when template is present)
            if (!entry.templateStr.empty()) {
                json += R"(,"@i":")";
                json += detail::toHexString(entry.templateHash);
                json += '"';
            }

            // @m - rendered message (optional, off by default)
            if (m_includeRenderedMessage.load(std::memory_order_relaxed)) {
                json += R"(,"@m":")";
                json += detail::json::escapeJsonString(localizedMessage(entry));
                json += '"';
            }

            if (!entry.exceptionType.empty()) {
                // Build the full @x string first, then escape once to avoid
                // fragmented escaping that can produce inconsistent output.
                std::string xValue;
                xValue += entry.exceptionType;
                xValue += ": ";
                xValue += entry.exceptionMessage;
                if (!entry.exceptionChain.empty()) {
                    xValue += '\n';
                    xValue += entry.exceptionChain;
                }
                json += R"(,"@x":")";
                json += detail::json::escapeJsonString(xValue);
                json += '"';
            }

            for (const auto &prop : entry.properties) {
                json += ',';
                json += '"';
                json += escapePropertyName(prop.name);
                json += R"(":)";
                if (prop.op == '@') {
                    json += detail::json::toJsonNativeValue(prop.value);
                } else {
                    json += '"';
                    json += detail::json::escapeJsonString(prop.value);
                    json += '"';
                }
            }

            // Flatten context to top level
            for (const auto &ctx : entry.customContext) {
                json += ',';
                json += '"';
                json += escapePropertyName(ctx.first);
                json += R"(":)";
                json += '"';
                json += detail::json::escapeJsonString(ctx.second);
                json += '"';
            }

            // Tags
            if (!entry.tags.empty()) {
                json += R"(,"tags":[)";
                bool first = true;
                for (const auto &tag : entry.tags) {
                    if (!first) json += ',';
                    json += '"';
                    json += detail::json::escapeJsonString(tag);
                    json += '"';
                    first = false;
                }
                json += ']';
            }

            json += '}';
            return json;
        }

    private:
        std::atomic<bool> m_includeRenderedMessage;

        /// Format timestamp as ISO 8601 UTC with millisecond precision.
        /// Example: "2026-02-16T12:00:00.000Z"
        static std::string formatTimestampUtc(const std::chrono::system_clock::time_point &time) {
            auto epoch = std::chrono::system_clock::to_time_t(time);
            auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                time.time_since_epoch()) % 1000;

            std::tm tmBuf;
#if defined(_MSC_VER)
            gmtime_s(&tmBuf, &epoch);
#else
            gmtime_r(&epoch, &tmBuf);
#endif

            char buf[32];
            size_t pos = std::strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S", &tmBuf);
            if (pos == 0) {
                buf[0] = '\0';
            }
            // Defensive: ensure non-negative milliseconds for pre-epoch time points
            std::snprintf(buf + pos, sizeof(buf) - pos, ".%03dZ",
                         static_cast<int>((ms.count() + 1000) % 1000));
            return std::string(buf);
        }

        /// Return 3-character level abbreviation.
        static const char* getCompactLevel(LogLevel level) {
            switch (level) {
                case LogLevel::TRACE: return "TRC";
                case LogLevel::DEBUG: return "DBG";
                case LogLevel::INFO:  return "INF";
                case LogLevel::WARN:  return "WRN";
                case LogLevel::ERROR: return "ERR";
                case LogLevel::FATAL: return "FTL";
                default: return "INF";
            }
        }

        /// Escape a property name for use as a JSON key.
        /// Names starting with @ are escaped to @@ to avoid collision with
        /// system fields (@t, @l, @mt, etc.).
        static std::string escapePropertyName(const std::string &name) {
            if (!name.empty() && name[0] == '@') {
                return "@" + detail::json::escapeJsonString(name);
            }
            return detail::json::escapeJsonString(name);
        }
    };
} // namespace minta


// --- lunar_log/formatter/xml_formatter.hpp ---

#include <string>
#include <cstdio>

namespace minta {
    class XmlFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::string xml;
            xml += "<log_entry>";
            xml += "<level>";
            xml += getLevelString(entry.level);
            xml += "</level>";
            xml += "<timestamp>";
            xml += detail::formatTimestamp(entry.timestamp);
            xml += "</timestamp>";
            xml += "<message>";
            xml += escapeXmlString(localizedMessage(entry));
            xml += "</message>";

            if (!entry.templateStr.empty()) {
                xml += "<MessageTemplate hash=\"";
                xml += detail::toHexString(entry.templateHash);
                xml += "\">";
                xml += escapeXmlString(entry.templateStr);
                xml += "</MessageTemplate>";
            }

            if (!entry.file.empty()) {
                xml += "<file>";
                xml += escapeXmlString(entry.file);
                xml += "</file>";
                xml += "<line>";
                xml += std::to_string(entry.line);
                xml += "</line>";
                xml += "<function>";
                xml += escapeXmlString(entry.function);
                xml += "</function>";
            }

            if (!entry.tags.empty()) {
                xml += "<tags>";
                for (const auto &tag : entry.tags) {
                    xml += "<tag>";
                    xml += escapeXmlString(tag);
                    xml += "</tag>";
                }
                xml += "</tags>";
            }

            if (!entry.exceptionType.empty()) {
                xml += "<exception type=\"";
                xml += escapeXmlString(entry.exceptionType);
                xml += "\">";
                xml += escapeXmlString(entry.exceptionMessage);
                if (!entry.exceptionChain.empty()) {
                    xml += "<chain>";
                    xml += escapeXmlString(entry.exceptionChain);
                    xml += "</chain>";
                }
                xml += "</exception>";
            }

            if (!entry.customContext.empty()) {
                xml += "<context>";
                for (const auto &ctx : entry.customContext) {
                    std::string safeName = sanitizeXmlName(ctx.first);
                    xml += "<";
                    xml += safeName;
                    xml += ">";
                    xml += escapeXmlString(ctx.second);
                    xml += "</";
                    xml += safeName;
                    xml += ">";
                }
                xml += "</context>";
            }

            if (!entry.properties.empty()) {
                xml += "<properties>";
                for (const auto &prop : entry.properties) {
                    std::string safeName = sanitizeXmlName(prop.name);
                    xml += "<";
                    xml += safeName;
                    if (prop.op == '@') {
                        xml += " destructure=\"true\"";
                    } else if (prop.op == '$') {
                        xml += " stringify=\"true\"";
                    }
                    if (!prop.transforms.empty()) {
                        xml += " transforms=\"";
                        bool firstT = true;
                        for (const auto &t : prop.transforms) {
                            if (!firstT) xml += '|';
                            xml += escapeXmlString(t);
                            firstT = false;
                        }
                        xml += '"';
                    }
                    xml += ">";
                    xml += escapeXmlString(prop.value);
                    xml += "</";
                    xml += safeName;
                    xml += ">";
                }
                xml += "</properties>";
            }

            xml += "</log_entry>";
            return xml;
        }

    private:
        static std::string sanitizeXmlName(const std::string &input) {
            if (input.empty()) return "_";
            std::string result;
            result.reserve(input.size() + 1);
            for (size_t i = 0; i < input.size(); ++i) {
                char c = input[i];
                bool valid = (c == '_' || c == ':') ||
                             (c >= 'A' && c <= 'Z') ||
                             (c >= 'a' && c <= 'z') ||
                             (c >= '0' && c <= '9') || c == '-' || c == '.';
                result += valid ? c : '_';
            }
            if (result.empty()) return "_";
            // XML element names cannot start with a digit, '-' or '.'.
            // Prefix with '_' instead of replacing the whole name so numeric
            // indexed keys like "0", "1" remain distinct as "_0", "_1".
            if (result[0] == '-' || result[0] == '.' || (result[0] >= '0' && result[0] <= '9')) {
                result.insert(result.begin(), '_');
            }
            return result;
        }

        static std::string escapeXmlString(const std::string &input) {
            std::string result;
            result.reserve(input.size());
            for (char c : input) {
                unsigned char uc = static_cast<unsigned char>(c);
                if (uc < 0x20 && uc != 0x09 && uc != 0x0A && uc != 0x0D) {
                    result += ' ';
                    continue;
                }
                switch (c) {
                    case '<': result += "&lt;"; break;
                    case '>': result += "&gt;"; break;
                    case '&': result += "&amp;"; break;
                    case '\'': result += "&apos;"; break;
                    case '"': result += "&quot;"; break;
                    default: result += c; break;
                }
            }
            return result;
        }
    };
} // namespace minta


// --- lunar_log/transport/transport_interface.hpp ---

#include <string>

namespace minta {

    class ITransport {
    public:
        virtual ~ITransport() = default;
        virtual void write(const std::string& formattedEntry) = 0;
    };

} // namespace minta


// --- lunar_log/transport/file_transport.hpp ---

#include <fstream>
#include <mutex>
#include <stdexcept>

namespace minta {
    class FileTransport : public ITransport {
    public:
        explicit FileTransport(const std::string &filename, bool autoFlush = true)
            : m_autoFlush(autoFlush) {
            m_file.open(filename, std::ios::app);
            if (!m_file.is_open()) {
                throw std::runtime_error("FileTransport: failed to open file: " + filename);
            }
        }

        void write(const std::string &formattedEntry) override {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (!m_file.good()) {
                m_file.clear();
                m_file << formattedEntry << '\n';
                if (!m_file.good()) {
                    if (!m_errorReported) {
                        m_errorReported = true;
                        std::fprintf(stderr, "FileTransport: write failed, some log entries may be lost\n");
                    }
                    return;
                }
                // Recovery succeeded
                m_errorReported = false;
            } else {
                m_file << formattedEntry << '\n';
            }
            if (m_autoFlush) {
                m_file << std::flush;
            }
        }

    private:
        std::ofstream m_file;
        std::mutex m_mutex;
        bool m_autoFlush;
        bool m_errorReported = false;
    };
} // namespace minta


// --- lunar_log/transport/stdout_transport.hpp ---

#include <iostream>
#include <mutex>

namespace minta {
    class StdoutTransport : public ITransport {
    public:
        void write(const std::string &formattedEntry) override {
            std::lock_guard<std::mutex> lock(m_mutex);
            std::cout << formattedEntry << '\n' << std::flush;
        }

    private:
        std::mutex m_mutex;
    };
} // namespace minta


// --- lunar_log/sink/sink_interface.hpp ---

#include <memory>
#include <atomic>
#include <mutex>
#include <vector>
#include <set>
#include <string>
#include <functional>

namespace minta {
    class LunarLog;

    using FilterPredicate = std::function<bool(const LogEntry&)>;

    class ISink {
    public:
        ISink() : m_minLevel(LogLevel::TRACE), m_hasFilters(false), m_hasTagFilters(false) {}
        virtual ~ISink() = default;

        virtual void write(const LogEntry &entry) = 0;

        // --- Named sink support ---
        void setSinkName(const std::string& name) { m_sinkName = name; }
        const std::string& getSinkName() const { return m_sinkName; }

        // --- Tag routing ---
        void addOnlyTag(const std::string& tag) {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_onlyTags.insert(tag);
            m_hasTagFilters.store(true, std::memory_order_release);
        }
        void addExceptTag(const std::string& tag) {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_exceptTags.insert(tag);
            m_hasTagFilters.store(true, std::memory_order_release);
        }
        void clearOnlyTags() {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_onlyTags.clear();
            m_hasTagFilters.store(!m_exceptTags.empty(), std::memory_order_release);
        }
        void clearExceptTags() {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_exceptTags.clear();
            m_hasTagFilters.store(!m_onlyTags.empty(), std::memory_order_release);
        }
        void clearTagFilters() {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            m_onlyTags.clear();
            m_exceptTags.clear();
            m_hasTagFilters.store(false, std::memory_order_release);
        }
        std::set<std::string> getOnlyTags() const {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            return m_onlyTags;
        }
        std::set<std::string> getExceptTags() const {
            std::lock_guard<std::mutex> lock(m_tagMutex);
            return m_exceptTags;
        }

        /// Check if this sink should accept an entry based on tag routing.
        /// Rules:
        ///   - If sink has only() tags: accept only if entry has at least one matching tag
        ///   - If sink has except() tags: reject if entry has any matching tag
        ///   - only() takes precedence over except()
        ///   - Entries without tags go to sinks that have NO only() filter
        bool shouldAcceptTags(const std::vector<std::string>& entryTags) const {
            if (!m_hasTagFilters.load(std::memory_order_acquire)) {
                return true;
            }
            std::lock_guard<std::mutex> lock(m_tagMutex);
            if (!m_onlyTags.empty()) {
                // only() mode: entry must have at least one matching tag
                for (const auto& tag : entryTags) {
                    if (m_onlyTags.count(tag)) return true;
                }
                return false; // no matching tag
            }
            if (!m_exceptTags.empty()) {
                // except() mode: reject if entry has any matching tag
                for (const auto& tag : entryTags) {
                    if (m_exceptTags.count(tag)) return false;
                }
            }
            return true;
        }

        void setMinLevel(LogLevel level) {
            m_minLevel.store(level, std::memory_order_relaxed);
        }

        LogLevel getMinLevel() const {
            return m_minLevel.load(std::memory_order_relaxed);
        }

        /// @note The predicate is invoked on the consumer thread while holding an
        ///       internal mutex. It must be fast, non-blocking, and must NOT call
        ///       any filter-modification methods on the same sink (deadlock).
        ///       Filter predicates must capture state by value. Referenced
        ///       objects must outlive the logger.
        void setFilter(FilterPredicate filter) {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filter = std::move(filter);
            m_hasFilters.store(true, std::memory_order_release);
        }

        void clearFilter() {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filter = nullptr;
            m_hasFilters.store(!m_filterRules.empty(), std::memory_order_release);
        }

        void addFilterRule(FilterRule rule) {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filterRules.push_back(std::move(rule));
            m_hasFilters.store(true, std::memory_order_release);
        }

        void addFilterRules(std::vector<FilterRule> rules) {
            if (rules.empty()) return;
            std::lock_guard<std::mutex> lock(m_filterMutex);
            for (size_t i = 0; i < rules.size(); ++i) {
                m_filterRules.push_back(std::move(rules[i]));
            }
            m_hasFilters.store(true, std::memory_order_release);
        }

        void addFilterRule(const std::string& ruleStr) {
            FilterRule rule = FilterRule::parse(ruleStr);
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filterRules.push_back(std::move(rule));
            m_hasFilters.store(true, std::memory_order_release);
        }

        void clearFilterRules() {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filterRules.clear();
            m_hasFilters.store(static_cast<bool>(m_filter), std::memory_order_release);
        }

        void clearAllFilters() {
            std::lock_guard<std::mutex> lock(m_filterMutex);
            m_filter = nullptr;
            m_filterRules.clear();
            m_hasFilters.store(false, std::memory_order_release);
        }

        /// Set a per-sink locale for culture-specific formatting.
        /// Forwards to the sink's formatter.
        void setLocale(const std::string& locale) {
            IFormatter* fmt = formatter();
            if (fmt) fmt->setLocale(locale);
        }

        std::string getLocale() const {
            IFormatter* fmt = formatter();
            return fmt ? fmt->getLocale() : std::string();
        }

        bool passesFilter(const LogEntry& entry) const {
            if (entry.level < m_minLevel.load(std::memory_order_relaxed)) {
                return false;
            }

            if (!m_hasFilters.load(std::memory_order_acquire)) {
                return true;
            }

            FilterPredicate filterCopy;
            std::vector<FilterRule> rulesCopy;
            {
                std::lock_guard<std::mutex> lock(m_filterMutex);
                filterCopy = m_filter;
                rulesCopy = m_filterRules;
            }

            if (filterCopy && !filterCopy(entry)) {
                return false;
            }
            for (const auto& rule : rulesCopy) {
                if (!rule.evaluate(entry)) {
                    return false;
                }
            }
            return true;
        }

    protected:
        void setFormatter(std::unique_ptr<IFormatter> formatter) {
            m_formatter = std::move(formatter);
        }

        void setTransport(std::unique_ptr<ITransport> transport) {
            m_transport = std::move(transport);
        }

        IFormatter* formatter() const { return m_formatter.get(); }
        ITransport* transport() const { return m_transport.get(); }

    private:
        std::unique_ptr<IFormatter> m_formatter;
        std::unique_ptr<ITransport> m_transport;
        std::atomic<LogLevel> m_minLevel;
        std::atomic<bool> m_hasFilters;
        mutable std::mutex m_filterMutex;
        FilterPredicate m_filter;
        std::vector<FilterRule> m_filterRules;

        std::string m_sinkName;
        std::atomic<bool> m_hasTagFilters;
        mutable std::mutex m_tagMutex;
        std::set<std::string> m_onlyTags;
        std::set<std::string> m_exceptTags;

        friend class LunarLog;
        friend class LoggerConfiguration;
        friend class SinkProxy;
    };

    class BaseSink : public ISink {
    public:
        void write(const LogEntry &entry) override {
            IFormatter* fmt = formatter();
            ITransport* tp = transport();
            if (fmt && tp) {
                tp->write(fmt->format(entry));
            }
        }
    };
} // namespace minta


// --- lunar_log/sink/console_sink.hpp ---


namespace minta {
    class ConsoleSink : public BaseSink {
    public:
        ConsoleSink() {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<StdoutTransport>());
        }
    };
} // namespace minta


// --- lunar_log/sink/file_sink.hpp ---


namespace minta {
    class FileSink : public BaseSink {
    public:
        explicit FileSink(const std::string &filename) {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<FileTransport>(filename));
        }
    };
} // namespace minta


// --- lunar_log/sink/rolling_file_sink.hpp ---

#include <fstream>
#include <mutex>
#include <string>
#include <cstdio>
#include <ctime>
#include <algorithm>
#include <climits>
#include <deque>
#include <vector>

#include <sys/stat.h>
#ifdef _MSC_VER
#include <direct.h>
#include <io.h>
#else
#include <unistd.h>
#include <dirent.h>
#endif

namespace minta {

    class RollingFileSink : public ISink {
    public:
        explicit RollingFileSink(const RollingPolicy& policy)
            : m_policy(policy)
            , m_currentSize(0)
            , m_lastPeriod()
            , m_fileOpen(false)
            , m_sizeRollIndex(0)
            , m_lastPeriodCheckTime(0)
        {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            splitBasePath();
        }

        ~RollingFileSink() {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_fileOpen) {
                m_file.close();
                m_fileOpen = false;
            }
        }

        /// Set the formatter type. Must be called during initialization only,
        /// before any calls to write(). Not thread-safe with concurrent logging.
        template<typename FormatterType>
        void useFormatter() {
            setFormatter(detail::make_unique<FormatterType>());
        }

        void write(const LogEntry& entry) override {
            IFormatter* fmt = formatter();
            if (!fmt) return;
            std::string formatted = fmt->format(entry);

            std::lock_guard<std::mutex> lock(m_mutex);
            ensureOpen();
            if (needsRotation()) {
                rotate();
            }
            writeToFile(formatted);
        }

    private:
        void splitBasePath() {
            const std::string& path = m_policy.basePath();
            size_t dotPos = path.rfind('.');
            size_t slashPos = path.find_last_of("/\\");
            if (dotPos != std::string::npos && (slashPos == std::string::npos || dotPos > slashPos)) {
                m_stem = path.substr(0, dotPos);
                m_ext = path.substr(dotPos);
            } else {
                m_stem = path;
                m_ext.clear();
            }
        }

        static bool mkdirRecursive(const std::string& path) {
            if (path.empty()) return true;
            struct stat st;
            if (stat(path.c_str(), &st) == 0) return true;

            size_t slashPos = path.find_last_of("/\\");
            if (slashPos != std::string::npos && slashPos > 0) {
                if (!mkdirRecursive(path.substr(0, slashPos))) return false;
            }
#ifdef _MSC_VER
            return _mkdir(path.c_str()) == 0 || errno == EEXIST;
#else
            return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
#endif
        }

        void ensureDirectoryExists() {
            const std::string& path = m_policy.basePath();
            size_t slashPos = path.find_last_of("/\\");
            if (slashPos != std::string::npos && slashPos > 0) {
                mkdirRecursive(path.substr(0, slashPos));
            }
        }

        void ensureOpen() {
            if (m_fileOpen) return;
            ensureDirectoryExists();
            m_file.open(m_policy.basePath(), std::ios::app | std::ios::binary);
            if (!m_file.is_open()) {
                std::fprintf(stderr, "RollingFileSink: failed to open file: %s\n",
                             m_policy.basePath().c_str());
                return;
            }
            m_fileOpen = true;
            m_currentSize = getFileSize(m_policy.basePath());
            if (m_policy.rollInterval() != RollInterval::None) {
                m_lastPeriodCheckTime = std::time(nullptr);
                m_lastPeriod = currentPeriodString(m_lastPeriodCheckTime);
            }
            discoverExistingRolledFiles();
        }

        void writeToFile(const std::string& formatted) {
            if (!m_fileOpen) return;
            m_file << formatted << '\n' << std::flush;
            m_currentSize += formatted.size() + 1;
        }

        bool needsRotation() {
            if (!m_fileOpen) return false;
            if (m_policy.maxSizeBytes() > 0 && m_currentSize >= m_policy.maxSizeBytes()) {
                return true;
            }
            if (m_policy.rollInterval() != RollInterval::None) {
                std::time_t now = std::time(nullptr);
                if (now != m_lastPeriodCheckTime) {
                    m_lastPeriodCheckTime = now;
                    std::string current = currentPeriodString(now);
                    if (current != m_lastPeriod) return true;
                }
            }
            return false;
        }

        void rotate() {
            m_file.close();
            m_fileOpen = false;

            std::string rolledName = buildRolledName();
            if (std::rename(m_policy.basePath().c_str(), rolledName.c_str()) == 0) {
                m_rolledFiles.push_back(rolledName);
            } else {
                std::fprintf(stderr, "RollingFileSink: failed to rename %s to %s\n",
                             m_policy.basePath().c_str(), rolledName.c_str());
            }

            if (m_policy.rollInterval() != RollInterval::None) {
                m_lastPeriodCheckTime = std::time(nullptr);
                m_lastPeriod = currentPeriodString(m_lastPeriodCheckTime);
            }

            cleanup();

            m_file.open(m_policy.basePath(), std::ios::app | std::ios::binary);
            if (m_file.is_open()) {
                m_fileOpen = true;
                m_currentSize = getFileSize(m_policy.basePath());
            }
        }

        std::string buildRolledName() {
            bool hasSizePolicy = m_policy.maxSizeBytes() > 0;
            bool hasTimePolicy = m_policy.rollInterval() != RollInterval::None;

            if (hasTimePolicy && hasSizePolicy) {
                std::string period = m_lastPeriod;
                if (period != m_lastRolledPeriod) {
                    m_sizeRollIndex = 0;
                    m_lastRolledPeriod = period;
                }
                m_sizeRollIndex++;
                char idx[16];
                std::snprintf(idx, sizeof(idx), "%03u", m_sizeRollIndex);
                return m_stem + "." + period + "." + idx + m_ext;
            }
            if (hasTimePolicy) {
                // Time-only mode: one file per period. If rotation triggers twice
                // in the same period, the second rename overwrites the first — by
                // design, since time-only means at most one rolled file per period.
                return m_stem + "." + m_lastPeriod + m_ext;
            }
            m_sizeRollIndex++;
            char idx[16];
            std::snprintf(idx, sizeof(idx), "%03u", m_sizeRollIndex);
            return m_stem + "." + idx + m_ext;
        }

        std::string currentPeriodString(std::time_t now) const {
            std::tm tmBuf;
#ifdef _MSC_VER
            localtime_s(&tmBuf, &now);
#else
            localtime_r(&now, &tmBuf);
#endif
            char buf[32];
            if (m_policy.rollInterval() == RollInterval::Daily) {
                std::strftime(buf, sizeof(buf), "%Y-%m-%d", &tmBuf);
            } else {
                std::strftime(buf, sizeof(buf), "%Y-%m-%d.%H", &tmBuf);
            }
            return std::string(buf);
        }

        static std::uint64_t getFileSize(const std::string& path) {
            struct stat st;
            if (stat(path.c_str(), &st) != 0) return 0;
            return static_cast<std::uint64_t>(st.st_size);
        }

        static std::time_t getFileMTime(const std::string& path) {
            struct stat st;
            if (stat(path.c_str(), &st) != 0) return 0;
            return st.st_mtime;
        }

        static std::vector<std::string> listDirectory(const std::string& dirPath) {
            std::vector<std::string> entries;
#ifdef _MSC_VER
            struct _finddata_t fileinfo;
            std::string pattern = dirPath + "/*";
            intptr_t handle = _findfirst(pattern.c_str(), &fileinfo);
            if (handle == -1) return entries;
            do {
                std::string name = fileinfo.name;
                if (name != "." && name != "..") {
                    entries.push_back(name);
                }
            } while (_findnext(handle, &fileinfo) == 0);
            _findclose(handle);
#else
            DIR* dir = opendir(dirPath.c_str());
            if (!dir) return entries;
            struct dirent* ent;
            while ((ent = readdir(dir)) != nullptr) {
                std::string name = ent->d_name;
                if (name != "." && name != "..") {
                    entries.push_back(name);
                }
            }
            closedir(dir);
#endif
            return entries;
        }

        static bool allDigits(const char* s, size_t n) {
            if (n == 0) return false;
            for (size_t i = 0; i < n; ++i) {
                if (s[i] < '0' || s[i] > '9') return false;
            }
            return true;
        }

        /// Check if string matches YYYY-MM-DD pattern.
        /// @pre strlen(s) >= 10
        static bool isDatePattern(const char* s) {
            return s[0] >= '0' && s[0] <= '9' && s[1] >= '0' && s[1] <= '9' &&
                   s[2] >= '0' && s[2] <= '9' && s[3] >= '0' && s[3] <= '9' &&
                   s[4] == '-' &&
                   s[5] >= '0' && s[5] <= '9' && s[6] >= '0' && s[6] <= '9' &&
                   s[7] == '-' &&
                   s[8] >= '0' && s[8] <= '9' && s[9] >= '0' && s[9] <= '9';
        }

        static bool isValidRolledMiddle(const std::string& mid) {
            if (mid.empty()) return false;
            const char* s = mid.c_str();
            size_t len = mid.size();

            // Pure digits (size index: "001", "002", etc.)
            if (allDigits(s, len)) return true;

            // Must start with date YYYY-MM-DD (10 chars)
            if (len < 10 || !isDatePattern(s)) return false;
            if (len == 10) return true;

            // Dot must follow the date
            if (s[10] != '.') return false;
            const char* rest = s + 11;
            size_t restLen = len - 11;
            if (restLen == 0) return false;

            // YYYY-MM-DD.digits (daily+size or hourly time-only)
            if (allDigits(rest, restLen)) return true;

            // YYYY-MM-DD.HH.NNN (hourly+size)
            if (restLen > 3 && rest[0] >= '0' && rest[0] <= '9' &&
                rest[1] >= '0' && rest[1] <= '9' && rest[2] == '.') {
                return allDigits(rest + 3, restLen - 3);
            }
            return false;
        }

        static unsigned int parseDigits(const char* s) {
            unsigned int result = 0;
            while (*s >= '0' && *s <= '9') {
                unsigned int digit = static_cast<unsigned int>(*s - '0');
                if (result > (UINT_MAX - digit) / 10) return UINT_MAX;
                result = result * 10 + digit;
                ++s;
            }
            return result;
        }

        void discoverExistingRolledFiles() {
            m_rolledFiles.clear();
            m_sizeRollIndex = 0;

            // Determine directory and stem filename
            std::string dir;
            std::string stemFilename;
            {
                size_t slashPos = m_stem.find_last_of("/\\");
                if (slashPos != std::string::npos) {
                    dir = m_stem.substr(0, slashPos);
                    stemFilename = m_stem.substr(slashPos + 1);
                } else {
                    dir = ".";
                    stemFilename = m_stem;
                }
            }

            std::string prefix = stemFilename + ".";
            std::vector<std::string> entries = listDirectory(dir);

            // Collect matching rolled files with mtime for sorting
            struct RolledEntry {
                std::string path;
                std::string middle;
                std::time_t mtime;
            };
            std::vector<RolledEntry> found;

            for (size_t i = 0; i < entries.size(); ++i) {
                const std::string& name = entries[i];

                // Must start with stem prefix (e.g. "roll_size.")
                if (name.size() <= prefix.size() ||
                    name.compare(0, prefix.size(), prefix) != 0) {
                    continue;
                }

                // Must end with extension (if any) and extract middle part
                std::string middle;
                if (!m_ext.empty()) {
                    if (name.size() <= prefix.size() + m_ext.size()) continue;
                    if (name.compare(name.size() - m_ext.size(),
                                     m_ext.size(), m_ext) != 0) continue;
                    middle = name.substr(prefix.size(),
                                         name.size() - prefix.size() - m_ext.size());
                } else {
                    middle = name.substr(prefix.size());
                }

                if (middle.empty()) continue;
                if (!isValidRolledMiddle(middle)) continue;

                // Reconstruct full path matching buildRolledName format
                std::string fullPath = m_stem + "." + middle + m_ext;

                RolledEntry re;
                re.path = fullPath;
                re.middle = middle;
                re.mtime = getFileMTime(fullPath);
                found.push_back(re);
            }

            // Sort by mtime (oldest first) for correct cleanup ordering
            std::sort(found.begin(), found.end(),
                      [](const RolledEntry& a, const RolledEntry& b) {
                          return a.mtime < b.mtime;
                      });

            // Populate m_rolledFiles and recover m_sizeRollIndex
            bool hasTimePolicy = m_policy.rollInterval() != RollInterval::None;
            bool hasSizePolicy = m_policy.maxSizeBytes() > 0;

            for (size_t i = 0; i < found.size(); ++i) {
                m_rolledFiles.push_back(found[i].path);

                if (hasSizePolicy) {
                    unsigned int idx = 0;
                    const std::string& mid = found[i].middle;

                    if (!hasTimePolicy) {
                        // Size only: entire middle is the index
                        idx = parseDigits(mid.c_str());
                    } else if (!m_lastPeriod.empty() &&
                               mid.size() > m_lastPeriod.size() + 1 &&
                               mid.compare(0, m_lastPeriod.size(), m_lastPeriod) == 0 &&
                               mid[m_lastPeriod.size()] == '.') {
                        // Hybrid: period.NNN — extract NNN for current period
                        idx = parseDigits(mid.c_str() + m_lastPeriod.size() + 1);
                    }

                    if (idx > m_sizeRollIndex) {
                        m_sizeRollIndex = idx;
                    }
                }
            }
        }

        void cleanup() {
            bool hasMaxFiles = m_policy.maxFilesCount() > 0;
            bool hasMaxTotalSize = m_policy.maxTotalSizeBytes() > 0;
            if (!hasMaxFiles && !hasMaxTotalSize) return;

            if (hasMaxFiles) {
                while (m_rolledFiles.size() > m_policy.maxFilesCount()) {
                    std::remove(m_rolledFiles.front().c_str());
                    m_rolledFiles.pop_front();
                }
            }

            if (hasMaxTotalSize) {
                std::vector<std::uint64_t> sizes;
                std::uint64_t total = 0;
                for (size_t i = 0; i < m_rolledFiles.size(); ++i) {
                    std::uint64_t sz = getFileSize(m_rolledFiles[i]);
                    sizes.push_back(sz);
                    total += sz;
                }
                // sizes[removeIdx] corresponds to the current front of m_rolledFiles
                // because we increment removeIdx in lockstep with pop_front
                size_t removeIdx = 0;
                while (removeIdx < m_rolledFiles.size() && total > m_policy.maxTotalSizeBytes()) {
                    total -= sizes[removeIdx];
                    std::remove(m_rolledFiles.front().c_str());
                    m_rolledFiles.pop_front();
                    removeIdx++;
                }
            }
        }

        RollingPolicy m_policy;
        std::string m_stem;
        std::string m_ext;
        std::ofstream m_file;
        std::mutex m_mutex;
        std::uint64_t m_currentSize;
        std::string m_lastPeriod;
        std::string m_lastRolledPeriod;
        bool m_fileOpen;
        unsigned int m_sizeRollIndex;
        std::time_t m_lastPeriodCheckTime;
        std::deque<std::string> m_rolledFiles;
    };

} // namespace minta


// --- lunar_log/log_manager.hpp ---

#include <vector>
#include <memory>
#include <atomic>
#include <functional>
#include <mutex>
#include <stdexcept>
#include <unordered_map>
#include <string>

namespace minta {
    class LogManager {
    public:
        LogManager() : m_loggingStarted(false), m_nextAutoIndex(0) {}

        /// Move constructor — used by the builder pattern.
        /// Safe only when no logging has started (no concurrent access).
        LogManager(LogManager&& other) noexcept
            : m_sinks(std::move(other.m_sinks))
            , m_loggingStarted(other.m_loggingStarted.load(std::memory_order_relaxed))
            , m_sinkNames(std::move(other.m_sinkNames))
            , m_nextAutoIndex(other.m_nextAutoIndex)
        {
            other.m_loggingStarted.store(false, std::memory_order_relaxed);
            other.m_nextAutoIndex = 0;
        }

        LogManager& operator=(LogManager&&) = delete;
        LogManager(const LogManager&) = delete;
        LogManager& operator=(const LogManager&) = delete;

        // Add all sinks before any log calls are made.
        //
        // There is a TOCTOU race between the m_loggingStarted check and the
        // push_back: two threads could both pass the check concurrently. This
        // is acceptable because the documented contract requires all sinks to
        // be added before any log calls, so well-behaved callers never hit
        // this window. The atomic check is a best-effort safety net, not a
        // thread-safe gate.
        void addSink(std::unique_ptr<ISink> sink) {
            if (m_loggingStarted.load(std::memory_order_acquire)) {
                throw std::logic_error("Cannot add sinks after logging has started");
            }
            // Auto-name unnamed sinks, skipping collisions with user-named sinks
            std::string autoName;
            do {
                autoName = "sink_" + std::to_string(m_nextAutoIndex++);
            } while (m_sinkNames.count(autoName) > 0);
            sink->setSinkName(autoName);
            m_sinks.push_back(std::move(sink));
            m_sinkNames[autoName] = m_sinks.size() - 1;
        }

        /// Add a named sink. Throws std::invalid_argument if name is duplicate.
        void addSink(const std::string& name, std::unique_ptr<ISink> sink) {
            if (m_loggingStarted.load(std::memory_order_acquire)) {
                throw std::logic_error("Cannot add sinks after logging has started");
            }
            if (m_sinkNames.count(name)) {
                throw std::invalid_argument("Duplicate sink name: " + name);
            }
            sink->setSinkName(name);
            m_sinks.push_back(std::move(sink));
            m_sinkNames[name] = m_sinks.size() - 1;
            m_nextAutoIndex++; // keep auto index advancing
        }

        /// Get sink index by name. Throws std::invalid_argument if not found.
        size_t getSinkIndex(const std::string& name) const {
            auto it = m_sinkNames.find(name);
            if (it == m_sinkNames.end()) {
                throw std::invalid_argument("Unknown sink name: " + name);
            }
            return it->second;
        }

        bool isLoggingStarted() const {
            return m_loggingStarted.load(std::memory_order_acquire);
        }

        /// Get sink pointer by index.
        ISink* getSink(size_t index) {
            requireValidIndex(index);
            return m_sinks[index].get();
        }

        const ISink* getSink(size_t index) const {
            requireValidIndex(index);
            return m_sinks[index].get();
        }

        /// Filter pipeline: global min level (caller) -> global predicate -> global DSL rules
        ///                -> per-sink tag routing -> per-sink min level -> per-sink predicate -> per-sink DSL rules.
        void log(const LogEntry &entry,
                 const FilterPredicate& globalFilter,
                 const std::vector<FilterRule>& globalFilterRules,
                 std::mutex& globalFilterMutex,
                 const std::atomic<bool>& hasGlobalFilters) {
            if (!m_loggingStarted.load(std::memory_order_relaxed)) {
                m_loggingStarted.store(true, std::memory_order_release);
            }

            if (hasGlobalFilters.load(std::memory_order_acquire)) {
                try {
                    std::lock_guard<std::mutex> lock(globalFilterMutex);
                    if (globalFilter && !globalFilter(entry)) return;
                    for (const auto& rule : globalFilterRules) {
                        if (!rule.evaluate(entry)) return;
                    }
                } catch (...) {
                    // Bad global filter — fail-open: let the entry through
                    // rather than silently dropping it for all sinks.
                }
            }

            for (const auto &sink : m_sinks) {
                try {
                    if (!sink->shouldAcceptTags(entry.tags)) continue;
                    if (sink->passesFilter(entry)) {
                        sink->write(entry);
                    }
                } catch (...) {
                    // One bad sink must not prevent subsequent sinks from running.
                }
            }
        }

        void setSinkLevel(size_t index, LogLevel level) {
            requireValidIndex(index);
            m_sinks[index]->setMinLevel(level);
        }

        void setSinkFilter(size_t index, FilterPredicate filter) {
            requireValidIndex(index);
            m_sinks[index]->setFilter(std::move(filter));
        }

        void clearSinkFilter(size_t index) {
            requireValidIndex(index);
            m_sinks[index]->clearFilter();
        }

        void addSinkFilterRule(size_t index, const std::string& ruleStr) {
            requireValidIndex(index);
            m_sinks[index]->addFilterRule(ruleStr);
        }

        void clearSinkFilterRules(size_t index) {
            requireValidIndex(index);
            m_sinks[index]->clearFilterRules();
        }

        void clearAllSinkFilters(size_t index) {
            requireValidIndex(index);
            m_sinks[index]->clearAllFilters();
        }

        void setSinkLocale(size_t index, const std::string& locale) {
            requireValidIndex(index);
            m_sinks[index]->setLocale(locale);
        }

    private:
        void requireValidIndex(size_t index) const {
            if (index >= m_sinks.size()) {
                throw std::out_of_range("Sink index out of range");
            }
        }

        std::vector<std::unique_ptr<ISink> > m_sinks;
        std::atomic<bool> m_loggingStarted;
        std::unordered_map<std::string, size_t> m_sinkNames;
        size_t m_nextAutoIndex;
        // NOTE: The global filter state (predicate, DSL rules, mutex) lives in
        // LunarLog and is passed into log() by reference.  A future cleanup
        // could bundle these into a GlobalFilterConfig struct owned here.
    };
} // namespace minta


// --- lunar_log/log_source.hpp ---

#include <atomic>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <type_traits>
#include <set>
#include <functional>
#include <map>
#include <unordered_map>
#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <cstdio>
#include <climits>
#include <cmath>
#include <sstream>
#include <list>

namespace minta {

    /// Tag type for disambiguating named-sink overloads from unnamed ones (H3).
    /// Use: logger.addSink<ConsoleSink>(named("console"))
    /// This prevents SFINAE ambiguity when SinkType is constructible from std::string.
    struct SinkName {
        std::string value;
        explicit SinkName(const std::string& n) : value(n) {}
        explicit SinkName(const char* n) : value(n) {}
    };

    /// Convenience factory for SinkName.
    inline SinkName named(const std::string& name) { return SinkName(name); }
    inline SinkName named(const char* name) { return SinkName(name); }

namespace detail {
    /// Parse [bracketed] tag prefixes from a message template.
    /// Tags must be at the start, contain only alphanumeric, hyphens, underscores.
    /// Brackets must be immediately adjacent: "[a][b] msg" parses two tags,
    /// but "[a] [b] msg" only parses one because the space breaks the scan.
    /// Returns the tags and the remaining message (stripped of tag prefixes).
    inline std::pair<std::vector<std::string>, std::string> parseTags(const std::string& messageTemplate) {
        std::vector<std::string> tags;
        size_t pos = 0;
        while (pos < messageTemplate.size() && messageTemplate[pos] == '[') {
            size_t close = messageTemplate.find(']', pos + 1);
            if (close == std::string::npos) break;
            std::string tag = messageTemplate.substr(pos + 1, close - pos - 1);
            // Validate tag: alphanumeric + hyphens + underscores only
            bool valid = !tag.empty();
            for (size_t i = 0; i < tag.size() && valid; ++i) {
                char c = tag[i];
                if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') || c == '-' || c == '_')) {
                    valid = false;
                }
            }
            if (!valid) break;
            tags.push_back(std::move(tag));
            pos = close + 1;
        }
        // Fast path: no tags found — pair construction still copies
        // messageTemplate, but avoids the substr + whitespace-strip work.
        if (tags.empty()) {
            return {tags, messageTemplate};
        }
        // Strip leading whitespace (spaces and tabs) after tags
        while (pos < messageTemplate.size() && (messageTemplate[pos] == ' ' || messageTemplate[pos] == '\t')) ++pos;
        return {tags, messageTemplate.substr(pos)};
    }
    using ScopeFrame = std::vector<std::pair<std::string, std::string>>;
    using ScopeStack = std::list<ScopeFrame>;
    using ScopeFrameIter = ScopeStack::iterator;

    inline ScopeStack& threadScopeStack() {
        thread_local ScopeStack stack;
        return stack;
    }

} // namespace detail

    class LoggerConfiguration;
    class LogScope;

    class LunarLog {
    public:
        explicit LunarLog(LogLevel minLevel = LogLevel::INFO, bool addDefaultConsoleSink = true)
            : m_minLevel(minLevel)
            , m_isRunning(true)
            , m_rateLimitWindowStart(std::chrono::steady_clock::now().time_since_epoch().count())
            , m_logCount(0)
            , m_captureSourceLocation(false)
            , m_hasCustomContext(false)
            , m_sinkWriteInProgress(false)
            , m_templateCacheSize(128)
            , m_hasGlobalFilters(false)
            , m_rateLimitMaxLogs(1000)
            , m_rateLimitWindowMs(1000)
            , m_threadStarted(false) {
            if (addDefaultConsoleSink) {
                addSink<ConsoleSink>();
            }
            ensureProcessingThread();
        }

        // NOTE: LunarLog must outlive all logging threads. Destroying LunarLog
        // while other threads are still calling log methods is undefined behavior.
        ~LunarLog() noexcept {
            if (m_threadStarted.load(std::memory_order_acquire)) {
                flush();
                m_isRunning = false;
                m_logCV.notify_one();
                if (m_logThread.joinable()) {
                    m_logThread.join();
                }
            }
        }

        LunarLog(const LunarLog &) = delete;
        LunarLog &operator=(const LunarLog &) = delete;

        /// Move constructor — only safe before logging starts (used by builder).
        LunarLog(LunarLog &&other) noexcept
            : m_minLevel(other.m_minLevel.load(std::memory_order_relaxed))
            , m_isRunning(true)
            , m_rateLimitWindowStart(other.m_rateLimitWindowStart.load(std::memory_order_relaxed))
            , m_logCount(0)
            , m_logManager(std::move(other.m_logManager))
            , m_customContext(std::move(other.m_customContext))
            , m_captureSourceLocation(other.m_captureSourceLocation.load(std::memory_order_relaxed))
            , m_hasCustomContext(other.m_hasCustomContext.load(std::memory_order_relaxed))
            , m_sinkWriteInProgress(false)
            , m_templateCache(std::move(other.m_templateCache))
            , m_templateCacheSize(other.m_templateCacheSize)
            , m_hasGlobalFilters(other.m_hasGlobalFilters.load(std::memory_order_relaxed))
            , m_globalFilter(std::move(other.m_globalFilter))
            , m_globalFilterRules(std::move(other.m_globalFilterRules))
            , m_hasLocale(other.m_hasLocale.load(std::memory_order_relaxed))
            , m_locale(std::move(other.m_locale))
            , m_enrichers(std::move(other.m_enrichers))
            , m_hasEnrichers(other.m_hasEnrichers.load(std::memory_order_relaxed))
            , m_rateLimitMaxLogs(other.m_rateLimitMaxLogs)
            , m_rateLimitWindowMs(other.m_rateLimitWindowMs)
            , m_threadStarted(false)
        {
            other.m_isRunning.store(false, std::memory_order_relaxed);
        }

        LunarLog &operator=(LunarLog &&) = delete;

        /// Create a fluent builder for configuring a new LunarLog instance.
        static LoggerConfiguration configure();

        void setMinLevel(LogLevel level) {
            m_minLevel.store(level, std::memory_order_relaxed);
        }

        LogLevel getMinLevel() const {
            return m_minLevel.load(std::memory_order_relaxed);
        }

        void setCaptureSourceLocation(bool capture) {
            m_captureSourceLocation.store(capture, std::memory_order_relaxed);
        }

        bool getCaptureSourceLocation() const {
            return m_captureSourceLocation.load(std::memory_order_relaxed);
        }

        /// Set rate-limit parameters (max messages per window).
        /// Must be called during setup, before the first log call.
        /// Corresponds to LoggerConfiguration::rateLimit() in the builder API.
        void setRateLimit(size_t maxLogs, std::chrono::milliseconds window) {
            m_rateLimitMaxLogs = maxLogs;
            m_rateLimitWindowMs = static_cast<long long>(window.count());
        }

        /// @deprecated Use setCaptureSourceLocation instead.
        inline void setCaptureContext(bool capture) {
            setCaptureSourceLocation(capture);
        }

        /// @deprecated Use getCaptureSourceLocation instead.
        inline bool getCaptureContext() const {
            return getCaptureSourceLocation();
        }

        /// @warning Do not call flush() from within a sink write() implementation.
        ///          flush() acquires the queue mutex and waits for sink writes to
        ///          complete, so calling it from inside write() will deadlock.
        void flush() {
            if (!m_threadStarted.load(std::memory_order_acquire)) return;
            std::unique_lock<std::mutex> lock(m_queueMutex);
            m_flushCV.wait(lock, [this] {
                return m_logQueue.empty() && !m_sinkWriteInProgress.load(std::memory_order_relaxed);
            });
        }

        /// Add an unnamed sink (auto-named "sink_0", "sink_1", etc.).
        /// SFINAE: only viable when SinkType is constructible from Args.
        template<typename SinkType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(Args &&... args) {
            m_logManager.addSink(detail::make_unique<SinkType>(std::forward<Args>(args)...));
        }

        /// Add an unnamed sink with a custom formatter.
        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_base_of<IFormatter, FormatterType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(std::move(sink));
        }

        /// Add a named sink: addSink<ConsoleSink>(named("console"))
        /// Uses SinkName tag type to avoid SFINAE ambiguity with unnamed overloads.
        template<typename SinkType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const SinkName& sinkName, Args &&... args) {
            m_logManager.addSink(sinkName.value, detail::make_unique<SinkType>(std::forward<Args>(args)...));
        }

        /// Add a named sink with a custom formatter:
        /// addSink<FileSink, JsonFormatter>(named("json-out"), "app.jsonl")
        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_base_of<IFormatter, FormatterType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const SinkName& sinkName, Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(sinkName.value, std::move(sink));
        }

        /// Convenience: addSink<SinkType>("name", args...) still works via
        /// const std::string& overload. This is unambiguous because SinkName
        /// is explicit-only from string, so implicit conversions go here.
        template<typename SinkType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const std::string& name, Args &&... args) {
            m_logManager.addSink(name, detail::make_unique<SinkType>(std::forward<Args>(args)...));
        }

        /// Named sink with formatter via string name.
        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<
            std::is_base_of<ISink, SinkType>::value &&
            std::is_base_of<IFormatter, FormatterType>::value &&
            std::is_constructible<SinkType, Args...>::value
        >::type
        addSink(const std::string& name, Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(name, std::move(sink));
        }

        void addCustomSink(std::unique_ptr<ISink> sink) {
            m_logManager.addSink(std::move(sink));
        }

        void addCustomSink(const std::string& name, std::unique_ptr<ISink> sink) {
            m_logManager.addSink(name, std::move(sink));
        }

        /// Get a SinkProxy for configuring a named sink.
        /// Throws std::invalid_argument if name is not found.
        SinkProxy sink(const std::string& name);

        template<typename... Args>
        void log(LogLevel level, const std::string &messageTemplate, const Args &... args) {
            logInternal(level, "", 0, "", messageTemplate, args...);
        }

        template<typename... Args>
        void logWithSourceLocation(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            logInternal(level, file, line, function, messageTemplate, args...);
        }

        /// @deprecated Use logWithSourceLocation instead.
        template<typename... Args>
        void logWithContext(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            logWithSourceLocation(level, file, line, function, messageTemplate, args...);
        }

        template<typename... Args>
        void logWithSourceLocationAndException(LogLevel level, const char* file, int line, const char* function,
                                               const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            logInternalWithException(level, file, line, function, ex, messageTemplate, args...);
        }

        template<typename... Args>
        void trace(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::TRACE, messageTemplate, args...);
        }

        template<typename... Args>
        void debug(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::DEBUG, messageTemplate, args...);
        }

        template<typename... Args>
        void info(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::INFO, messageTemplate, args...);
        }

        template<typename... Args>
        void warn(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::WARN, messageTemplate, args...);
        }

        template<typename... Args>
        void error(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::ERROR, messageTemplate, args...);
        }

        template<typename... Args>
        void fatal(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::FATAL, messageTemplate, args...);
        }

        template<typename... Args>
        void log(LogLevel level, const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            logInternalWithException(level, "", 0, "", ex, messageTemplate, args...);
        }

        void log(LogLevel level, const std::exception& ex) {
            logInternalWithException(level, "", 0, "", ex, detail::safeWhat(ex));
        }

        template<typename... Args>
        void trace(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::TRACE, ex, messageTemplate, args...);
        }
        void trace(const std::exception& ex) { log(LogLevel::TRACE, ex); }

        template<typename... Args>
        void debug(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::DEBUG, ex, messageTemplate, args...);
        }
        void debug(const std::exception& ex) { log(LogLevel::DEBUG, ex); }

        template<typename... Args>
        void info(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::INFO, ex, messageTemplate, args...);
        }
        void info(const std::exception& ex) { log(LogLevel::INFO, ex); }

        template<typename... Args>
        void warn(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::WARN, ex, messageTemplate, args...);
        }
        void warn(const std::exception& ex) { log(LogLevel::WARN, ex); }

        template<typename... Args>
        void error(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::ERROR, ex, messageTemplate, args...);
        }
        void error(const std::exception& ex) { log(LogLevel::ERROR, ex); }

        template<typename... Args>
        void fatal(const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::FATAL, ex, messageTemplate, args...);
        }
        void fatal(const std::exception& ex) { log(LogLevel::FATAL, ex); }

        /// @note The predicate is invoked on the consumer thread while holding an
        ///       internal mutex. It must be fast, non-blocking, and must NOT call
        ///       any filter-modification methods on the same logger (deadlock).
        ///       Filter predicates must capture state by value. Referenced
        ///       objects must outlive the logger.
        ///       If the global predicate throws, the entry is let through
        ///       (fail-open) rather than silently dropped for all sinks.
        void setFilter(FilterPredicate filter) {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilter = std::move(filter);
            m_hasGlobalFilters.store(true, std::memory_order_release);
        }

        void clearFilter() {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilter = nullptr;
            m_hasGlobalFilters.store(!m_globalFilterRules.empty(), std::memory_order_release);
        }

        void addFilterRule(const std::string& ruleStr) {
            FilterRule rule = FilterRule::parse(ruleStr);
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilterRules.push_back(std::move(rule));
            m_hasGlobalFilters.store(true, std::memory_order_release);
        }

        void clearFilterRules() {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilterRules.clear();
            m_hasGlobalFilters.store(static_cast<bool>(m_globalFilter), std::memory_order_release);
        }

        void clearAllFilters() {
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            m_globalFilter = nullptr;
            m_globalFilterRules.clear();
            m_hasGlobalFilters.store(false, std::memory_order_release);
        }

        /// Add compact filter rules (space-separated, AND-combined).
        /// Syntax: "WARN+", "~keyword", "!~keyword", "ctx:key", "ctx:key=val",
        /// "tpl:pattern", "!tpl:pattern". See Compact-Filter wiki page.
        /// Thread-safe — acquires global filter mutex.
        void filter(const std::string& compactExpr) {
            std::vector<FilterRule> rules = detail::parseCompactFilter(compactExpr);
            std::lock_guard<std::mutex> lock(m_globalFilterMutex);
            for (size_t i = 0; i < rules.size(); ++i) {
                m_globalFilterRules.push_back(std::move(rules[i]));
            }
            if (!m_globalFilterRules.empty()) {
                m_hasGlobalFilters.store(true, std::memory_order_release);
            }
        }

        void setSinkLevel(size_t sinkIndex, LogLevel level) {
            m_logManager.setSinkLevel(sinkIndex, level);
        }

        void setSinkFilter(size_t sinkIndex, FilterPredicate filter) {
            m_logManager.setSinkFilter(sinkIndex, std::move(filter));
        }

        void clearSinkFilter(size_t sinkIndex) {
            m_logManager.clearSinkFilter(sinkIndex);
        }

        void addSinkFilterRule(size_t sinkIndex, const std::string& ruleStr) {
            m_logManager.addSinkFilterRule(sinkIndex, ruleStr);
        }

        void clearSinkFilterRules(size_t sinkIndex) {
            m_logManager.clearSinkFilterRules(sinkIndex);
        }

        void clearAllSinkFilters(size_t sinkIndex) {
            m_logManager.clearAllSinkFilters(sinkIndex);
        }

        void setContext(const std::string& key, const std::string& value) {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext[key] = value;
            m_hasCustomContext.store(true, std::memory_order_release);
        }

        void clearContext(const std::string& key) {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext.erase(key);
            m_hasCustomContext.store(!m_customContext.empty(), std::memory_order_release);
        }

        void clearAllContext() {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext.clear();
            m_hasCustomContext.store(false, std::memory_order_release);
        }

        LogScope scope(std::initializer_list<std::pair<std::string, std::string>> pairs);

        /// Set the maximum number of cached template parse results.
        /// Setting to 0 disables caching and clears existing entries.
        /// Shrinking to a non-zero value does NOT trim existing entries —
        /// they remain accessible for lookups but no new entries are
        /// inserted until the map size drops below the new cap.
        void setTemplateCacheSize(size_t size) {
            std::lock_guard<std::mutex> lock(m_cacheMutex);
            m_templateCacheSize = size;
            if (size == 0) {
                m_templateCache.clear();
            }
        }

        void setLocale(const std::string& locale) {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            m_locale = locale;
            m_hasLocale.store(locale != "C" && locale != "POSIX" && !locale.empty(), std::memory_order_release);
        }

        std::string getLocale() const {
            std::lock_guard<std::mutex> lock(m_localeMutex);
            return m_locale;
        }

        /// Set a per-sink locale. The sink's formatter will use this locale
        /// to re-render culture-specific format specifiers, overriding the
        /// logger-level locale for that sink only.
        void setSinkLocale(size_t sinkIndex, const std::string& locale) {
            m_logManager.setSinkLocale(sinkIndex, locale);
        }

        /// Register an enricher that attaches metadata to every log entry.
        /// Enrichers run in registration order before explicit context
        /// (setContext / scoped context), so explicit context wins on
        /// key collisions.
        ///
        /// @throws std::logic_error if called after the first log entry
        ///         has been emitted. All enrichers must be registered
        ///         during logger configuration, before any logging begins.
        void enrich(EnricherFn fn) {
            if (m_logManager.isLoggingStarted()) {
                throw std::logic_error("Cannot add enrichers after logging has started");
            }
            m_enrichers.push_back(std::move(fn));
            m_hasEnrichers.store(true, std::memory_order_release);
        }

    private:
        friend class LoggerConfiguration;

        struct BuilderTag {};
        explicit LunarLog(BuilderTag)
            : m_minLevel(LogLevel::TRACE)
            , m_isRunning(true)
            , m_rateLimitWindowStart(std::chrono::steady_clock::now().time_since_epoch().count())
            , m_logCount(0)
            , m_captureSourceLocation(false)
            , m_hasCustomContext(false)
            , m_sinkWriteInProgress(false)
            , m_templateCacheSize(128)
            , m_hasGlobalFilters(false)
            , m_rateLimitMaxLogs(1000)
            , m_rateLimitWindowMs(1000)
            , m_threadStarted(false) {
        }

        void ensureProcessingThread() {
            if (!m_threadStarted.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> lock(m_queueMutex);
                if (!m_threadStarted.load(std::memory_order_relaxed)) {
                    m_logThread = std::thread(&LunarLog::processLogQueue, this);
                    m_threadStarted.store(true, std::memory_order_release);
                }
            }
        }

        std::atomic<LogLevel> m_minLevel;
        std::atomic<bool> m_isRunning;
        std::atomic<long long> m_rateLimitWindowStart;
        std::atomic<size_t> m_logCount;
        std::mutex m_queueMutex;
        std::mutex m_contextMutex;
        std::condition_variable m_logCV;
        std::condition_variable m_flushCV;
        std::queue<LogEntry> m_logQueue;
        std::thread m_logThread;
        LogManager m_logManager;
        std::map<std::string, std::string> m_customContext;
        std::atomic<bool> m_captureSourceLocation;
        std::atomic<bool> m_hasCustomContext;
        std::atomic<bool> m_sinkWriteInProgress;

        struct PlaceholderInfo {
            std::string name;
            std::string fullContent;
            std::string spec;
            size_t startPos;
            size_t endPos;
            char operator_;  // '@' (destructure), '$' (stringify), or 0 (none)
            std::vector<detail::Transform> transforms;
            int indexedArg;  // >= 0 for indexed ({0},{1},...), -1 for named
            int alignment;   // >0 right-align, <0 left-align, 0 = none
        };

        std::mutex m_cacheMutex;
        std::unordered_map<std::string, std::vector<PlaceholderInfo>> m_templateCache;
        size_t m_templateCacheSize;

        std::mutex m_globalFilterMutex;
        std::atomic<bool> m_hasGlobalFilters;
        FilterPredicate m_globalFilter;
        std::vector<FilterRule> m_globalFilterRules;

        mutable std::mutex m_localeMutex;
        std::atomic<bool> m_hasLocale{false};
        std::string m_locale = "C";

        std::vector<EnricherFn> m_enrichers;
        std::atomic<bool> m_hasEnrichers{false};

        size_t m_rateLimitMaxLogs;
        long long m_rateLimitWindowMs;
        std::atomic<bool> m_threadStarted;

        static std::vector<PlaceholderInfo> extractPlaceholders(const std::string &messageTemplate) {
            std::vector<PlaceholderInfo> placeholders;
            detail::forEachPlaceholder(messageTemplate, [&](const detail::ParsedPlaceholder& ph) {
                placeholders.push_back({ph.name, ph.fullContent, ph.spec, ph.startPos, ph.endPos, ph.op, ph.transforms, ph.indexedArg, ph.alignment});
            });
            return placeholders;
        }

        template<typename... Args>
        void logInternal(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            if (!m_isRunning.load(std::memory_order_acquire)) return;
            if (level < m_minLevel.load(std::memory_order_relaxed)) return;
            if (!rateLimitCheck()) return;

            std::vector<std::string> values{toString(args)...};
            detail::ExceptionInfo noException;
            emitLogEntry(level, file, line, function, messageTemplate, values, noException);
        }

        template<typename... Args>
        void logInternalWithException(LogLevel level, const char* file, int line, const char* function,
                                      const std::exception& ex, const std::string &messageTemplate, const Args &... args) {
            if (!m_isRunning.load(std::memory_order_acquire)) return;
            if (level < m_minLevel.load(std::memory_order_relaxed)) return;
            if (!rateLimitCheck()) return;

            std::vector<std::string> values{toString(args)...};
            detail::ExceptionInfo exInfo = detail::extractExceptionInfo(ex);
            emitLogEntry(level, file, line, function, messageTemplate, values, exInfo);
        }

        void emitLogEntry(LogLevel level, const char* file, int line, const char* function,
                          const std::string &messageTemplate, std::vector<std::string>& values,
                          detail::ExceptionInfo& exInfo) {
            auto now = std::chrono::system_clock::now();

            auto tagResult = detail::parseTags(messageTemplate);
            std::vector<std::string> entryTags = std::move(tagResult.first);
            const std::string& effectiveTemplate = entryTags.empty() ? messageTemplate : tagResult.second;

            uint32_t hash = detail::fnv1a(effectiveTemplate);
            std::vector<PlaceholderInfo> placeholders;
            bool cacheHit = false;
            {
                std::lock_guard<std::mutex> cacheLock(m_cacheMutex);
                if (m_templateCacheSize > 0) {
                    auto it = m_templateCache.find(effectiveTemplate);
                    if (it != m_templateCache.end()) {
                        placeholders = it->second;
                        cacheHit = true;
                    }
                }
            }
            if (!cacheHit) {
                placeholders = extractPlaceholders(effectiveTemplate);
                std::lock_guard<std::mutex> cacheLock(m_cacheMutex);
                if (m_templateCacheSize > 0) {
                    if (m_templateCache.size() < m_templateCacheSize) {
                        m_templateCache[effectiveTemplate] = placeholders;
                    }
                }
            }

            std::string localeCopy = "C";
            if (m_hasLocale.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> localeLock(m_localeMutex);
                localeCopy = m_locale;
            }

            std::vector<std::string> warnings = validatePlaceholders(effectiveTemplate, placeholders, values);
            std::string message = formatMessage(effectiveTemplate, placeholders, values, localeCopy);
            auto argumentPairs = mapArgumentsToPlaceholders(placeholders, values);
            auto properties = mapProperties(placeholders, values);

            bool captureCtx = m_captureSourceLocation.load(std::memory_order_relaxed);
            std::map<std::string, std::string> contextCopy;
            if (m_hasCustomContext.load(std::memory_order_acquire)) {
                std::lock_guard<std::mutex> contextLock(m_contextMutex);
                contextCopy = m_customContext;
            }

            auto& scopeStack = detail::threadScopeStack();
            if (!scopeStack.empty()) {
                for (const auto& frame : scopeStack) {
                    for (const auto& kv : frame) {
                        contextCopy[kv.first] = kv.second;
                    }
                }
            }

            bool hasEnrichers = m_hasEnrichers.load(std::memory_order_acquire);

            LogEntry entry(
                level, std::move(message), now, effectiveTemplate, hash,
                std::move(argumentPairs),
                captureCtx ? file : "", captureCtx ? line : 0, captureCtx ? function : "",
                std::map<std::string, std::string>(),
                std::move(properties), std::move(entryTags), std::move(localeCopy),
                std::this_thread::get_id(),
                std::move(exInfo.type), std::move(exInfo.message), std::move(exInfo.chain)
            );

            if (hasEnrichers) {
                for (const auto& enricher : m_enrichers) {
                    // Enricher exceptions are swallowed to prevent logging
                    // from crashing the application.
                    try {
                        enricher(entry);
                    } catch (...) {}
                }
                // Explicit context (setContext / scoped) overwrites enricher
                // values — key-by-key merge required for correct precedence.
                for (const auto& kv : contextCopy) {
                    entry.customContext[kv.first] = kv.second;
                }
            } else {
                // Fast path: no enrichers registered — move the entire context
                // map into the entry in O(1) instead of copying key-by-key.
                entry.customContext = std::move(contextCopy);
            }

            ensureProcessingThread();

            std::unique_lock<std::mutex> lock(m_queueMutex);
            m_logQueue.push(std::move(entry));

            for (const auto& warning : warnings) {
                uint32_t warnHash = detail::fnv1a(warning);
                m_logQueue.emplace(LogEntry(
                    /* level */        LogLevel::WARN,
                    /* message */      warning,
                    /* timestamp */    now,
                    /* templateStr */  warning,
                    /* templateHash */ warnHash,
                    /* arguments */    {},
                    /* file */         captureCtx ? file : "",
                    /* line */         captureCtx ? line : 0,
                    /* function */     captureCtx ? function : "",
                    /* customContext */{},
                    /* properties */   {},
                    /* tags */         {},
                    /* locale */       "C",
                    /* threadId */     std::this_thread::get_id()
                ));
            }

            lock.unlock();
            m_logCV.notify_one();
        }

        void processLogQueue() {
            while (m_isRunning) {
                std::unique_lock<std::mutex> lock(m_queueMutex);
                m_logCV.wait(lock, [this] { return !m_logQueue.empty() || !m_isRunning; });

                while (!m_logQueue.empty()) {
                    auto entry = std::move(m_logQueue.front());
                    m_logQueue.pop();
                    m_sinkWriteInProgress.store(true, std::memory_order_relaxed);
                    lock.unlock();

                    try {
                        m_logManager.log(entry, m_globalFilter, m_globalFilterRules, m_globalFilterMutex, m_hasGlobalFilters);
                    } catch (...) {
                        // Swallow — logging must not crash the application
                    }

                    // Re-acquire lock BEFORE clearing sinkWriteInProgress and
                    // notifying, so that flush() cannot miss the state change.
                    // Without this, flush() can check the predicate (seeing
                    // sinkWriteInProgress==true), then we set it to false and
                    // notify, and THEN flush() enters wait — a classic lost wakeup.
                    lock.lock();
                    m_sinkWriteInProgress.store(false, std::memory_order_relaxed);
                    m_flushCV.notify_all();
                }
            }

            {
                std::unique_lock<std::mutex> lock(m_queueMutex);
                while (!m_logQueue.empty()) {
                    auto entry = std::move(m_logQueue.front());
                    m_logQueue.pop();
                    m_sinkWriteInProgress.store(true, std::memory_order_relaxed);
                    lock.unlock();
                    try {
                        m_logManager.log(entry, m_globalFilter, m_globalFilterRules, m_globalFilterMutex, m_hasGlobalFilters);
                    } catch (...) {
                        // Swallow — logging must not crash the application
                    }
                    lock.lock();
                    m_sinkWriteInProgress.store(false, std::memory_order_relaxed);
                    m_flushCV.notify_all();
                }
            }
        }

        // Rate limiting is best-effort under concurrent access.
        //
        // When the window expires, the first thread to win the CAS resets
        // m_rateLimitWindowStart and stores m_logCount to 1 (counting its own
        // message). Concurrent threads that already read the old window but
        // lose the CAS retry and see the new window; their subsequent
        // fetch_add on m_logCount races with the store(1), so a small number
        // of messages at the window boundary may be silently lost or allowed
        // beyond the limit. This is acceptable for a best-effort rate limiter.
        bool rateLimitCheck() {
            auto now = std::chrono::steady_clock::now();
            long long nowNs = now.time_since_epoch().count();
            long long windowStart = m_rateLimitWindowStart.load(std::memory_order_relaxed);

            for (;;) {
                auto durationMs = std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::steady_clock::duration(nowNs - windowStart)).count();
                if (durationMs < m_rateLimitWindowMs) break;
                if (m_rateLimitWindowStart.compare_exchange_weak(windowStart, nowNs,
                        std::memory_order_relaxed, std::memory_order_relaxed)) {
                    // Release so that the new count is visible to threads that
                    // subsequently read it with acquire in fetch_add below.
                    m_logCount.store(1, std::memory_order_release);
                    return true;
                }
            }
            // Acquire pairs with the release-store above: if a window reset just
            // happened, this thread sees the updated count before incrementing.
            size_t count = m_logCount.fetch_add(1, std::memory_order_acquire);
            if (count >= m_rateLimitMaxLogs) {
                return false;
            }
            return true;
        }

        static bool isWhitespaceOnly(const std::string &s) {
            for (size_t i = 0; i < s.size(); ++i) {
                if (!std::isspace(static_cast<unsigned char>(s[i]))) return false;
            }
            return !s.empty();
        }

        static std::vector<std::string> validatePlaceholders(
            const std::string &templateStr,
            const std::vector<PlaceholderInfo> &placeholders,
            const std::vector<std::string> &values) {
            std::vector<std::string> warnings;
            std::set<std::string> uniquePlaceholders;

            for (const auto &ph : placeholders) {
                if (ph.name.empty()) {
                    warnings.push_back("Warning: Template \"" + templateStr + "\" has empty placeholder");
                } else if (isWhitespaceOnly(ph.name)) {
                    warnings.push_back("Warning: Template \"" + templateStr + "\" has whitespace-only placeholder name");
                } else if (ph.indexedArg < 0 && !uniquePlaceholders.insert(ph.name).second) {
                    warnings.push_back("Warning: Template \"" + templateStr + "\" has duplicate placeholder name: " + ph.name);
                }
            }

            std::set<size_t> usedSlots;
            size_t namedOrdinal = 0;
            for (size_t i = 0; i < placeholders.size(); ++i) {
                const auto &ph = placeholders[i];
                size_t slot = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                usedSlots.insert(slot);
            }

            if (usedSlots.size() < values.size()) {
                warnings.push_back("Warning: More values provided than placeholders");
            }

            bool hasMissingSlot = false;
            for (std::set<size_t>::const_iterator it = usedSlots.begin(); it != usedSlots.end(); ++it) {
                if (*it >= values.size()) {
                    hasMissingSlot = true;
                    break;
                }
            }
            if (hasMissingSlot) {
                warnings.push_back("Warning: More placeholders than provided values");
            }

            return warnings;
        }

        template<typename T>
        static std::string toString(const T &value) {
            std::ostringstream oss;
            oss << value;
            return oss.str();
        }

        static std::string toString(const std::string &value) {
            return value;
        }

        static std::string toString(const char *value) {
            if (!value) return "(null)";
            return std::string(value);
        }

        static std::string toString(std::nullptr_t) {
            return "(null)";
        }

        static std::string toString(int value) {
            return std::to_string(value);
        }

        static std::string toString(long value) {
            return std::to_string(value);
        }

        static std::string toString(long long value) {
            return std::to_string(value);
        }

        static std::string toString(unsigned int value) {
            return std::to_string(value);
        }

        static std::string toString(unsigned long value) {
            return std::to_string(value);
        }

        static std::string toString(unsigned long long value) {
            return std::to_string(value);
        }

        static std::string toString(bool value) {
            return value ? "true" : "false";
        }

        static std::string toString(double value) {
            char buf[64];
            std::snprintf(buf, sizeof(buf), "%.15g", value);
            // Locale-safety: some locales use ',' as decimal separator;
            // ensure consistent '.' for downstream parsers (e.g. JSON).
            for (char *p = buf; *p; ++p) { if (*p == ',') *p = '.'; }
            return std::string(buf);
        }

        static std::string toString(float value) {
            char buf[64];
            std::snprintf(buf, sizeof(buf), "%.9g", static_cast<double>(value));
            // Locale-safety: same as toString(double).
            for (char *p = buf; *p; ++p) { if (*p == ',') *p = '.'; }
            return std::string(buf);
        }

        // ----------------------------------------------------------------
        // Format helpers — delegate to detail:: namespace implementations.
        // Kept as private statics for internal use within LunarLog.
        // ----------------------------------------------------------------

        static int safeStoi(const std::string &s, int fallback = 0) {
            return detail::safeStoi(s, fallback);
        }

        static bool tryParseDouble(const std::string &s, double &out) {
            return detail::tryParseDouble(s, out);
        }

        static bool isNumericString(const std::string &s) {
            double ignored;
            return detail::tryParseDouble(s, ignored);
        }

        static double parseDouble(const std::string &s) {
            double val = 0.0;
            detail::tryParseDouble(s, val);
            return val;
        }

        /// Apply a format spec to a value, with locale for culture-specific specs.
        /// Delegates to detail::applyFormat which handles all specs including
        /// culture-specific ones (:n, :N, :d, :D, :t, :T, :f, :F).
        static std::string applyFormat(const std::string &value, const std::string &spec, const std::string &locale = "C") {
            return detail::applyFormat(value, spec, locale);
        }

        static std::pair<std::string, std::string> splitPlaceholder(const std::string &placeholder) {
            return detail::splitPlaceholder(placeholder);
        }

        static std::string formatMessage(const std::string &messageTemplate,
            const std::vector<PlaceholderInfo> &placeholders, const std::vector<std::string> &values,
            const std::string &locale = "C") {
            return detail::walkTemplate(messageTemplate, placeholders, values, locale);
        }

        static std::vector<std::pair<std::string, std::string>> mapArgumentsToPlaceholders(
            const std::vector<PlaceholderInfo> &placeholders, const std::vector<std::string> &values) {
            std::vector<std::pair<std::string, std::string>> argumentPairs;

            size_t namedOrdinal = 0;
            for (size_t i = 0; i < placeholders.size(); ++i) {
                const auto &ph = placeholders[i];
                size_t valueIdx = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                if (valueIdx < values.size()) {
                    argumentPairs.emplace_back(ph.name, values[valueIdx]);
                }
            }

            return argumentPairs;
        }

        /// Map placeholders to PlaceholderProperty entries for structured formatters.
        /// @param placeholders Parsed placeholder metadata (includes operator info).
        /// @param values       Positional argument strings (from toString() conversion).
        /// Properties is the richer representation: it carries operator context (@/$)
        /// that arguments (simple name-value pairs) do not, enabling formatters to
        /// choose type-aware serialization (e.g. JSON native types for @).
        /// @note Properties are populated unconditionally — even when no operators
        ///       are used — so that structured formatters (JSON, XML) always have
        ///       access to placeholder names.  The per-message overhead is a single
        ///       reserve + N moves for typical placeholder counts (< 10), which is
        ///       negligible relative to I/O.
        static std::vector<PlaceholderProperty> mapProperties(
            const std::vector<PlaceholderInfo> &placeholders, const std::vector<std::string> &values) {
            std::vector<PlaceholderProperty> props;
            props.reserve(placeholders.size());
            std::set<std::string> seen;

            size_t namedOrdinal = 0;
            for (size_t i = 0; i < placeholders.size(); ++i) {
                const auto &ph = placeholders[i];
                size_t valueIdx = detail::resolveValueSlot(ph.indexedArg, namedOrdinal);
                if (ph.indexedArg < 0) ++namedOrdinal;
                if (valueIdx >= values.size()) continue;
                if (!seen.insert(ph.name).second) continue;
                char effectiveOp = ph.operator_;
                std::vector<std::string> transformSpecs;
                for (size_t ti = 0; ti < ph.transforms.size(); ++ti) {
                    const auto &t = ph.transforms[ti];
                    if (t.name == "expand") effectiveOp = '@';
                    else if (t.name == "str") effectiveOp = '$';
                    if (t.arg.empty()) {
                        transformSpecs.push_back(t.name);
                    } else {
                        transformSpecs.push_back(t.name + ":" + t.arg);
                    }
                }
                props.push_back({ph.name, values[valueIdx], effectiveOp, std::move(transformSpecs)});
            }

            return props;
        }
    };

    /// RAII scoped context that injects key-value pairs into log entries
    /// for the lifetime of the scope.
    ///
    /// NOTE: Scoped context is **thread-wide**, not per-logger instance.
    /// All LunarLog instances on the same thread share the same scope stack.
    /// If you use multiple loggers on one thread, scoped context will appear
    /// in log entries from all of them. This is by design — most applications
    /// use a single logger, and thread-wide scoping avoids the complexity of
    /// passing logger pointers into scope objects.
    class LogScope {
    public:
        LogScope(const LogScope&) = delete;
        LogScope& operator=(const LogScope&) = delete;

        LogScope(LogScope&& other) noexcept
            : m_active(other.m_active), m_iter(other.m_iter) {
            other.m_active = false;
        }

        LogScope& operator=(LogScope&& other) noexcept {
            if (this != &other) {
                if (m_active) {
                    detail::threadScopeStack().erase(m_iter);
                }
                m_active = other.m_active;
                m_iter = other.m_iter;
                other.m_active = false;
            }
            return *this;
        }

        ~LogScope() noexcept {
            if (m_active) {
                detail::threadScopeStack().erase(m_iter);
            }
        }

        /// Append a key-value pair to this scope's frame.
        /// If the same key is added multiple times, the last value wins
        /// (later entries overwrite earlier ones during collection).
        LogScope& add(const std::string& key, const std::string& value) {
            if (m_active) {
                m_iter->emplace_back(key, value);
            }
            return *this;
        }

    private:
        friend class LunarLog;

        explicit LogScope(std::initializer_list<std::pair<std::string, std::string>> pairs)
            : m_active(true) {
            auto& stack = detail::threadScopeStack();
            stack.emplace_back(pairs.begin(), pairs.end());
            m_iter = std::prev(stack.end());
        }

        bool m_active = false;
        detail::ScopeFrameIter m_iter;
    };

    inline LogScope LunarLog::scope(std::initializer_list<std::pair<std::string, std::string>> pairs) {
        return LogScope(pairs);
    }

    class ContextScope {
    public:
        ContextScope(LunarLog& logger, const std::string& key, const std::string& value)
            : m_logger(logger), m_key(key) {
            m_logger.setContext(key, value);
        }

        ~ContextScope() noexcept {
            m_logger.clearContext(m_key);
        }

        ContextScope(const ContextScope &) = delete;
        ContextScope &operator=(const ContextScope &) = delete;
        ContextScope(ContextScope &&) = delete;
        ContextScope &operator=(ContextScope &&) = delete;

    private:
        LunarLog& m_logger;
        std::string m_key;
    };

    inline SinkProxy LunarLog::sink(const std::string& name) {
        size_t idx = m_logManager.getSinkIndex(name);
        return SinkProxy(m_logManager.getSink(idx), m_logManager.isLoggingStarted());
    }

    inline LoggerConfiguration LunarLog::configure() {
        return LoggerConfiguration();
    }

    inline LunarLog LoggerConfiguration::build() {
        if (m_built) {
            throw std::logic_error(
                "LoggerConfiguration::build() already called");
        }
        m_built = true;

        // Create a bare LunarLog — no default console sink, no thread.
        LunarLog logger(LunarLog::BuilderTag{});

        // Apply global settings via friend access.
        logger.m_minLevel.store(m_minLevel, std::memory_order_relaxed);
        logger.m_captureSourceLocation.store(
            m_captureSourceLocation, std::memory_order_relaxed);
        logger.m_rateLimitMaxLogs  = m_rateLimitMaxLogs;
        logger.m_rateLimitWindowMs = m_rateLimitWindowMs;
        logger.setTemplateCacheSize(m_templateCacheSize);

        if (!m_locale.empty()) {
            logger.setLocale(m_locale);
        }

        // Register enrichers (must happen before first log entry).
        for (size_t i = 0; i < m_enrichers.size(); ++i) {
            logger.enrich(std::move(m_enrichers[i]));
        }

        // Add compact filter expressions.
        for (size_t i = 0; i < m_filterCompact.size(); ++i) {
            logger.filter(m_filterCompact[i]);
        }

        // Add DSL filter rules.
        for (size_t i = 0; i < m_filterRules.size(); ++i) {
            logger.addFilterRule(m_filterRules[i]);
        }

        // Add sinks.
        if (m_sinks.empty()) {
            std::fprintf(stderr, "[LunarLog] Warning: build() called with no "
                                 "sinks — logger will silently discard all "
                                 "messages.\n");
        }
        for (size_t i = 0; i < m_sinks.size(); ++i) {
            if (m_sinks[i].hasName) {
                logger.addCustomSink(m_sinks[i].name,
                                     std::move(m_sinks[i].sink));
            } else {
                logger.addCustomSink(std::move(m_sinks[i].sink));
            }
        }

        // Start the background processing thread.
        logger.ensureProcessingThread();

        // Safe to return by move: LunarLog's move constructor transfers all
        // internal state (queue, sinks, atomics, enrichers, filters).  The
        // processing thread has not yet received any log entries at this point
        // because ensureProcessingThread() only starts the thread — it does
        // not produce entries.  The moved-from instance is left in a valid
        // but empty state (m_isRunning == false).
        return logger;
    }

} // namespace minta


#define LUNAR_LOG_CONTEXT __FILE__, __LINE__, __func__

#endif // LUNAR_LOG_SINGLE_HEADER_HPP
