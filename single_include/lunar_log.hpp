// LunarLog - Single Header
// https://github.com/LunarECL/LunarLog
// Auto-generated by tools/generate_single_header.py
//
// Usage: just include this file.

#ifndef LUNAR_LOG_SINGLE_HEADER_HPP
#define LUNAR_LOG_SINGLE_HEADER_HPP

// --- lunar_log/core/log_level.hpp ---

namespace minta {
    enum class LogLevel {
        TRACE,
        DEBUG,
        INFO,
        WARN,
        ERROR,
        FATAL
    };

    inline const char *getLevelString(LogLevel level) {
        switch (level) {
            case LogLevel::TRACE: return "TRACE";
            case LogLevel::DEBUG: return "DEBUG";
            case LogLevel::INFO: return "INFO";
            case LogLevel::WARN: return "WARN";
            case LogLevel::ERROR: return "ERROR";
            case LogLevel::FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }
} // namespace minta


// --- lunar_log/core/log_common.hpp ---

#include <string>
#include <chrono>
#include <sstream>
#include <iomanip>
#include <vector>
#include <memory>

namespace minta {
namespace detail {
    template<typename T, typename... Args>
    inline std::unique_ptr<T> make_unique(Args&&... args) {
#if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
        return std::make_unique<T>(std::forward<Args>(args)...);
#else
        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
#endif
    }
} // namespace detail

    inline std::string formatTimestamp(const std::chrono::system_clock::time_point &time) {
        auto nowTime = std::chrono::system_clock::to_time_t(time);
        auto nowMs = std::chrono::duration_cast<std::chrono::milliseconds>(time.time_since_epoch()) % 1000;

        std::ostringstream oss;
        oss << std::put_time(std::localtime(&nowTime), "%Y-%m-%d %H:%M:%S");
        oss << '.' << std::setfill('0') << std::setw(3) << nowMs.count();
        return oss.str();
    }
} // namespace minta


// --- lunar_log/core/log_entry.hpp ---

#include <string>
#include <chrono>
#include <vector>
#include <map>

namespace minta {
    struct LogEntry {
        LogLevel level;
        std::string message;
        std::chrono::system_clock::time_point timestamp;
        std::string templateStr;
        std::vector<std::pair<std::string, std::string>> arguments;
        std::string file;
        int line;
        std::string function;
        std::map<std::string, std::string> customContext;
    };
} // namespace minta


// --- lunar_log/formatter/formatter_interface.hpp ---

#include <string>

namespace minta {
    class IFormatter {
    public:
        virtual ~IFormatter() = default;

        virtual std::string format(const LogEntry &entry) const = 0;
    };
} // namespace minta


// --- lunar_log/formatter/human_readable_formatter.hpp ---

#include <sstream>

namespace minta {
    class HumanReadableFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::ostringstream oss;
            oss << formatTimestamp(entry.timestamp) << " "
                << "[" << getLevelString(entry.level) << "] "
                << entry.message;

            if (!entry.file.empty()) {
                oss << " [" << entry.file << ":" << entry.line << " " << entry.function << "]";
            }

            if (!entry.customContext.empty()) {
                oss << " {";
                bool first = true;
                for (const auto &ctx : entry.customContext) {
                    if (!first) oss << ", ";
                    oss << ctx.first << "=" << ctx.second;
                    first = false;
                }
                oss << "}";
            }

            return oss.str();
        }
    };
} // namespace minta


// --- lunar_log/formatter/json_formatter.hpp ---

#include <sstream>
#include <iomanip>

namespace minta {
    class JsonFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::ostringstream json;
            json << R"({)";

            json << R"("level":")" << getLevelString(entry.level) << R"(",)";
            json << R"("timestamp":")" << formatTimestamp(entry.timestamp) << R"(",)";
            json << R"("message":")" << escapeJsonString(entry.message) << R"(")";

            if (!entry.file.empty()) {
                json << R"(,"file":")" << escapeJsonString(entry.file) << R"(",)";
                json << R"("line":)" << entry.line << R"(,)";
                json << R"("function":")" << escapeJsonString(entry.function) << R"(")";
            }

            if (!entry.customContext.empty()) {
                json << R"(,"context":{)";
                bool first = true;
                for (const auto &ctx : entry.customContext) {
                    if (!first) json << ",";
                    json << R"(")" << escapeJsonString(ctx.first) << R"(":")" << escapeJsonString(ctx.second) << R"(")";
                    first = false;
                }
                json << "}";
            }

            json << R"(})";
            return json.str();
        }

    private:
        static std::string escapeJsonString(const std::string &input) {
            std::ostringstream result;
            for (char c : input) {
                switch (c) {
                    case '"': result << R"(\")"; break;
                    case '\\': result << R"(\\)"; break;
                    case '\b': result << R"(\b)"; break;
                    case '\f': result << R"(\f)"; break;
                    case '\n': result << R"(\n)"; break;
                    case '\r': result << R"(\r)"; break;
                    case '\t': result << R"(\t)"; break;
                    default:
                        if ('\x00' <= c && c <= '\x1f') {
                            result << R"(\u)" << std::hex << std::setw(4) << std::setfill('0') << static_cast<int>(c);
                        } else {
                            result << c;
                        }
                }
            }
            return result.str();
        }
    };
} // namespace minta


// --- lunar_log/formatter/xml_formatter.hpp ---

#include <sstream>
#include <iomanip>

namespace minta {
    class XmlFormatter : public IFormatter {
    public:
        std::string format(const LogEntry &entry) const override {
            std::ostringstream xml;
            xml << "<log_entry>";
            xml << "<level>" << getLevelString(entry.level) << "</level>";
            xml << "<timestamp>" << formatTimestamp(entry.timestamp) << "</timestamp>";
            xml << "<message>" << escapeXmlString(entry.message) << "</message>";

            if (!entry.file.empty()) {
                xml << "<file>" << escapeXmlString(entry.file) << "</file>";
                xml << "<line>" << entry.line << "</line>";
                xml << "<function>" << escapeXmlString(entry.function) << "</function>";
            }

            if (!entry.customContext.empty()) {
                xml << "<context>";
                for (const auto &ctx : entry.customContext) {
                    xml << "<" << escapeXmlString(ctx.first) << ">";
                    xml << escapeXmlString(ctx.second);
                    xml << "</" << escapeXmlString(ctx.first) << ">";
                }
                xml << "</context>";
            }

            xml << "</log_entry>";
            return xml.str();
        }

    private:
        static std::string escapeXmlString(const std::string &input) {
            std::ostringstream result;
            for (char c : input) {
                switch (c) {
                    case '<': result << "&lt;"; break;
                    case '>': result << "&gt;"; break;
                    case '&': result << "&amp;"; break;
                    case '\'': result << "&apos;"; break;
                    case '"': result << "&quot;"; break;
                    default: result << c; break;
                }
            }
            return result.str();
        }
    };
} // namespace minta


// --- lunar_log/transport/transport_interface.hpp ---

#include <string>

namespace minta {

    class ITransport {
    public:
        virtual ~ITransport() = default;
        virtual void write(const std::string& formattedEntry) = 0;
    };

} // namespace minta


// --- lunar_log/transport/file_transport.hpp ---

#include <fstream>
#include <mutex>
#include <stdexcept>

namespace minta {
    class FileTransport : public ITransport {
    public:
        explicit FileTransport(const std::string &filename) : m_filename(filename) {
            m_file.open(filename, std::ios::app);
            if (!m_file.is_open()) {
                throw std::runtime_error("FileTransport: failed to open file: " + filename);
            }
        }

        void write(const std::string &formattedEntry) override {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (!m_file.good()) {
                return;
            }
            m_file << formattedEntry << std::endl;
        }

    private:
        std::string m_filename;
        std::ofstream m_file;
        std::mutex m_mutex;
    };
} // namespace minta


// --- lunar_log/transport/stdout_transport.hpp ---

#include <iostream>
#include <mutex>

namespace minta {
    class StdoutTransport : public ITransport {
    public:
        void write(const std::string &formattedEntry) override {
            std::lock_guard<std::mutex> lock(m_mutex);
            std::cout << formattedEntry << std::endl;
        }

    private:
        std::mutex m_mutex;
    };
} // namespace minta


// --- lunar_log/sink/sink_interface.hpp ---

#include <memory>

namespace minta {
    class ISink {
    public:
        virtual ~ISink() = default;

        virtual void write(const LogEntry &entry) = 0;

        void setFormatter(std::unique_ptr<IFormatter> formatter) {
            m_formatter = std::move(formatter);
        }

        void setTransport(std::unique_ptr<ITransport> transport) {
            m_transport = std::move(transport);
        }

    protected:
        std::unique_ptr<IFormatter> m_formatter;
        std::unique_ptr<ITransport> m_transport;
    };
} // namespace minta


// --- lunar_log/sink/console_sink.hpp ---


namespace minta {
    class ConsoleSink : public ISink {
    public:
        ConsoleSink() {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<StdoutTransport>());
        }

        void write(const LogEntry &entry) override {
            if (m_formatter && m_transport) {
                m_transport->write(m_formatter->format(entry));
            }
        }
    };
} // namespace minta


// --- lunar_log/sink/file_sink.hpp ---


namespace minta {
    class FileSink : public ISink {
    public:
        explicit FileSink(const std::string &filename) {
            setFormatter(detail::make_unique<HumanReadableFormatter>());
            setTransport(detail::make_unique<FileTransport>(filename));
        }

        void write(const LogEntry &entry) override {
            if (m_formatter && m_transport) {
                m_transport->write(m_formatter->format(entry));
            }
        }
    };
} // namespace minta


// --- lunar_log/log_manager.hpp ---

#include <vector>
#include <memory>

namespace minta {
    class LogManager {
    public:
        void addSink(std::unique_ptr<ISink> sink) {
            m_sinks.push_back(std::move(sink));
        }

        void log(const LogEntry &entry) {
            for (const auto &sink: m_sinks) {
                sink->write(entry);
            }
        }

    private:
        std::vector<std::unique_ptr<ISink> > m_sinks;
    };
} // namespace minta


// --- lunar_log/log_source.hpp ---

#include <atomic>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <regex>
#include <type_traits>
#include <set>
#include <map>

namespace minta {
    class LunarLog {
    public:
        explicit LunarLog(LogLevel minLevel = LogLevel::INFO)
            : m_minLevel(minLevel)
            , m_isRunning(true)
            , m_lastLogTime(std::chrono::steady_clock::now())
            , m_logCount(0)
            , m_captureContext(false) {
            addSink<ConsoleSink>();
            m_logThread = std::thread(&LunarLog::processLogQueue, this);
        }

        ~LunarLog() {
            m_isRunning = false;
            m_logCV.notify_one();
            if (m_logThread.joinable()) {
                m_logThread.join();
            }
        }

        LunarLog(const LunarLog &) = delete;
        LunarLog &operator=(const LunarLog &) = delete;
        LunarLog(LunarLog &&) = delete;
        LunarLog &operator=(LunarLog &&) = delete;

        void setMinLevel(LogLevel level) {
            m_minLevel.store(level, std::memory_order_relaxed);
        }

        LogLevel getMinLevel() const {
            return m_minLevel.load(std::memory_order_relaxed);
        }

        void setCaptureContext(bool capture) {
            m_captureContext.store(capture, std::memory_order_relaxed);
        }

        bool getCaptureContext() const {
            return m_captureContext.load(std::memory_order_relaxed);
        }

        template<typename SinkType, typename... Args>
        typename std::enable_if<std::is_base_of<ISink, SinkType>::value>::type
        addSink(Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<HumanReadableFormatter>());
            m_logManager.addSink(std::move(sink));
        }

        template<typename SinkType, typename FormatterType, typename... Args>
        typename std::enable_if<std::is_base_of<ISink, SinkType>::value && std::is_base_of<IFormatter, FormatterType>::value>::type
        addSink(Args &&... args) {
            auto sink = detail::make_unique<SinkType>(std::forward<Args>(args)...);
            sink->setFormatter(detail::make_unique<FormatterType>());
            m_logManager.addSink(std::move(sink));
        }

        void addCustomSink(std::unique_ptr<ISink> sink) {
            m_logManager.addSink(std::move(sink));
        }

        template<typename... Args>
        void log(LogLevel level, const std::string &messageTemplate, const Args &... args) {
            logInternal(level, "", 0, "", messageTemplate, args...);
        }

        template<typename... Args>
        void logWithContext(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            logInternal(level, file, line, function, messageTemplate, args...);
        }

        template<typename... Args>
        void trace(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::TRACE, messageTemplate, args...);
        }

        template<typename... Args>
        void debug(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::DEBUG, messageTemplate, args...);
        }

        template<typename... Args>
        void info(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::INFO, messageTemplate, args...);
        }

        template<typename... Args>
        void warn(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::WARN, messageTemplate, args...);
        }

        template<typename... Args>
        void error(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::ERROR, messageTemplate, args...);
        }

        template<typename... Args>
        void fatal(const std::string &messageTemplate, const Args &... args) {
            log(LogLevel::FATAL, messageTemplate, args...);
        }

        void setContext(const std::string& key, const std::string& value) {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext[key] = value;
        }

        void clearContext(const std::string& key) {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext.erase(key);
        }

        void clearAllContext() {
            std::lock_guard<std::mutex> lock(m_contextMutex);
            m_customContext.clear();
        }

    private:
        static constexpr size_t kRateLimitMaxLogs = 1000;
        static constexpr long long kRateLimitWindowSeconds = 1;

        std::atomic<LogLevel> m_minLevel;
        std::atomic<bool> m_isRunning;
        std::chrono::steady_clock::time_point m_lastLogTime;
        size_t m_logCount;
        std::mutex m_queueMutex;
        std::mutex m_contextMutex;
        std::mutex m_rateLimitMutex;
        std::condition_variable m_logCV;
        std::queue<LogEntry> m_logQueue;
        std::thread m_logThread;
        LogManager m_logManager;
        std::map<std::string, std::string> m_customContext;
        std::atomic<bool> m_captureContext;

        static const std::regex& placeholderRegex() {
            static const std::regex instance(R"(\{([^{}]*)\})");
            return instance;
        }

        template<typename... Args>
        void logInternal(LogLevel level, const char* file, int line, const char* function, const std::string &messageTemplate, const Args &... args) {
            if (level < m_minLevel.load(std::memory_order_relaxed)) return;
            if (!rateLimitCheck()) return;

            auto validationResult = validatePlaceholders(messageTemplate, args...);
            std::string validatedTemplate = validationResult.first;
            std::vector<std::string> warnings = validationResult.second;

            auto now = std::chrono::system_clock::now();
            std::string message = formatMessage(validatedTemplate, args...);
            auto argumentPairs = mapArgumentsToPlaceholders(validatedTemplate, args...);

            bool captureCtx = m_captureContext.load(std::memory_order_relaxed);
            std::map<std::string, std::string> contextCopy;
            {
                std::lock_guard<std::mutex> contextLock(m_contextMutex);
                contextCopy = m_customContext;
            }

            std::unique_lock<std::mutex> lock(m_queueMutex);
            m_logQueue.emplace(LogEntry{
                level, std::move(message), now, validatedTemplate, std::move(argumentPairs),
                captureCtx ? file : "", captureCtx ? line : 0, captureCtx ? function : "", std::move(contextCopy)
            });

            for (const auto& warning : warnings) {
                m_logQueue.emplace(LogEntry{LogLevel::WARN, warning, now, warning, {},
                                            captureCtx ? file : "", captureCtx ? line : 0, captureCtx ? function : "", {}});
            }

            lock.unlock();
            m_logCV.notify_one();
        }

        void processLogQueue() {
            while (m_isRunning) {
                std::unique_lock<std::mutex> lock(m_queueMutex);
                m_logCV.wait(lock, [this] { return !m_logQueue.empty() || !m_isRunning; });

                while (!m_logQueue.empty()) {
                    auto entry = std::move(m_logQueue.front());
                    m_logQueue.pop();
                    lock.unlock();

                    m_logManager.log(entry);

                    lock.lock();
                }
            }
        }

        bool rateLimitCheck() {
            std::lock_guard<std::mutex> lock(m_rateLimitMutex);
            auto now = std::chrono::steady_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::seconds>(now - m_lastLogTime).count();
            if (duration >= kRateLimitWindowSeconds) {
                m_lastLogTime = now;
                m_logCount = 1;
                return true;
            }
            if (m_logCount >= kRateLimitMaxLogs) {
                return false;
            }
            ++m_logCount;
            return true;
        }

        template<typename... Args>
        static std::pair<std::string, std::vector<std::string>> validatePlaceholders(
            const std::string &messageTemplate, const Args &... args) {
            std::vector<std::string> warnings;
            std::vector<std::string> placeholders;
            std::set<std::string> uniquePlaceholders;
            std::vector<std::string> values{toString(args)...};

            const std::regex& regex = placeholderRegex();
            auto placeholderBegin = std::sregex_iterator(messageTemplate.begin(), messageTemplate.end(), regex);
            auto placeholderEnd = std::sregex_iterator();

            for (std::sregex_iterator i = placeholderBegin; i != placeholderEnd; ++i) {
                std::smatch match = *i;
                std::string placeholder = match[1].str();

                if (placeholder.empty()) {
                    std::string prefix = match.prefix().str();
                    if (!prefix.empty() && prefix.back() == '{') {
                        continue;
                    }
                }

                placeholders.push_back(placeholder);

                if (placeholder.empty()) {
                    warnings.push_back("Warning: Empty placeholder found");
                } else if (!uniquePlaceholders.insert(placeholder).second) {
                    warnings.push_back("Warning: Repeated placeholder name: " + placeholder);
                }
            }

            if (placeholders.size() < values.size()) {
                warnings.push_back("Warning: More values provided than placeholders");
            } else if (placeholders.size() > values.size()) {
                warnings.push_back("Warning: More placeholders than provided values");
            }

            return std::make_pair(messageTemplate, warnings);
        }

        template<typename T>
        static std::string toString(const T &value) {
            std::ostringstream oss;
            oss << value;
            return oss.str();
        }

        template<typename... Args>
        static std::string formatMessage(const std::string &messageTemplate, const Args &... args) {
            std::vector<std::string> values{toString(args)...};
            std::string result;
            result.reserve(messageTemplate.length());
            size_t valueIndex = 0;

            for (size_t i = 0; i < messageTemplate.length(); ++i) {
                if (messageTemplate[i] == '{') {
                    if (i + 1 < messageTemplate.length() && messageTemplate[i + 1] == '{') {
                        result += '{';
                        ++i;
                    } else {
                        size_t endPos = messageTemplate.find("}", i);
                        if (endPos == std::string::npos) {
                            result += messageTemplate[i];
                        } else if (valueIndex < values.size()) {
                            result += values[valueIndex++];
                            i = endPos;
                        } else {
                            result += messageTemplate.substr(i, endPos - i + 1);
                            i = endPos;
                        }
                    }
                } else if (messageTemplate[i] == '}') {
                    if (i + 1 < messageTemplate.length() && messageTemplate[i + 1] == '}') {
                        result += '}';
                        ++i;
                    } else {
                        result += messageTemplate[i];
                    }
                } else {
                    result += messageTemplate[i];
                }
            }
            return result;
        }

        template<typename... Args>
        static std::vector<std::pair<std::string, std::string>> mapArgumentsToPlaceholders(
            const std::string &messageTemplate, const Args &... args) {
            std::vector<std::pair<std::string, std::string>> argumentPairs;
            std::vector<std::string> values{toString(args)...};

            const std::regex& regex = placeholderRegex();
            auto placeholderBegin = std::sregex_iterator(messageTemplate.begin(), messageTemplate.end(), regex);
            auto placeholderEnd = std::sregex_iterator();

            size_t valueIndex = 0;
            for (std::sregex_iterator i = placeholderBegin; i != placeholderEnd && valueIndex < values.size(); ++i) {
                std::smatch match = *i;
                std::string placeholder = match[1].str();

                if (placeholder.empty()) {
                    std::string prefix = match.prefix().str();
                    if (!prefix.empty() && prefix.back() == '{') {
                        continue;
                    }
                }

                argumentPairs.emplace_back(placeholder, values[valueIndex++]);
            }

            return argumentPairs;
        }
    };

    class ContextScope {
    public:
        ContextScope(LunarLog& logger, const std::string& key, const std::string& value)
            : m_logger(logger), m_key(key) {
            m_logger.setContext(key, value);
        }

        ~ContextScope() {
            m_logger.clearContext(m_key);
        }

        ContextScope(const ContextScope &) = delete;
        ContextScope &operator=(const ContextScope &) = delete;
        ContextScope(ContextScope &&) = delete;
        ContextScope &operator=(ContextScope &&) = delete;

    private:
        LunarLog& m_logger;
        std::string m_key;
    };
} // namespace minta


#define LUNAR_LOG_CONTEXT __FILE__, __LINE__, __FUNCTION__

#endif // LUNAR_LOG_SINGLE_HEADER_HPP
